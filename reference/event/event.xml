<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 6ceccac7860f382f16ac1407baf54f656e85ca0b Maintainer: fernandowobeto Status: ready --><!-- CREDITS: fernandowobeto -->
<phpdoc:classref xml:id="class.event" xmlns:phpdoc="http://php.net/ns/phpdoc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude">
 <title>A classe Event</title>
 <titleabbrev>Event</titleabbrev>
 <partintro>
<!-- {{{ Event intro -->
  <section xml:id="event.intro">
   &reftitle.intro;
   <para>
    A classe <classname>Event</classname>
    representa um evento disparado em um descritor de arquivo pronto para leitura
    ou escrita; um descritor de arquivo ficando pronto para leitura ou gravação
   (somente E/S acionada por borda); um tempo limite expirando; um sinal ocorrendo; um
    evento acionado pelo usuário.
   </para>
   <para>
    Cada evento está associado a
    <classname>EventBase</classname>.
    Entretanto, o evento nunca será acionado até que seja
    <emphasis>adicionado</emphasis>
    (via
    <methodname>Event::add</methodname>).
    Um evento adicionado permanece no estado
    <emphasis>pendente</emphasis>
    até que o evento registrado ocorra, passando assim para o estado
    <emphasis>ativo</emphasis>.
    Para lidar com eventos, o usuário pode registrar um retorno de chamada que é chamado quando
    o evento se torna ativo. Se o evento estiver configurado
    como <emphasis>persistente</emphasis>,
    ele permanecerá pendente. Se não for persistente, ele deixa de ficar pendente quando
    o retorno de chamada é executado.
    O método <methodname>Event::del</methodname>
    <emphasis>deleta</emphasis>
    o evento, tornando-o não pendente. Através do método
    <methodname>Event::add</methodname>
    ele pode ser adicionado novamente.
   </para>
  </section>
<!-- }}} -->
  <section xml:id="event.synopsis">
   &reftitle.classsynopsis;

<!-- {{{ Synopsis -->
   <classsynopsis>
    <ooclass>
     <classname>Event</classname>
    </ooclass>
<!-- {{{ Class synopsis -->
    <classsynopsisinfo>
     <ooclass>
      <modifier>final</modifier>
      <classname>Event</classname>
     </ooclass>
    </classsynopsisinfo>
<!-- }}} -->
    <classsynopsisinfo role="comment">&Constants;</classsynopsisinfo>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>int</type>
     <varname linkend="event.constants.et">Event::ET</varname>
     <initializer>32</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>int</type>
     <varname linkend="event.constants.persist">Event::PERSIST</varname>
     <initializer>16</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>int</type>
     <varname linkend="event.constants.read">Event::READ</varname>
     <initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>int</type>
     <varname linkend="event.constants.write">Event::WRITE</varname>
     <initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>int</type>
     <varname linkend="event.constants.signal">Event::SIGNAL</varname>
     <initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>int</type>
     <varname linkend="event.constants.timeout">Event::TIMEOUT</varname>
     <initializer>1</initializer>
    </fieldsynopsis>
    <classsynopsisinfo role="comment">&Properties;</classsynopsisinfo>
    <fieldsynopsis>
     <modifier>public</modifier>
     <modifier>readonly</modifier>
     <type>bool</type>
     <varname linkend="event.props.pending">pending</varname>
    </fieldsynopsis>
    <classsynopsisinfo role="comment">&Methods;</classsynopsisinfo>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('class.event')/db:refentry/db:refsect1[@role='description']/descendant::db:methodsynopsis[1])" />
   </classsynopsis>
<!-- }}} -->
  </section>
<!-- {{{ Event properties -->
  <section xml:id="event.props">
   &reftitle.properties;
   <variablelist>
    <varlistentry xml:id="event.props.pending">
     <term>
      <varname>pending</varname>
     </term>
     <listitem>
      <para>
       Se o evento está pendente. Consulte
       <link linkend="event.persistence">Sobre persistência de eventos</link>
       .
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>
<!-- }}} -->
<!-- {{{ Event constants -->
  <section xml:id="event.constants">
   &reftitle.constants;
   <variablelist>
    <varlistentry xml:id="event.constants.et">
     <term>
      <constant>Event::ET</constant>
     </term>
     <listitem>
      <para>
       Indica que o evento deve ser acionado pela borda, se o backend da base de
       eventos subjacente suportar eventos acionados pela borda. Isso afeta a
       semântica de
       <constant>Event::READ</constant>
       e
       <constant>Event::WRITE</constant>
       .
      </para>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="event.constants.persist">
     <term>
      <constant>Event::PERSIST</constant>
     </term>
     <listitem>
      <para>
       Indica que o evento é persistente. Consulte
       <link linkend="event.persistence">Sobre persistência de eventos</link>
       .
      </para>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="event.constants.read">
     <term>
      <constant>Event::READ</constant>
     </term>
     <listitem>
      <para>
       Esta opção indica um evento que se torna ativo quando o descritor de arquivo fornecido
       (geralmente um recurso de fluxo ou socket) está pronto para leitura.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="event.constants.write">
     <term>
      <constant>Event::WRITE</constant>
     </term>
     <listitem>
      <para>
       Esta opção indica um evento que se torna ativo quando o descritor de arquivo fornecido
       (geralmente um recurso de fluxo ou socket) está pronto para leitura.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="event.constants.signal">
     <term>
      <constant>Event::SIGNAL</constant>
     </term>
     <listitem>
      <para>
       Usado para implementar a detecção de sinal. Consulte "Construindo eventos de sinal"
       abaixo.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="event.constants.timeout">
     <term>
      <constant>Event::TIMEOUT</constant>
     </term>
     <listitem>
      <para>
       Esta opção indica um evento que se torna ativo depois de decorrido um tempo
       limite.
      </para>
      <para>
       A
       flag <constant>Event::TIMEOUT</constant>
       é ignorada ao construir um evento: pode-se definir um
       tempo limite quando o evento é
       <emphasis>adicionado</emphasis>
       , ou não. É definido no argumento
       <literal>$what</literal>
       para a função de retorno de chamada quando ocorre um tempo limite.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>
<!-- }}} -->
 </partintro>

 &reference.event.entities.event;

</phpdoc:classref>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
