<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: a47dff201e3f65c07f6c84a535951632771cf72d Maintainer: leonardolara Status: ready --><!-- CREDITS: leonardolara -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="eventlistener.construct">
 <refnamediv>
  <refname>EventListener::__construct</refname>
  <refpurpose>Cria um novo ouvinte de conexão associado a uma base de eventos</refpurpose>
 </refnamediv>
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <modifier>public</modifier>
   <methodname>EventListener::__construct</methodname>
   <methodparam>
    <type>EventBase</type>
    <parameter>base</parameter>
   </methodparam>
   <methodparam>
    <type>callable</type>
    <parameter>cb</parameter>
   </methodparam>
   <methodparam>
    <type>mixed</type>
    <parameter>data</parameter>
   </methodparam>
   <methodparam>
    <type>int</type>
    <parameter>flags</parameter>
   </methodparam>
   <methodparam>
    <type>int</type>
    <parameter>backlog</parameter>
   </methodparam>
   <methodparam>
    <type>mixed</type>
    <parameter>target</parameter>
   </methodparam>
  </methodsynopsis>
  <para>
   Cria um novo ouvinte de conexão associado a uma base de eventos.
  </para>
 </refsect1>
 <refsect1 role="parameters">
  &reftitle.parameters;
  <variablelist>
   <varlistentry>
    <term>
     <parameter>base</parameter>
    </term>
    <listitem>
     <para>
      Base de evento associada.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <parameter>cb</parameter>
    </term>
    <listitem>
     <para>
      Uma função do tipo
      <type>callable</type>
      que será chamada quando um nova conexão for recebida.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <parameter>data</parameter>
    </term>
    <listitem>
     <para>
      Dados personalizados do usuário
      anexados a <parameter>cb</parameter>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <parameter>flags</parameter>
    </term>
    <listitem>
     <para>
      Máscara de bits das
      constantes
      <literal>EventListener::OPT_*</literal>.
      Consulte as <link linkend="eventlistener.constants">constantes EventListener</link>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <parameter>backlog</parameter>
    </term>
    <listitem>
     <para>
      Controla o número máximo de conexões pendentes que a pilha de rede
      deve permitir esperar em um estado ainda-não-aceito a qualquer momento; veja
      a documentação da função
      <literal>listen</literal>
      do seu sistema para mais detalhes. Se
      <parameter>backlog</parameter>
      for negativo, o Libevent tenta escolher um bom valor para o
      <parameter>backlog</parameter>;
      se for zero, o Event assume que
      <literal>listen</literal>
      já foi chamado no soquete (<parameter>target</parameter>).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <parameter>target</parameter>
    </term>
    <listitem>
     <para>
      Pode ser uma string, um recurso de soquete ou um fluxo associado a um soquete.
      Caso
      <parameter>target</parameter>
      seja uma string, ela será analisada como endereço de rede. Será
      interpretada como um caminho de soquete de domínio UNIX, se prefixada com
      <literal>'unix:'</literal>,
      por exemplo
      <literal>'unix:/tmp/my.sock'</literal>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
 <refsect1 role="changelog">
  &reftitle.changelog;
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>PECL event 1.5.0</entry>
      <entry>
       Adicionado suporte a soquetes de domínio UNIX.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </refsect1>
 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>
    Exemplo de <function>EventListener::__construct</function></title>
   <programlisting role="php">
<![CDATA[
<?php
/*
 * Servidor de eco simples baseado no ouvinte de conexão do libevent.
 *
 * Usage:
 * 1) Em uma janela de terminal, execute:
 *
 * $ php listener.php 9881
 *
 * 2) Em outra janela de terminal abra a conexão, por exemplo:
 *
 * $ nc 127.0.0.1 9881
 *
 * 3) Comece a digitar. O servidor deve repetir a entrada.
 */

class MyListenerConnection {
    private $bev, $base;

    public function __destruct() {
        $this->bev->free();
    }

    public function __construct($base, $fd) {
        $this->base = $base;

        $this->bev = new EventBufferEvent($base, $fd, EventBufferEvent::OPT_CLOSE_ON_FREE);

        $this->bev->setCallbacks(array($this, "echoReadCallback"), NULL,
            array($this, "echoEventCallback"), NULL);

        if (!$this->bev->enable(Event::READ)) {
            echo "Falha ao habilitar READ\n";
            return;
        }
    }

    public function echoReadCallback($bev, $ctx) {
        // Copia todos os dados do buffer de entrada para o buffer de saída

        // Variante #1
        $bev->output->addBuffer($bev->input);

        /* Variante #2 */
        /*
        $input    = $bev->getInput();
        $output = $bev->getOutput();
        $output->addBuffer($input);
        */
    }

    public function echoEventCallback($bev, $events, $ctx) {
        if ($events & EventBufferEvent::ERROR) {
            echo "Erro de bufferevent\n";
        }

        if ($events & (EventBufferEvent::EOF | EventBufferEvent::ERROR)) {
            //$bev->free();
            $this->__destruct();
        }
    }
}

class MyListener {
    public $base,
        $listener,
        $socket;
    private $conn = array();

    public function __destruct() {
        foreach ($this->conn as &$c) $c = NULL;
    }

    public function __construct($port) {
        $this->base = new EventBase();
        if (!$this->base) {
            echo "Não foi possível abrir a base de eventos";
            exit(1);
        }

        // Variante #1
        /*
        $this->socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        if (!socket_bind($this->socket, '0.0.0.0', $port)) {
            echo "Não é possível vincular o soquete\n";
            exit(1);
        }
        $this->listener = new EventListener($this->base,
            array($this, "acceptConnCallback"), $this->base,
            EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE,
            -1, $this->socket);
         */

        // Variante #2
         $this->listener = new EventListener($this->base,
             array($this, "acceptConnCallback"), $this->base,
             EventListener::OPT_CLOSE_ON_FREE | EventListener::OPT_REUSEABLE, -1,
             "0.0.0.0:$port");

        if (!$this->listener) {
            echo "Não foi possível criar o ouvinte";
            exit(1);
        }

        $this->listener->setErrorCallback(array($this, "accept_error_cb"));
    }

    public function dispatch() {
        $this->base->dispatch();
    }

    // Esta função de retorno é invocada quando há dados para ler em $bev
    public function acceptConnCallback($listener, $fd, $address, $ctx) {
        // Temos uma nova conexão! Configurando um bufferevent para ela. */
        $base = $this->base;
        $this->conn[] = new MyListenerConnection($base, $fd);
    }

    public function accept_error_cb($listener, $ctx) {
        $base = $this->base;

        fprintf(STDERR, "Ocorreu um erro %d (%s) no ouvinte. "
            ."Desligando.\n",
            EventUtil::getLastSocketErrno(),
            EventUtil::getLastSocketError());

        $base->exit(NULL);
    }
}

$port = 9808;

if ($argc > 1) {
    $port = (int) $argv[1];
}
if ($port <= 0 || $port > 65535) {
    exit("Porta inválida");
}

$l = new MyListener($port);
$l->dispatch();
?>
]]>
   </programlisting>
  </example>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
