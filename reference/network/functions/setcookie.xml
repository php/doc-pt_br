<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.11 Maintainer: thiago Status: ready -->
<refentry xml:id="function.setcookie" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <refnamediv>
  <refname>setcookie</refname>
  <refpurpose>Envia um cookie</refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>setcookie</methodname>
   <methodparam><type>string</type><parameter>nome</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>valor</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>expira</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>caminho</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>domínio</parameter></methodparam>
   <methodparam choice="opt"><type>bool</type><parameter>seguro</parameter></methodparam>
   <methodparam choice="opt"><type>bool</type><parameter>somente http</parameter></methodparam>
  </methodsynopsis>
  <para>
   A função <function>setcookie</function> define um cookie para ser enviado
   juntamente com o resto dos cabeçalhos HTTP. Como outros cabeçalhos
   (headers), os cookies devem ser enviados <emphasis>antes</emphasis> de
   qualquer saída do seu script (isso é uma restrição do protocolo). O que
   quer dizer que você deve colocar chamadas a essa função antes de qualquer
   saída, incluindo as tags <literal>&lt;html&gt;</literal> e
   <literal>&lt;head&gt;</literal> e também espaços em branco.
  </para>
  <para>
   Uma vez que o cookie foi setado, ele pode ser acessado através dos arrays
   <varname>$_COOKIE</varname> e <varname>$HTTP_COOKIE_VARS</varname>. Note
   que as <link linkend="language.variables.superglobals">superglobais</link>
   como <varname>$_COOKIE</varname> ou <varname>$HTTP_COOKIE_VARS</varname>
   estão disponíveis a partir do PHP 4.1.0.
   Os valores dos cookies também existem na variável
   <varname>$_REQUEST</varname>.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   Todos os argumentos, excento o <parameter>name</parameter>, são opcionais.
   Você pode também colocar como argumento uma string vazia 
   (<emphasis>&quot;&quot;</emphasis>) para pular o argumento. Por que o
   argumento <parameter>expire</parameter> é um inteiro, ele não pode ser
   escapado com uma string vazia, por isso utilize um zero
   (<emphasis>0</emphasis>) no lugar.
  </para>
  <para>
   Veja a <link xlink:href="&spec.cookies;">especificação de cookie do
    Netscape </link> para ver como cada parâmetro de
   <function>setcookie</function> funciona.
   <variablelist>
    <varlistentry>
     <term><parameter>nome</parameter></term>
     <listitem>
      <para>
       O nome do cookie.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>valor</parameter></term>
     <listitem>
      <para>
       O valor do cookie. Esse valor é guardado no computador do cliente; não
       guarde informação sensível.
       Supondo que o <parameter>nome</parameter> é 'nomedocookie', o valor
       pode ser lido través de
       <varname>$_COOKIE['nomedocookie']</varname>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>expira</parameter></term>
     <listitem>
      <para>
       O tempo para o cookie expirar. Esse valor é uma timestamp Unix,
       portanto é o número de segundos desde a época (epoch). Em outras
       palavras, você provavelmente irá utilizar isso com a função
       <function>time</function> mais o número de segundos que você quer que
       ele expire. Ou você pode utilizar a função <function>mktime</function>.
       </literal>time()+60*60*24*30</literal> irá configurar o cookie para
       expirar daqui a 30 dias. Se configurado para 0, ou omitido, o cookie irá
       expirar ao fim da sessao (quando o navegador fechar).
      </para>
      <para>
       <note>
        <para>
         Você pode ver que o parâmetro <parameter>expira</parameter> recebe
         uma timestamp Unix, ao contrário do formato de data <literal>Wdy,
          DD-Mon-YYYY HH:MM:SS GMT</literal>, isso se dá porque o PHP faz essa
         conversão internamente.
        </para>
        <para>
         <parameter>expira</parameter> é comparado com a hora do computador do
         cliente, que pode ser diferente da hora do servidor.
        </para>
       </note>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>caminho</parameter></term>
     <listitem>
      <para>
       O caminho no servidor aonde o cookie estará disponível. Se configurado
       para <literal>'/'</literal>, o cookie estará dosponível para todo o
       domínio. Se configurado para o diretório <literal>'/foo/'</literal>, o
       cookie estará disponível apenas dentro do diretório
       <literal>/foo/</literal> e todos os subdiretórios como
       <literal>/foo/bar</literal> do <parameter>domínio</parameter>. O valor
       padrão é o diretório atual aonde o cookie está sendo configurado.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>domínio</parameter></term>
     <listitem>
      <para>
       O domínio para qual o domínio estará disponível.
       Para fazer com que ele esteja disponível para todos os subdomínios de
       example.com então você deve configurar ele para
       <literal>'.example.com'</literal>. O <literal>.</literal> não é
       obrigatório mas faz com que seja compatível com mais navegadores.
       Configurando ele para <literal>www.example.com</literal> ele fará com
       que o cookie esteja disponível somente para o subdomínio
       <literal>www</literal>. Veja a especificação de <literal>'tail
        matching'</literal> em <link xlink:href="&spec.cookies;">spec</link>
       para maiores detalhes.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>seguro</parameter></term>
     <listitem>
      <para>
       Indica que o cookie só podera ser transimitido sob uma conexão segura HTTPS do
       cliente. Quando configurado para &true;. o cookie será enviado somente
       se uma conexão segura existir. O padrão é &false;. No lado do servidor,
       fica por conta do programador enviar esse tipo de cookie somente sob
       uma conexão segura (ex respeitando
       <varname>$_SERVER["HTTPS"]</varname>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>somente http</parameter></term>
     <listitem>
      <para>
       Quando for &true; o cookie será acessível somente sob o protocolo HTTP.
       Isso significa que o cookie não será acessível por linguagens de
       script, como JavaScript. Essa configuração pode efetivamente ajudar a
       reduzir ou identificar roubos através de ataques do tipo XSS
       (entretanto ela não é suportada por todos os browsers). Foi adicionada
       no PHP 5.2.0.
       &true; ou &false;
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Se existe saída antes da chamada dessa função,
   <function>setcookie</function> irá falhar e retornará &false;. Se a função
   <function>setcookie</function> executar com sucesso, ela retornará &true;.
   Isso não quer dizer que o usuário aceitou o cookie.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   Alguns exemplos para seguir de como enviar cookies:
   <example>
    <title>Exemplo de <function>setcookie</function> para enviar cookies</title>
    <programlisting role="php">
<![CDATA[
<?php
$value = 'alguma coisa de algum lugar';

setcookie("CookieTeste", $value);
setcookie("CookieTeste", $value, time()+3600);  /* expire in 1 hour */
setcookie("CookieTeste", $value, time()+3600, "/~rasmus/", ".example.com", 1);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Note que a porção do valor do cookie será automaticamente codificada com
   urlencode quando você enviar o cookie, e quando ele for recebido, será
   automaticamente decodificado e atribuido a uma variável com o mesmo nome do
   cookie. Se você não quer que isso aconteça, você pode utilizar no lugar a
   função <function>setrawcookie</function> se você estiver utilizando o PHP
   5. Para ver o conteúdo do nosso cookie de teste em um script, simplesmente
   utilize um dos exemplos abaixo:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Mostra um cookie individual
echo $_COOKIE["CookieTeste"];
echo $HTTP_COOKIE_VARS["CookieTeste"];

// Outra maneira de depurar(debug)/testar é vendo todos os cookies
print_r($_COOKIE);
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   <example>
    <title>Exemplo de <function>setcookie</function> para deletar exemplos</title>
    <para>
     Quando estiver deletando um cookie, tenha certeza de que a data de
     expiração dele está no passado, para acionar o mecanismo de remoção do
     seu navegador.
     O exemplo a seguir mostra como deletar os cookies enviados no exemplo
     anterior:
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// Configura a data de expiração para uma hora atrás
setcookie ("CookieTeste", "", time() - 3600);
setcookie ("CookieTeste", "", time() - 3600, "/~rasmus/", ".example.com", 1);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>A função <function>setcookie</function> e arrays</title>
    <para>
     Você pode também enviar cookies de array, utilizando a notação de array
     no nome dele. Isso tem o efeito de enviar tantos cookies quantos
     elementos houverem no array, mas quando o cookie for recebido todos os
     valores serão colocados em um array com o nome do cookie:
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// envia os cookies
setcookie("cookie[tres]", "cookietres");
setcookie("cookie[dois]", "cookiedois);
setcookie("cookie[um]", "cookieum");

// Depois que a página recarregar, mostra eles
if (isset($_COOKIE['cookie'])) {
    foreach ($_COOKIE['cookie'] as $nome => $valor) {
        echo "$nome : $valor <br />\n";
    }
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
tres : cookietres
dois : cookiedois
um : cookieum
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    A partir do PHP 4, você pode utilizar o output buffering para enviar 
    saída antes de chamar essa função, com o custo (overhead) de toda sua
    saída ser guardada em buffer até que você a envie. Você pode fazer isso
    chamando <function>ob_start</function> e <function>ob_end_flush</function>
    em seu script, ou configurando a diretiva
    <literal>output_buffering</literal> no seu &php.ini; ou arquivos de
    configuração do servidor.
   </para>
  </note>
  <note>
   <para>
    Se a diretiva <link linkend="ini.register-globals">register_globals</link>
    estiver configurada como <literal>on</literal> então os valores dos
    cookies serão colocadas em variáveis. Em nossos exemplos acima, a variável 
    <varname>$CookieTeste</varname> irá existir. É recomendado o uso de
    <varname>$_COOKIE</varname>.
   </para>
  </note>
  <para>
   Problemas comuns:
   <itemizedlist>
    <listitem>
     <simpara>
      Os cookies não estarão disponíveis até o próximo carregamento da página
      a qual o cookie deverá estar visível. Para testar se um cookie foi
      enviado com sucesso, verifique o cookie no próximo carregamento da
      página antes que ele expire. O tempo para expirar é configurado via o
      parâmetro <parameter>expira</parameter>. Uma maneira boa de depurar a
      existência dos cookies é chamando a função
      <literal>print_r($_COOKIE);</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Os cookies devem ser deletados com os mesmos parâmetros com os quais
      foram configurados. Se o argumento valor for uma string vazia, ou
      &false;, e todos os outros argumentos forem iguais a chamada anterior de
      setcookie, então o cookie com o nome especificado será deletado do
      cliente remoto.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Quando você configurar um cookie com o valor &false;, ele tentará
      deletar o cookie. Portanto evite utilizar valores booleanos. No lugar,
      utilize <emphasis>0</emphasis> para &false; e <emphasis>1</emphasis> for
      &true;.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nomes de cookies podem ser configurados como arrays e estarão disponíves
      para seus scripts PHP como arrays mas cookies separados serão guardados
      no sistema do usuário. Considere utilizar <function>explode</function>
      para enviar um cookie com nomes e valores múltiplos. Não é recomendado o
      uso da função <function>serialize</function> para esse propósito, pois
      ele pode resultar em furos de segurança.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <simpara>
   Várias chamadas para a função <function>setcookie</function> são feitas na
   ordem em que são chamadas.
  </simpara>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>header</function></member>
    <member><function>setrawcookie</function></member>
    <member><link linkend="features.cookies">cookies section</link></member>
    <member><link xlink:href="&url.rfc;2109">RFC 2109</link></member>
    <member><link xlink:href="&url.rfc;2965">RFC 2965</link></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
