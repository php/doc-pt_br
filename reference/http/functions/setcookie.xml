<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.30 Maintainer: fernandoc Status: ready -->
<!-- splitted from ./en/functions/http.xml, last change in rev 1.2 -->
  <refentry xml:id="function.setcookie" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <refnamediv>
    <refname>setcookie</refname>
    <refpurpose>Envia um cookie</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
     <methodsynopsis>
      <type>bool</type><methodname>setcookie</methodname>
      <methodparam><type>string</type><parameter>name</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>value</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>expire</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>path</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>domain</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>secure</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>setcookie</function> define um cookie para ser enviado junto com o resto dos
     cabeçalhos HTTP. Como outros cabeçalhos, cookies devem ser enviados
     <emphasis>antes</emphasis> de qualquer saída do seu script
     (esta é uma restrição do protocolo). Isto requer que você utilize esta função
     antes de qualquer saída, incluindo as tags
     <literal>&lt;html&gt;</literal> e <literal>&lt;head&gt;</literal>
     assim como quaiquer espaços em branco. Se já tiver sido enviada qualquer saída
     antes dessa função, <function>setcookie</function> irá falhar e retornar &false;.
     Se <function>setcookie</function> for bem sucedida, irá retornar
     &true;. Isto não indica que o usuário aceitou o cookie.
    </para>
    <note>
     <para>
      A partir do PHP 4, você pode usar o buffer de saída para enviar saída antes de utilizar
      esta função, o que fará com que toda a saída para o browser seja guardada em
      buffer no servidor até que você envie ela. Você poderá fazer isso utilizando as funções
      <function>ob_start</function> e <function>ob_end_flush</function>
      no seu script, ou definindo a diretiva de configuração
      <literal>output_buffering</literal>
      no seu &php.ini; ou nos arquivos de configuração do servidor.
     </para>
    </note>
    <para>
     Todos os argumentos com exceção de <parameter>name</parameter> são
     opcionais. Você pode também substituir um argumento com uma string vazia
     (<emphasis>&quot;&quot;</emphasis>) para pular este argumento. Devido a
     <parameter>expire</parameter> e <parameter>secure</parameter> serem inteiros,
     eles não podem ser pulados com uma string vazia, use um zero
     (<emphasis>0</emphasis>). A seguinte tabela explica cada parâmetro da função
     <function>setcookie</function>, Tenha certeza de ler
     <link xlink:href="&spec.cookies;">Netscape cookie specification</link> para
     detalhes de como funciona cada parâmetro de <function>setcookie</function>
     e <link xlink:href="&url.rfc;2965">RFC 2965</link> para informações
     adicionais de como cookies HTTP fucionam.
    </para>
    <para>
     <table>
      <title>Os parâmetros de <function>setcookie</function> explicados</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Parâmetro</entry>
         <entry>Descrição</entry>
         <entry>Exemplos</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><parameter>name</parameter></entry>
         <entry>
          O nome do cookie.
         </entry>
         <entry>
          'cookiename' é chamado como <varname>$_COOKIE['cookiename']</varname>
         </entry>
        </row>
        <row>
         <entry><parameter>value</parameter></entry>
         <entry>
          O valor do cookie. Este valor é guardado no computador do cliente,
          não guarde informações sensíveis.
         </entry>
         <entry>
          Assumindo que <parameter>name</parameter> e 'cookiename', este valor
          é obtido atraves de <varname>$_COOKIE['cookiename']</varname>
         </entry>
        </row>
        <row>
         <entry><parameter>expire</parameter></entry>
         <entry>
          O tempo para o cookie expirar. Este é um timestamp Unix assim
          é o número de segundos desde epoch. Em outras palavras, normalmente
          você vai definir com a função <function>time</function>
          mais o número de segundos que você queira té que expire. Ou
          você pode usar a função <function>mktime</function>.
         </entry>
         <entry>
          <literal>time()+60*60*24*30</literal> irá fazer com que o cookie
          expire em 30 dias. Se não for definido, o cookie irá expirar
          ao fim da sessão (quando o browser fechar).
         </entry>
        </row>
        <row>
         <entry><parameter>path</parameter></entry>
         <entry>
          O caminho no servidor para qual o cookie estará disponível.
         </entry>
         <entry>
          Se for definido <literal>'/'</literal>, o cookie estará
          disponível para todo o <parameter>domain</parameter>(domínio).
          Se for definido <literal>'/foo/'</literal>, o cookie estará disponível
          apenas no diretório <literal>/foo/</literal> e todos os
          sub-diretórios <literal>/foo/bar/</literal> de
          <parameter>domain</parameter>. O valor padrão é o diretório
          que o cookie esta sendo definido.
         </entry>
        </row>
        <row>
         <entry><parameter>domain</parameter></entry>
         <entry>
          O domínio que o cookie estará disponível.
         </entry>
         <entry>
          Para fazer o cookie estar disponível para todos os subdomínios de example.com
          então você deve definir como <literal>'.example.com'</literal>. O
          <literal>.</literal> não é requerido, mas torna compativel
          com mais browsers. Definindo como <literal>www.example.com</literal>
          fará o cookie estar disponível apenas para o subdomínio <literal>www</literal>.
          Você pode ler <link xlink:href="&spec.cookies;">spec</link> para maiores detalhes.
         </entry>
        </row>
        <row>
         <entry><parameter>secure</parameter></entry>
         <entry>
          Indica que o cookie deve ser transmitido sobre uma conexão segura HTTPS.
          Quando for definido como <literal>1</literal>, o cookie
          só será definido se existir uma conexão segura. O padrão é <literal>0</literal>.
         </entry>
         <entry>
          <literal>0</literal> ou <literal>1</literal>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Depois que os cookies foram definidos, eles podem ser acessados na próxima página com
     as matrizes <link linkend="reserved.variables.cookies">$_COOKIE</link> ou
     <varname>$HTTP_COOKIE_VARS</varname>. Note que,
     <link linkend="language.variables.superglobals">autoglobals</link>
     como <varname>$_COOKIE</varname> estão disponíveis a apartir do PHP
     <link xlink:href="&url.php.release4.1.0;">4.1.0</link>.
     <varname>$HTTP_COOKIE_VARS</varname> existe desde o PHP 3. Os valores dos cookies
     também existem em <link linkend="reserved.variables.request">
     $_REQUEST</link>.
    </para>
    <note>
     <para>
      Se a diretiva do PHP <link linkend="ini.register-globals">register_globals</link>
      estiver definida como <literal>on</literal> então os valores dos cookie também estarão
      em variáveis. Nos nossos exemplos abaixo, <varname>$TextCookie</varname> irá
      existir. É recomendado usar <varname>$_COOKIE</varname>.
     </para>
    </note>
    <para>
     Problemas comuns:
     <itemizedlist>
      <listitem>
       <simpara>
        Cookies não estarão visiveis até a próxima vez que a pagina para a qual devem estar
        visiveis seja carregada novamente. Para testar se um cookie foi realmente definido,
        confira o cookie na próxima vez que a pagina seja carregada e antes que expire.
        O tempo de expirar é definido pelo parâmetro <parameter>expire</parameter>.
        Uma maneira fácil de fazer o debug da existencia de cookies é simplesmente
        usar <literal>print_r($_COOKIE);</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Cookies devem ser excluídos com os mesmos parâmetros que foram criados.
        Se o argumento valor for uma string vazia (""), e todos os outros argumentos forem iguais,
        então o cookie com o nome especificado será excluído do cliente.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Nomes de cookies podem ser definidos como uma matriz de nomes e estará
        disponível nos scripts PHP como uma matriz, mas são guardados como cookies separados
        no sistema do usuário. Considere utilizar <function>explode</function> ou
        <function>serialize</function> para definir um cookie
        com multiplos nomes e valores.
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <simpara>
     No PHP 3, multiplas chamadas a <function>setcookie</function> no mesmo script
     serão feitas em ordem reversa. Se você esta tentando
     excluir um cookie antes de inserir outro, você deve colocar a inserção
     antes da exclusão. A partir do PHP 4, multiplas chamadas a
     <function>setcookie</function> são feitas na ordem de chamada.
    </simpara>
    <para>
     Alguns exemplos de como enviar cookies:
     <example>
      <title><function>setcookie</function> enviando cookies</title>
      <programlisting role="php">
<![CDATA[
<?php
$value = 'something from somewhere';

setcookie("TestCookie", $value);
setcookie("TestCookie", $value, time()+3600); /* expira em uma hora */
setcookie("TestCookie", $value, time()+3600, "/~rasmus/", ".example.com", 1);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Note que o valor do cookie será automaticamente codificado como
     url quando você envia o cookie, e quando é recebido, é automaticamente
     decodificado e definido para uma variável com o mesmo nome do cookie.
     Se você não quiser isto, você pode ao invés usar
     <function>setrawcookie</function> se você estiver usando o PHP 5. Para ver
     o conteúdo do nosso cookie de teste em um script, simplesmente use um dos
     seguintes exemplos:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Mostra um cookie
echo $_COOKIE["TestCookie"];
echo $HTTP_COOKIE_VARS["TestCookie"];

// Mostr todos os cookies
print_r($_COOKIE);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Quando estiver excluindo um cookie, você deve se assegurar que a data de expiração
     esta no passado, para ativar o mecanismo de remoção do seu browser.
     Exemplos a seguir de como excluir cookies enviados nos exemplos anteriores:
    </para>
    <para>
     <example>
      <title>Exemplo <function>setcookie</function> de exclusão</title>
      <programlisting role="php">
<![CDATA[
<?php
// define a data de expiração do cookie para uma hora atrás
setcookie ("TestCookie", "", time() - 3600);
setcookie ("TestCookie", "", time() - 3600, "/~rasmus/", ".example.com", 1);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Você pode também criar uma matriz de cookies usando a marcação de matriz no
     nome do cookie. Isto tem o efeito de definir tantos cookies quantos
     os elementos da matriz, mas quando o cookie é recebido pelo seu script,
     todos os cookies são colocados em uma matriz com o nome do cookie:
    </para>
    <para>
     <example>
      <title><function>setcookie</function> e matrizes</title>
      <programlisting role="php">
<![CDATA[
<?php
// define os cookies
setcookie("cookie[three]", "cookiethree");
setcookie("cookie[two]", "cookietwo");
setcookie("cookie[one]", "cookieone");

// após a pagina recarregar, mostra eles
if (isset($_COOKIE['cookie'])) {
    foreach ($_COOKIE['cookie'] as $name => $value) {
        echo "$name : $value <br />\n";
    }
}
?>
]]>
              </programlisting>
          <para>
           O qual mostra:
          </para>
          <screen>
    <![CDATA[
three : cookiethree
two : cookietwo
one : cookieone
]]>
      </screen>
     </example>
    </para>
    <note>
     <para>
      Para maiores informações sobre cookie, veja a espeficação de cookies da Netscape
      em <link xlink:href="&spec.cookies;">&spec.cookies;</link> e
      <link xlink:href="&url.rfc;2965">RFC 2965</link>.
     </para>
     <para>
      Você deve saber que <parameter>expire</parameter> leva um
      Unix timestamp, em oposição a uma data formatada <literal>Wdy, DD-Mon-YYYY
      HH:MM:SS GMT</literal>, isto é porque o PHP faz esta conversão internamente.
     </para>
      <para>
      <parameter>expire</parameter> é comparado com o horário do cliente o qual pode
      ser diferente do horário do servidor.
     </para>
    </note>
    <note>
     <simpara>
      Microsoft Internet Explorer 4 com Service Pack 1 não lida corretamente
      com cookies que tenham o parâmetro path definido.
     </simpara>
     <simpara>
      Netscape Communicator 4.05 e Microsoft Internet Explorer 3.x
      parecem não manusear corretamente cookies quando o path e time
      não estão definidos.
     </simpara>
    </note>
    <para>
     Veja também <function>header</function>, <function>setrawcookie</function> e a sessão sobre
     <link linkend="features.cookies">cookies</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
