<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.9 Maintainer: fernandoc Status: ready -->
<!-- splitted from ./en/functions/exec.xml, last change in rev 1.28 -->
  <refentry id='function.proc-open'>
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     Executa um comando e abre ponteiros de arquivos para entrada/saída
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descrição</title>
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>descriptorspec</parameter></methodparam>
      <methodparam><type>array</type><parameter>pipes</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> é similar a <function>popen</function>
     mas provê um controle muito maior sobre a execução do programa.
     <parameter>cmd</parameter> é o comando a ser executado pelo shell.
     <parameter>descriptorspec</parameter> é uma mariz indexada aonde a
     chave representa o número do descritor e o valor representa como o 
     PHP irá passar o descritor para o processo filho.
     <parameter>pipes</parameter> será definido como uma matriz de ponteiros de
     arquivos que corresponde no PHP a qualquer pipe que foi criado.
     O valor de retorno é um recurso representando o processo, você deve
     libera-lo usando <function>proc_close</function> quando você tiver terminado com ela.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin é um pipe a partir do qual o processo filho vai ler
   1 => array("pipe", "w"),  // stdout é um pipe a partir do qual o processo filho vai escrever
   2 => array("file", "/tmp/error-output.txt", "a") // stderr é um arquivo que será escrito
);
$process = proc_open("php", $descriptorspec, $pipes);
if (is_resource($process)) {
    // $pipes parece com isso agora:
    // 0 => manipulador de escrita conectado com o stdin do processo filho
    // 1 => manipulador de leitura conectado com o stdout do processo filho
    // Qualquer saída de erro será adicionada em /tmp/error-output.txt

    fwrite($pipes[0], "<?php echo \"Hello World!\"; ?>");
    fclose($pipes[0]);

    while (!feof($pipes[1])) {
        echo fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);
    // É importante que você feche qualquer pipe antes de usar
    // proc_close para evitar um travamento
    $return_value = proc_close($process);

    echo "command returned $return_value\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     O PHP 5RC2 introduz suporte pty para sistemas com Unix98 ptys. Isto permite ao
     seu script interagir com aplicações que esperão estar conversando com um terminal.
     Um pty funciona como um pipe, mas é bi-direcional, então não é
     necessário especificar um modo de leitura/escrita. O exemplo abaixo mostra como usar um pty;
     note que você não precisa ter todos os descritores conversando com um pty.
     Note também que apenas um pty é criado, mesmo que o pty seja especificado 3
     vezes. Em versões futuras do PHP, será possível fazer mais do que apenas
     ler e escrever para o pty.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Cria um pseudo terminal para o processo filho
$descriptorspec = array(
  0 => array("pty"),
  1 => array("pty"),
  2 => array("pty")
);
$process = proc_open("cvs -d:pserver:cvsread@cvs.php.net:/repository login", $descriptorspec, $pipes);
if (is_resource($process)) {
   // work with it here
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Os números de descritores em <parameter>descriptorspec</parameter>
     não saõ limitados a 0, 1 e 2 - você pode especificar qualquer número de descritor
     de arquivo válido e será passado para o processo filho. Isto permite ao seu script
     interagir com outros scripts que funcionam como "co-processos".
     Em particular, isto é útil para passar senhas para programas como
     PGP, GPG e openssl de uma maneira mais segura. É útil também para ler a
     informação de status provida por estes programas
     nos descritores de arquivos auxiliares.
    </para>
    <note>
     <para>
      Compatibilidade com o Windows: Descritores além do  2 (stderr) são
      disponibilizados para o Windows, mas desde que a arquitetura Windows
      não associa descritores de arquivos com os manipuladores de baixo nível,
      o processo filho não tem (ainda) meios de acessar estes manipuladores.
      Stdin, stdout e stderr funcionam como esperado.
     </para>
    </note>
    <note>
     <para>
      Se você precisa de um pipe de processo uni-direcional, use a função
      <function>popen</function> ao invés, já que ela é muito mais fácil de usar.
     </para>
    </note>

    <para>
     Veja também <function>stream_select</function>, <function>exec</function>,
     <function>system</function>,
     <function>passthru</function>, <function>popen</function>,
     <function>escapeshellcmd</function>, e o operador <link
     linkend="language.operators.execution">backtick</link>.
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
