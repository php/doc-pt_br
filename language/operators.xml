<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.53 Maintainer: ae Status: ready -->
 <chapter id="language.operators">
  <title>Operadores</title>
  <simpara>
  </simpara>

  <sect1 id="language.operators.precedence">
   <title>Precedência de Operadores</title>
   <para>
    A precedência de um operador especifica quem tem mais prioridade quando há
    duas delas juntas. Por exemplo, na expressão, <literal>1 +
    5 * 3</literal>, a resposta é <literal>16</literal> e não
    <literal>18</literal> porque o operador de multiplicação ("*")
    tem prioridade de precedência que o operador de adição ("+").
    Parênteses podem ser utilizados para forçar a precedência, se necessário.
    Assim, <literal>(1 + 5) * 3</literal> é avaliado como
    <literal>18</literal>.
   </para>
   <para>
    A tabela seguinte mostra a precedência dos operadores, da menor
    precedência para a maior.
    <table>
     <title>Precedência dos operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associação</entry>
        <entry>Operador</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>esquerda</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>não associativo</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>não associativo</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>não associativo</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <para>
     Mesmo tendo <literal>!</literal> maior precedência que
     <literal>=</literal>, o PHP ainda permitirá expressões
     similares à seguinte: <literal>if (!$a = foo())</literal>,
     que no caso terá como resultado que <literal>foo()</literal> é
     recebido em <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 id="language.operators.arithmetic">
   <title>Operadores Aritméticos</title>
   <simpara>
    Lembra-se da aritmética básica da escola? Estes operadores funcionam
    exatamente como aqueles.
   </simpara>
   <table>
    <title>Operadores Aritméticos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Adição</entry>
       <entry>Soma de $a e $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Subtração</entry>
       <entry>Diferença entre $a e $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplicação</entry>
       <entry>Produto de $a e $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisão</entry>
       <entry>Quociente de $a por $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Módulo</entry>
       <entry>Resto de $a dividido por $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
    <simpara>
    O operador de divisão ("/") sempre retorna um valor com ponto flutuante,
    mesmo que os dois operandos sejam inteiros (ou strings
    convetidos para inteiros).
   </simpara>
   <simpara>
    Veja também a página do manual
    <link linkend="ref.math">funções matemáticas</link>.
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>

  <sect1 id="language.operators.assignment">
   <title>Operadores de Atribuição</title>
   <simpara>
    O operador básico de atribuição é "=". A sua primeira inclinação deve ser
    a de pensar nisto como "é igual". Não. Isto quer dizer, na verdade, que o
    operando da esquerda recebe o valor da expressão da direita (ou seja,
    "é configurado para").
   </simpara>
   <para>
    O valor de uma expressão de atribuição é o valor atribuído. Ou seja,
    o valor de "$a = 3" é 3. Isto permite que você faça alguns
    truques:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = ($b = 4) + 5; // $a é igual a 9 agora e $b foi configurado como 4.
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Além do operador básico de atribuição, há "operadores
    combinados" para todos os operadores binários, aritméticos e de string,
    que permitem a você pegar um valor de uma expressão e então usar seu
    próprio valor para o resultado daquela expressão. Por exemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 3;
$a += 5; // configura $a para 8, como se disséssemos: $a = $a + 5;
$b = "Bom ";
$b .= "Dia!"; // configura $b para "Bom Dia!", como em $b = $b . "Dia!";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Note que a atribuição copia a variável original para a nova
    (atribuição por valor), assim a mudança de uma não afeta a
    outra. Isto pode ter relevância se você precisa copiar algo
    como uma grande matriz dentro de um loop longo. O PHP 4 suporta atribuições
    por referência, usando a sintaxe <computeroutput>$var =
    &amp;$outra_var;</computeroutput>, mas isto não é possível
    no PHP3. 'Atribuição por referência' significa que ambas as variáveis
    acabam apontando para os mesmos dados, e nada é copiado para lugar nenhum.
    Para aprender mais sobre referências, leia <link
    linkend="language.references">Referências explicadas</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>Operador Bit-a-bit</title>
   <simpara>
    Operadores bit-a-bit permitem que você acione ou desligue bits específicos dentro
    de um inteiro. Se ambos os parâmetros da esquerda e da direita forem
    strings, esses operadores irão trabalhar nos caracteres dessa
    string.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 12 ^ 9; // Imprime '5'

    echo "12" ^ "9"; // Imprime o caracter de volta (backspace - ASCII 8)
                     // ('1' (ASCII 49)) ^ ('9' (ASCII 57)) = 8

    echo "hallo" ^ "hello"; // Imprime os valores ASCII 0 4 0 0 0
                            // 'a' ^ 'e' = 4
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <table>
    <title>Operadores Bit-a-bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>E</entry>
       <entry>Os bits que estão ativos tanto em $a quanto em $b são ativados.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>OU</entry>
       <entry>Os bits que estão ativos em $a ou em $b são ativados.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>XOR</entry>
       <entry>
        Os bits que estão ativos em $a ou em $b, mas não em ambos, são ativados.
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>NÃO</entry>
       <entry>
        Os bits que estão ativos em $a não são ativados, e vice-versa.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Deslocamento à esquerda</entry>
       <entry>
        Desloca os bits de $a $b passos para a esquerda (cada passo significa
        "multiplica por dois")
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Deslocamento à direita</entry>
       <entry>
        Desloca os bits de $a $b passos para a direita (cada passo significa
        "divide por dois")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>Operadores de Comparação</title>
   <simpara>
    Operadores de comparação, como os seus nomes implicam, permitem que você
    compare dois valores. Você pode se interessar em ver 
    <link linkend="types.comparisons">as tabelas de comparação de tipos</link>,
    que tem exemplo das várias comparações entre tipos relacionadas.
   </simpara>
   <table>
    <title>Operadores de comparação</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Igual</entry>
       <entry>Verdadeiro (&true;) se $a é igual a $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Idêntico</entry>
       <entry>
        Verdadeiro (&true;) se $a é igual a $b, e eles são do mesmo
        tipo (somente para PHP4).
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diferente</entry>
       <entry>Verdadeiro se $a não é igual a $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diferente</entry>
       <entry>Verdadeiro se $a não é igual a $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Não idêntico</entry>
       <entry>
        Verdadeiro de $a não é igual a $b, ou eles não são do mesmo
        tipo (somente para o PHP4).
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Menor que</entry>
       <entry>Verdadeiro se $a é estritamente menor que $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maior que</entry>
       <entry>Verdadeiro se $a é estritamente maior que $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Menor ou igual</entry>
       <entry>Verdadeiro se $a é menor ou igual a $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maior ou igual</entry>
       <entry>Verdadeiro se $a é maior ou igual a $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Outro operador condicional é o operador "?:" (ou trinário),
    que opera como no C e em muitas outras linguagens.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Exemplo de uso do operador trinário
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// A instrucao assima eh identica a seguinte instrucao if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
     </programlisting>
    </informalexample>
    A expressão <literal>(expr1) ? (expr2) : (expr3)</literal>
    é avaliada para <replaceable>expr2</replaceable> se
    <replaceable>expr1</replaceable> é avaliada como &true;, ou
    <replaceable>expr3</replaceable> se
    <replaceable>expr1</replaceable> é avaliada como &false;.
   </para>
   <para>
    Vaj também <function>strcasecmp</function>,
    <function>strcmp</function>, e a seção do manual sobre
    <link linkend="language.types">Tipos</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Operadores de controle de erro</title>
   <simpara>
    O PHP suporta um operador de controle de erro: o sinal 'arroba' (@). Quando
    ele precede uma expressão em PHP, qualquer mensagem de erro que possa ser
    gerada por aquela expressão será ignorada.
   </simpara>
   <simpara>
    Se o recurso <link linkend="ini.track-errors">track_errors</link>
    estiver habilitado, qualquer mensagem de erro gerada pela expressão
    será gravada na variável global
    <link linkend="reserved.variables.phperrormsg">$php_errormsg</link>.
    Esta variável será sobrescrita em cada erro, assim verifique-a constantemente
    se você quiser usá-la.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Erro de arquivo intencional */
$my_file = @file ('arquivo_nao_existente') ou
    die ("Falha abrindo arquivo: '$php_errormsg'");

// Isto funciona para qualquer expressão, não apenas para funções:
$value = @$cache[$key];
// você não receberá nenhum aviso se a chave $key não existir.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     O operador @ funciona somente em
     <link linkend="language.expressions">expressões</link>. Uma regra simples para
     lembrar disso: se você pode pegar o valor de alguma coisa, você pode prefixar
     isso com o @. Assim, você pode prefixar chamadas de variáveis,
     funções e <function>include</function>s, constantes e
     afins. Você não pode prefixar definições de funções ou classe,
     estruturas condicionais como o <literal>if</literal>,
     <literal>foreach</literal> e assim por diante.
    </simpara>
   </note>
   <simpara>
    Veja também <function>error_reporting</function> e a seção do manual sobre
    <link linkend="ref.errorfunc">funções de Manipulação de Erros e Logging</link>.
   </simpara>
   <note>
    <para>
     O prefixo de controle de erro "@" não desabilita mensagens
     que são resultado de erros de interpretação (parse errors).
    </para>
   </note>
   <warning>
    <para>
     Atualmente, o operador de controle de erro "@" sempre desativa
     mensagens de erro, mesmo para erros críticos, que terminam a execução
     de scripts. Além de outras coisas, isto significa que se você usar "@" para
     suprimir erros de certas funções e elas não estiverem
     disponíveis ou com tipos incorretos, o script vai parar exatamente aí
     sem nenhuma indicação da razão.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.operators.execution">
   <title>Operadores de Execução</title>
   <para>
    O PHP suporta um operador de execução: acentos graves (``). Note que
    não são apóstrofes! O PHP tentará executar
    o conteúdo dos acentos graves como um comando do shell; a saída será
    retornada (isto é, ela não será simplesmente descarregada para a saída;
    ela pode ser atribuída a uma variável). A utilização do operador contra-apóstrofo é idêntica
    a função <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
$output = `ls -al`;
echo "<pre>$output</pre>";
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     O operador de execução fica desabilitado quando &safemode; está ativo
     ou <function>shell_exec</function> está desabilitado.
    </para>
   </note>
   <para>
    Veja também a seção do manual sobre <link linkend="ref.exec">funções
    de execução de programas</link>, <function>popen</function>
    <function>proc_open</function> e
    <link linkend="features.commandline">Utilizando o PHP em linha de
    comando</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Operadores de Incremento/Decremento</title>
   <para>
    O PHP suporta operadores de pré e pós-incremento e decremento
    no estilo C.
   </para>
   <table>
    <title>Operadores de Incremento/Decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Efeito</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pré-incremento</entry>
       <entry>Incrementa $a em um, e então retorna $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Pós-incremento</entry>
       <entry>Retorna $a, e então incrementa $a em um.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pré-decremento</entry>
       <entry>Decrementa $a em um, e então retorna $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Pós-decremento</entry>
       <entry>Retorna $a, e então decrementa $a em um.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Aqui está um script de exemplo simples:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Pós-incremento</h3>";
$a = 5;
echo "Deve ser 5: " . $a++ . "<br />\n";
echo "Deve ser 6: " . $a . "<br />\n";

echo "<h3>Pré-incremento</h3>";
$a = 5;
echo "Deve ser 6: " . ++$a . "<br />\n";
echo "Deve ser 6: " . $a . "<br />\n";

echo "<h3>Pós-decremento</h3>";
$a = 5;
echo "Deve ser 5: " . $a-- . "<br />\n";
echo "Deve ser 4: " . $a . "<br />\n";

echo "<h3>Pré-decremento</h3>";
$a = 5;
echo "Deve ser 4: " . --$a . "<br />\n";
echo "Deve ser 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    O PHP segue a convenção Perl quando tratando operações aritmétricas
    em variavéis caracter em vez da convenção C. Por exemplo, em Perl 'Z'+1 se torna
    'AA', enquanto que no C 'Z'+1 se torna '[' ( ord('Z') == 90, ord('[') == 91 ).
    Note que variáveis caracter podem ser incrementadas mas não decrementadas.
    <example>
     <title>Operações aritmétricas em variáveis caracter</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Produz uma saida similar a seguinte:

X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>Operadores Lógicos</title>

   <table>
    <title>Operadores Lógicos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>E</entry>
       <entry>Verdadeiro (&true;) se tanto $a quanto $b são verdadeiros.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>OU</entry>
       <entry>Verdadeiro se $a ou $b são verdadeiros.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>XOR</entry>
       <entry>Verdadeiro se $a ou $b são verdadeiros, mas não ambos.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>NÃO</entry>
       <entry>Verdadeiro se $a não é verdadeiro.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>E</entry>
       <entry>Verdadeiro se tanto $a quanto $b são verdadeiros.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>OU</entry>
       <entry>Verdadeiro se $a ou $b são verdadeiros.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
   	A razão para as duas variantes dos operandos "and" e "or"
   	é que eles operam com precedências diferentes. (Veja
   	<link linkend="language.operators.precedence">Precedência
   	de Operadores</link>.)
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Operadores de String</title>
   <simpara>
    Há dois operadores de string. O primeiro é o operador de concatenação
    ('.'), que retorna a concatenação dos seus argumentos direito e
    esquerdo. O segundo é o operador de atribuição de concatenação
    ('.='), que acrescenta o argumento do lado direito no
    argumento do lado esquerdo. Veja em <link 
    linkend="language.operators.assignment">Operadores
    de Atribuição </link> para mais informações.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = "Olá ";
$b = $a . "mundo!"; // agora $b contém "Olá mundo!"

$a = "Olá ";
$a .= "mundo!";     // agora $a contém "Olá mundo!"
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Veja também as seções do manual sobre o
    <link linkend="language.types.string">tipo String</link> e as
    <link linkend="ref.strings">funções de manipulação de Strings</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.array">
   <title>Operadores de Arrays</title>
   <simpara>
    O único operador de arrays no PHP é o <literal>+</literal>.
    Ele acrescenta o array informado à direita no array informado à esquerda, onde
    chaves duplicadas NÃO são sobrescritos.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = array("a" => "maçã", "b" => "banana");
$b = array("a" =>"pêra", "b" => "framboesa", "c" => "morango");

$c = $a + $b;

var_dump($c);
]]>
     </programlisting>
    </informalexample>
    Quando executado, o script produz uma saída assim:
    <screen role="php">
<![CDATA[
array(3) {
  ["a"]=>
  string(5) "maçã"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "morango"
}

]]>
    </screen>
   </para>
   <para>
    Veja também as seções do manual sobre o
    <link linkend="language.types.array">tipo Array</link> e
    <link linkend="ref.array">funções de manipulação de Arrays</link>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
