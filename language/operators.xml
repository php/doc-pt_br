<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 99ef98227f2d590d6124ebb4ebae0284a9d3e576 Maintainer: ae Status: ready --><!-- CREDITS: felipe,ae,fabioluciano,rogeriopradoj -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operadores</title>
  <simpara>
   Um operador é algo que recebe um ou mais valores (ou
   expressões, no jargão de programação) e que devolve outro valor (e por isso
   os operadores são expressões também).
  </simpara>
  <para>
   Operadores podem ser agrupados segundo o número de valores que aceitam. Operadores
   unários recebem um único valor, por exemplo <literal>!</literal> (o
   <link linkend="language.operators.logical">operador lógico de negação</link>) ou
   <literal>++</literal> (o
   <link linkend="language.operators.increment">operador de incremento</link>).
   Operadores binários aceitam dois valores, como os
   <link linkend="language.operators.arithmetic">operadores aritméticos</link>
   <literal>+</literal> (soma) e <literal>-</literal> (subtração), além
   da maioria dos operadores PHP dessa categoria. Finalmente há um
   único <link linkend="language.operators.comparison.ternary">operador
   ternário</link>, <literal>? :</literal>, que aceita três valores; normalmente
   conhecido simplesmente como "o operador ternário" (embora um
   nome melhor fosse operador condicional).
  </para>
  <para>
   A lista completa dos operadores no PHP está na seção sobre
   <link linkend="language.operators.precedence">Precedência de Operadores</link>.
   Essa seção também explica precedência e combinações, que governam
   exatamente como expressões contendo vários operadores são
   avaliados.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Precedência de Operadores</title>
   <para>
    A precedência de um operador especifica quem tem mais prioridade quando há
    duas delas juntas. Por exemplo, na expressão <literal>1 +
    5 * 3</literal>, a resposta é <literal>16</literal> e não
    <literal>18</literal> porque o operador de multiplicação ("*")
    tem prioridade de precedência que o operador de adição ("+").
    Parênteses podem ser utilizados para forçar a precedência, se necessário.
    Assim, <literal>(1 + 5) * 3</literal> é avaliado como
    <literal>18</literal>.
   </para>
   <para>
    Quando operadores têm precedência igual a associatividade decide
    como os operadores são agrupados. Por exemplo "-" é associado à esquerda, de forma que
    <literal>1 - 2 - 3</literal> é agrupado como <literal>(1 - 2) - 3</literal>
    e resulta em <literal>-4</literal>. "=" por outro lado
    associa para a direita, de forma que <literal>$a = $b = $c</literal> é agrupado como
    <literal>$a = ($b = $c)</literal>.
   </para>
   <para>
    Operadores de igual precedência e associatividade não podem
    ser utilizados uns próximos aos outros. Por exemplo <literal>1 &lt; 2 &gt; 1</literal> é
    ilegal no PHP. A expressão <literal>1 &lt;= 1 == 1</literal> por outro
    lado é válida, porque o operador <literal>==</literal> tem menor
    precedência que o operador <literal>&lt;=</literal>.
   </para>
   <para>
    A associatividade somente faz sentido para operadores binários e ternários.
    Operadores unários são precedentes ou seguintes, de forma que essa outra noção não se aplica.
    Por exemplo <literal>!!$a</literal> somente pode ser agrupado como <literal>!(!$a)</literal>.
   </para>
   <para>
    O uso de parênteses, embora não estritamente necessário, pode melhorar
    a leitura do código ao deixar o agrupamento explícito em vez de depender
    da associatividade e precedências implícitos.
   </para>
   <para>
    A tabela seguinte mostra a precedência dos operadores, com a maior
    precedência no começo. Operadores com a mesma precedência estão na mesma linha,
    nesses casos a associatividade deles decidirá qual ordem eles serão avaliados.
    <table>
     <title>Precedência dos operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associação</entry>
        <entry>Operadores</entry>
        <entry>Informação Adicional</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>(não aplicável)</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry>
        <entry><link linkend="language.oop5.cloning">clone</link> e <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">aritmética</link></entry>
       </row>
       <row>
        <entry>(não aplicável)</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>++</literal>
         <literal>--</literal>
         <literal>~</literal>
         <literal>(int)</literal>
         <literal>(float)</literal>
         <literal>(string)</literal>
         <literal>(array)</literal>
         <literal>(object)</literal>
         <literal>(bool)</literal>
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritméticos</link> (unário <literal>+</literal> e <literal>-</literal>),
         <link linkend="language.operators.increment">incremento/decremento</link>,
         <link linkend="language.operators.bitwise">bitwise</link>,
         <link linkend="language.types.typecasting">type cast</link>&listendand;
         <link linkend="language.operators.errorcontrol">controle de erro</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.operators.type">tipos</link>
        </entry>
       </row>
       <row>
        <entry>(não aplicável)</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmética</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmética</link> (binário <literal>+</literal> e <literal>-</literal>),
         <link linkend="language.operators.array">array</link>&listendand;
         <link linkend="language.operators.string">string</link> (<literal>.</literal> anteriormente ao PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry>
         <literal>&lt;&lt;</literal>
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">bits</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>.</literal></entry>
        <entry>
         <link linkend="language.operators.string">string</link> (desde o PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>não associativo</entry>
        <entry>
         <literal>&lt;</literal>
         <literal>&lt;=</literal>
         <literal>&gt;</literal>
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">comparação</link>
        </entry>
       </row>
       <row>
        <entry>não associativo</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal>
         <literal>===</literal>
         <literal>!==</literal>
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">comparação</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bits</link>&listendand;
         <link linkend="language.references">referências</link></entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bits</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bits</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.coalesce">null coalescing</link>
        </entry>
       </row>
       <row>
        <entry>não associativo</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">ternário</link>
         (esquerda anteriormente ao PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>direita</entry>
        <entry>
         <literal>=</literal>
         <literal>+=</literal>
         <literal>-=</literal>
         <literal>*=</literal>
         <literal>**=</literal>
         <literal>/=</literal>
         <literal>.=</literal>
         <literal>%=</literal>
         <literal>&amp;=</literal>
         <literal>|=</literal>
         <literal>^=</literal>
         <literal>&lt;&lt;=</literal>
         <literal>&gt;&gt;=</literal>
         <literal>??=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">atribuição</link>
        </entry>
       </row>
       <row>
        <entry>(não aplicável)</entry>
        <entry><literal>yield from</literal></entry>
        <entry>
         <link linkend="control-structures.yield.from">yield from</link>
        </entry>
       </row>
       <row>
        <entry>(não aplicável)</entry>
        <entry><literal>yield</literal></entry>
        <entry>
         <link linkend="control-structures.yield">yield</link>
        </entry>
       </row>
       <row>
        <entry>(não aplicável)</entry>
        <entry><literal>print</literal></entry>
        <entry><function>print</function></entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>esquerda</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>Associação</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// associação do operador ternário difere do C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (antes do PHP 8.0.0)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    A precedência e associatividade apenas determinam como as expressões são
    agrupadas, mas não especificam a ordem de avaliação. O PHP
    (geralmente) não especifica em que ordem as expressões são avaliadas,
    então códigos que assumem ordens específicas de avaliação devem ser evitados
    porque o comportamento pode ser alterado entre versões do PHP ou dependendo
    do código em volta.
    <example>
     <title>Ordem de avaliação não definida</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // pode imprimir 2 ou 3

$i = 1;
$array[$i] = $i++; // pode definir o índice 1 ou 2
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>, <literal>-</literal> and <literal>.</literal> possuem a mesma precedência</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// esta linha pode resultar em uma saída inesperada:
echo "x menos um é igual a " . $x-1 . ", ou assim eu espero\n";
// porque é avaliada como esta linha (antes do PHP  8.0.0):
echo (("x menos um é igual a " . $x) - 1) . ", ou assim eu espero\n";
// a precedência desejada pode ser aplicada utilizando parênteses:
echo "x menos um é igual a " . ($x-1) . ", ou assim eu espero\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, ou assim eu espero
-1, ou assim eu espero
x menos um é igual a 3, ou assim eu espero
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     Embora o <literal>=</literal> tenha uma precedência menor que
     a maioria dos operadores, o PHP ainda permite expressões
     similares a <literal>if (!$a = foo())</literal>,
     onde o valor retornado de <literal>foo()</literal> é
     colocado em <varname>$a</varname>.
    </para>
   </note>
   <sect2 role="changelog">
    &reftitle.changelog;
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>8.0.0</entry>
        <entry>
         Concatenação de strings (<literal>.</literal>) tem uma precedência menor que
         adição/subtração (<literal>+</literal> e <literal>-</literal>) e
         shift de bits à esquerda/direita (<literal>&lt;&lt;</literal> e <literal>&gt;&gt;</literal>);
         anteriormente ele tinha a mesma precedência que <literal>+</literal> e <literal>-</literal>
         uma precedência maior que <literal>&lt;&lt;</literal> e <literal>&gt;&gt;</literal>.
        </entry>
       </row>
       <row>
        <entry>8.0.0</entry>
        <entry>
         O operador ternário (<literal>? :</literal>) agora é não associativo;
         anteriormente associava a esquerda.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Depender da precedência da concatenação de strings (<literal>.</literal>) em relação
         à adição/subtração (<literal>+</literal> ou <literal>-</literal>) ou
         shift de bits a esquerda/direta (<literal>&lt;&lt;</literal> ou <literal>&gt;&gt;</literal>),
         ou seja, os usar numa mesma expressão, está obsoleto.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Depender da associatividade à esquerda do operador ternário (<literal>? :</literal>),
         ou seja, o utilizar em várias expressões sem parênteses, está obsoleto.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Operadores Aritméticos</title>
   <simpara>
    Lembra-se da aritmética básica da escola? Estes operadores funcionam
    exatamente como aqueles.
   </simpara>
   <table>
    <title>Operadores Aritméticos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Identidade</entry>
       <entry>
        Conversão de <varname>$a</varname> para <type>int</type> ou
        <type>float</type> conforme apropriado.
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>Negação</entry>
       <entry>Oposto de <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Adição</entry>
       <entry>Soma de <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Subtração</entry>
       <entry>Diferença entre <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplicação</entry>
       <entry>Produto de <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisão</entry>
       <entry>Quociente de <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Módulo</entry>
       <entry>Resto de <varname>$a</varname> dividido por <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Exponencial</entry>
       <entry>Resultado de <varname>$a</varname> elevado a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    O operador de divisão ("/") sempre retorna um valor com ponto flutuante,
    a não ser que os dois operandos sejam inteiros (ou strings que são convertidas para inteiros)
    e números inteiramente divisíveis, nesse caso um inteiro é retornado. Para
    divisão de inteiros, veja <function>intdiv</function>.
   </simpara>
   <simpara>
    Operandos de módulo são convertidos para <type>int</type>
    antes do processamento. Para módulos de ponto flutuante, veja
    <function>fmod</function>.
   </simpara>
   <para>
    O resultado do operador de módulo <literal>%</literal> tem o mesmo sinal
    do dividendo — ou seja, o resultado de <literal>$a % $b</literal>
    terá o mesmo sinal de <varname>$a</varname>. Exemplos:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // imprime 2
echo (5 % -3)."\n";          // imprime 2
echo (-5 % 3)."\n";          // imprime -2
echo (-5 % -3)."\n";         // imprime -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.math">Funções matemáticas</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operadores de Atribuição</title>
   <simpara>
    O operador básico de atribuição é "=". A sua primeira inclinação deve ser
    a de pensar nisto como "é igual". Não. Isto quer dizer, na verdade, que o
    operando da esquerda recebe o valor da expressão da direita (ou seja,
    "é definido para").
   </simpara>
   <para>
    O valor de uma expressão de atribuição é o valor atribuído. Ou seja,
    o valor de "<literal>$a = 3</literal>" é 3. Isto permite que você faça alguns
    truques:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a é igual a 9 agora e $b foi definido como 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Além do operador básico de atribuição, há "operadores
    combinados" para todos os <link linkend="language.operators">operadores
    aritméticos</link>, de array e string que permitem a você pegar um valor de uma
    expressão e então usar seu próprio valor para o resultado daquela expressão. Por
    exemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // define $a para 8, como se disséssemos: $a = $a + 5;
$b = "Bom ";
$b .= "Dia!"; // define $b para "Bom Dia!", como em $b = $b . "Dia!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Note que a atribuição copia a variável original para a nova
    (atribuição por valor), assim a mudança de uma não afeta a
    outra. Isto pode ser relevante se você precisa copiar algo
    como uma grande matriz dentro de um loop apertado.
   </para>
   <para>
    Uma exceção ao comportamento geral de atribuição ocorre
    com <type>object</type>s, que são atribuídos por referência.
    Objetos podem ser explicitamente copiados através da instrução <link
    linkend="language.oop5.cloning">clone</link>.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Atribuição por referência</title>
    <para>
     Atribuição por referência também é possível, utilizando-se a sintaxe
     "<computeroutput>$var = &amp;$othervar;</computeroutput>".
     A atribuição por referência significa que ambas as variáveis apontam
     para o mesmo dado, e nada é copiado.
    </para>
    <para>
     <example>
      <title>Atribuição por referência</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b é uma referência de $a

print "$a\n"; // imprime 3
print "$b\n"; // imprime 3

$a = 4; // modificamos $a

print "$a\n"; // imprime 4
print "$b\n"; // imprime 4 também, pois $b é uma referência de $a, que foi
              // modificada
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     O operador <link linkend="language.oop5.basic.new">new</link>
     retorna uma referência automaticamente, de forma que a atribuição de um resultado de
     <link linkend="language.oop5.basic.new">new</link> por referência é um erro.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Mais informações sobre referências e seus potenciais usos podem ser encontrados
     na seção <link linkend="language.references">Explicando Referências</link>
     do manual.
    </para>
   </sect2>

   <sect2 xml:id="language.operators.assignment.arithmetic">
    <title>Arithmetic Assignment Operators</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemplo</entry>
        <entry>Equivalente</entry>
        <entry>Operação</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a += $b</entry>
        <entry>$a = $a + $b</entry>
        <entry>Adição</entry>
       </row>
       <row>
        <entry>$a -= $b</entry>
        <entry>$a = $a - $b</entry>
        <entry>Subtração</entry>
       </row>
       <row>
        <entry>$a *= $b</entry>
        <entry>$a = $a * $b</entry>
        <entry>Multiplicação</entry>
       </row>
       <row>
        <entry>$a /= $b</entry>
        <entry>$a = $a / $b</entry>
        <entry>Divisão</entry>
       </row>
       <row>
        <entry>$a %= $b</entry>
        <entry>$a = $a % $b</entry>
        <entry>Módulo</entry>
       </row>
       <row>
        <entry>$a **= $b</entry>
        <entry>$a = $a ** $b</entry>
        <entry>Exponentiation</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.bitwise">
    <title>Operadores de bits</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemplo</entry>
        <entry>Equivalente</entry>
        <entry>Operação</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp;= $b</entry>
        <entry>$a = $a &amp; $b</entry>
        <entry>Bitwise E</entry>
       </row>
       <row>
        <entry>$a |= $b</entry>
        <entry>$a = $a | $b</entry>
        <entry>Bitwise Ou</entry>
       </row>
       <row>
        <entry>$a ^= $b</entry>
        <entry>$a = $a ^ $b</entry>
        <entry>Bitwise Xor</entry>
       </row>
       <row>
        <entry>$a &lt;&lt;= $b</entry>
        <entry>$a = $a &lt;&lt; $b</entry>
        <entry>Desloca para esquerda</entry>
       </row>
       <row>
        <entry>$a &gt;&gt;= $b</entry>
        <entry>$a = $a &gt;&gt; $b</entry>
        <entry>Desloca para direita</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.other">
    <title>Outras operações de assimilação</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemplo</entry>
        <entry>Equivalente</entry>
        <entry>Operação</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a .= $b</entry>
        <entry>$a = $a . $b</entry>
        <entry>Concatenação de strings</entry>
       </row>
       <row>
        <entry>$a ??= $b</entry>
        <entry>$a = $a ?? $b</entry>
        <entry>Aglutinação de nulls (null coalesce)</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.operators.arithmetic">operadores aritméticos</link></member>
      <member><link linkend="language.operators.bitwise">operadores em bits</link></member>
      <member><link linkend="language.operators.comparison.coalesce">operador de aglutinação de null</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operadores em bits (bitwise)</title>
   <simpara>
    Operadores bit-a-bit permitem a avaliação e modificação de bits
    específicos em um tipo inteiro.
   </simpara>
   <table>
    <title>Operadores Bit-a-bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>E (AND)</entry>
       <entry>Os bits que estão ativos tanto em <varname>$a</varname> quanto em <varname>$b</varname> são ativados.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>OU (OR inclusivo)</entry>
       <entry>Os bits que estão ativos em <varname>$a</varname> ou em <varname>$b</varname> são ativados.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>XOR (OR exclusivo)</entry>
       <entry>
        Os bits que estão ativos em <varname>$a</varname> ou em <varname>$b</varname>, mas não em ambos, são ativados.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>NÃO (NOT)</entry>
       <entry>
        Os bits que estão ativos em <varname>$a</varname> não são ativados, e vice-versa.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Deslocamento à esquerda</entry>
       <entry>
        Desloca os bits de <varname>$a</varname> em <varname>$b</varname> passos para a esquerda (cada passo significa
        "multiplica por dois")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Deslocamento à direita</entry>
       <entry>
        Desloca os bits de <varname>$a</varname> em <varname>$b</varname> passos para a direita (cada passo significa
        "divide por dois")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    O deslocamento de bits no PHP é aritmético.
    Bits deslocados no lado final são descartados.
    Deslocamentos à esquerda tem zeros inseridos à direita e o bit
    de sinal é perdido, e assim o sinal do operando
    não é preservado.
    Deslocamentos à direita tem cópias do bit de sinal à esquerda,
    e assim o sinal do operando é preservado.
   </para>
   <para>
    Utilize parênteses para garantir a
    <link linkend="language.operators.precedence">precedência</link> desejada.
    Por exemplo <literal>$a &amp; $b == true</literal> avalia primeiro
    a equivalência e depois a operação de bits, enquanto que
    <literal>($a &amp; $b) == true</literal> avalia primeiro a operação de bits e
    só depois a equivalência.
   </para>
   <para>
    Se ambos os operandos de <literal>&amp;</literal>, <literal>|</literal> e
    <literal>^</literal> forem strings então a operação será
    realizada nos valores ASCII dos caracteres das strings, e o
    resultado final será uma string. Em todos os outros casos ambos os operandos serão
    <link linkend="language.types.integer.casting">convertidos para inteiros</link>
    e o resultado será um inteiro.
   </para>
   <para>
    Se o operando de <literal>~</literal> for uma string então a
    operação será realizada nos valores ASCII dos caracteres da
    string, e o resultado será uma string. Nos demais casos o operando e o
    resultado serão tratados como inteiros.
   </para>
   <para>
    Ambos os operandos e o resultado para <literal>&lt;&lt;</literal> e
    <literal>&gt;&gt;</literal> sempre são tratados como inteiros.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
A configuração error_reporting ini utiliza valores posicionados em bits,
fornecendo um exemplo real de ligar ou desligar
bits. Para mostrar todos os erros mas não os alertas
coloque no php.ini:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Isto funciona pois começa com E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Depois pegando o valor de E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... que invertido através de <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
... é finalmente mesclado via E (&amp;) e assim o valor final
se torna:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Outra forma de conseguir esse efeito seria através do XOR (<literal>^</literal>)
e assim encontrar os bits que estão ativos em apenas um ou no outro:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
O error_reporting pode também ser utilizado para demonstrar a ativação de bits.
Para mostrar apenas erros e erros recuperáveis:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Este processo combina E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
e
<computeroutput>00000000000000000001000000000000</computeroutput>
utilizando OU (<literal>|</literal>)
para pegar os bits ativos de ambos os valores:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Operações bitwise AND, OR e XOR em inteiros</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignore essa primeira parte,
 * que é apenas para deixar a impressão mais limpa.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * Agora os exemplos
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Operador de bit E \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Operador de bit OU inlusivo \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Operador de bit OU Exclusivo (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Operador de bit E
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Operador de bit OU inlusivo
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Operador de bit OU Exclusivo (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Operações de bit XOR em strings</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Imprime '5'

echo "12" ^ "9"; // Imprime caracter backspace (ASCII 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Imprime os valores ASCII #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Imprime 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Imprime 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Deslocamento de bits em inteiros</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Aqui estão os exemplos.
 */

echo "\n--- MOVENDO BITS A DIREITA EM INTEIROS POSITIVOS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'cópia do bit de sinal trocada para a esquerda');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'move os bits para fora da direita');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'mesmo resultado que acima; não se pode mover além do 0');


echo "\n--- MOVENDO BITS A DIREITA EM INTEIROS NEGATIVOS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'cópia do bit de sinal trocada para a esquerda');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'move os bits para fora da direita');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'mesmo resultado que acima; não se pode mover além do -1');


echo "\n--- MOVENDO BITS A ESQUERDA EM INTEIROS POSITIVOS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'preenche com zeros o lado direito');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'bit de sinal movido para fora');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits movidos para fora da esquerda');


echo "\n--- MOVENDO BITS A ESQUERDA EM INTEIROS NEGATIVOS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'preenche com zeros o lado direito');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits movidos para fora pela esquerda, incluindo o bit de sinal');


/*
 * Ignore essa seção abaixo,
 * é apenas para formatar a saída e deixar mais clara a apresentação.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expressão: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binário:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTA: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- MOVENDO BITS A DIREITA EM INTEIROS POSITIVOS ---
Expressão: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binário:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTA: cópia do bit de sinal trocada para a esquerda

Expressão: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binário:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expressão: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binário:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: move os bits para fora da direita

Expressão: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binário:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: mesmo resultado que acima; não se pode mover além do 0


--- MOVENDO BITS A DIREITA EM INTEIROS NEGATIVOS ---
Expressão: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binário:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTA: cópia do bit de sinal trocada para a esquerda

Expressão: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binário:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: move os bits para fora da direita

Expressão: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binário:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: mesmo resultado que acima; não se pode mover além do -1


--- MOVENDO BITS A ESQUERDA EM INTEIROS POSITIVOS ---
Expressão: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binário:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTA: preenche com zeros o lado direito

Expressão: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binário:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expressão: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binário:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTA: bit de sinal movido para fora

Expressão: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binário:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: bits movidos para fora da esquerda


--- MOVENDO BITS A ESQUERDA EM INTEIROS NEGATIVOS ---
Expressão: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binário:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTA: preenche com zeros o lado direito

Expressão: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binário:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expressão: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binário:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTA: bits movidos para fora pela esquerda, incluindo o bit de sinal
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- MOVENDO BITS A DIREITA EM INTEIROS POSITIVOS ---
Expressão: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTA: cópia do bit de sinal trocada para a esquerda

Expressão: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expressão: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: move os bits para fora da direita

Expressão: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: mesmo resultado que acima; não se pode mover além do 0


--- MOVENDO BITS A DIREITA EM INTEIROS NEGATIVOS ---
Expressão: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binário:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTA: cópia do bit de sinal trocada para a esquerda

Expressão: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binário:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: move os bits para fora da direita

Expressão: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binário:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: mesmo resultado que acima; não se pode mover além do -1


--- MOVENDO BITS A ESQUERDA EM INTEIROS POSITIVOS ---
Expressão: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTA: preenche com zeros o lado direito

Expressão: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expressão: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTA: bit de sinal movido para fora

Expressão: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binário:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: bits movidos para fora da esquerda


--- MOVENDO BITS A ESQUERDA EM INTEIROS NEGATIVOS ---
Expressão: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binário:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTA: preenche com zeros o lado direito

Expressão: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binário:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expressão: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binário:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: bits movidos para fora pela esquerda, incluindo o bit de sinal
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Utilize as funções da extensão <link linkend="book.gmp">gmp</link> para manipulações
     de troca de bit em números maiores que <literal>PHP_INT_MAX</literal>.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
<!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
      <member><function>pack</function></member>
      <member><function>unpack</function></member>
      <member><function>gmp_and</function></member>
      <member><function>gmp_or</function></member>
      <member><function>gmp_xor</function></member>
      <member><function>gmp_testbit</function></member>
      <member><function>gmp_clrbit</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operadores de Comparação</title>
   <simpara>
    Operadores de comparação, como os seus nomes implicam, permitem que você
    compare dois valores. Você pode se interessar em ver
    <link linkend="types.comparisons">as tabelas de comparação de tipos</link>,
    que tem exemplo das várias comparações entre tipos relacionadas.
   </simpara>
   <table>
    <title>Operadores de comparação</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Igual</entry>
       <entry>&true; se <varname>$a</varname> é igual a <varname>$b</varname> após equalização de tipos.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Idêntico</entry>
       <entry>
        &true; se <varname>$a</varname> é igual a <varname>$b</varname>, e eles são do mesmo
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diferente</entry>
       <entry>&true; se <varname>$a</varname> não é igual a <varname>$b</varname> depois de equalização de ativos.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diferente</entry>
       <entry>&true; se <varname>$a</varname> não é igual a <varname>$b</varname> depois de equalização de ativos.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Não idêntico</entry>
       <entry>
        &true; se <varname>$a</varname> não é igual a <varname>$b</varname>, ou eles não são do mesmo
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Menor que</entry>
       <entry>&true; se <varname>$a</varname> é estritamente menor que <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maior que</entry>
       <entry>&true; se <varname>$a</varname> é estritamente maior que <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Menor ou igual</entry>
       <entry>&true; se <varname>$a</varname> é menor ou igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maior ou igual</entry>
       <entry>&true; se <varname>$a</varname> é maior ou igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Spaceship (nave espacial)</entry>
       <entry>
        Um <type>int</type> menor que, igual a ou maior que zero quando
        <varname>$a</varname> é, respectivamente, menor que, igual a ou maior
        que <varname>$b</varname>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Se ambos os operadores são
    <link linkend="language.types.numeric-strings">strings numéricas</link>,
    ou um operando é um número e o outro é uma
    <link linkend="language.types.numeric-strings">string numérica</link>,
    então a comparação é realizada numericamente.
    Estas regras se aplicam à instrução
    <link linkend="control-structures.switch">switch</link>.
    A conversão de tipos não é realizada quando a comparação é realizada através
    <literal>===</literal> ou <literal>!==</literal> porque aqui
    é realizada a comparação de tipos, além de valores.
   </para>

   <warning>
    <para>
     Anteriormente ao PHP 8.0.0, se uma <type>string</type> era comparada a um número
     ou uma string numérica, então a <type>string</type> era convertida para
     número antes de realizar a comparação. Isto pode levar a resultados
     inesperados, como observado no exemplo a seguir:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
      </programlisting>
      &example.outputs.7;
      <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
      </screen>
      &example.outputs.8;
      <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]>
      </screen>
     </informalexample>
    </para>
   </warning>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Integers
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Floats
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Strings
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Arrays
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Objects
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// valores e tipos precisam coincidir
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1

?>
]]>

     </programlisting>
    </informalexample>
   </para>

   <para>
    Para vários tipos, comparações são feitas de acordo com a seguinte
    tabela (em ordem).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Comparação com vários tipos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo do 1º operando</entry>
       <entry>Tipo do 2º operando</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> ou <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Converte &null; para "", numérico ou comparação léxica</entry>
      </row>
      <row>
       <entry><type>bool</type> or <type>null</type></entry>
       <entry>qualquer</entry>
       <entry>Converte para <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Classes nativas podem definir suas próprias comparações, classes diferentes
        são incomparáveis, same class see <link
        linkend="language.oop5.object-comparison">Comparação de Objetos</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> ou <type>float</type></entry>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> ou <type>float</type></entry>
       <entry>Transforma strings e resources para números</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>Array com menos membros é menor, se a chave do operando 1 não é
        encontrada no operando 2, então os arrays são incomparáveis, caso contrário compara
        valor por valor (veja o seguinte exemplo)</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>qualquer</entry>
       <entry><type>object</type> é sempre maior</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>qualquer</entry>
       <entry><type>array</type> é sempre maior</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <example>
     <title>Comparações de boolean e null</title>
     <programlisting role="php">
<![CDATA[
<?php
// Bool e null são sempre comparados como booleanos
var_dump(1 == TRUE);  // TRUE - same as (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - same as (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - same as (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - same as (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 is FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    <example>
     <title>Transcrição do padrão de comparação de array</title>
     <programlisting role="php">
<![CDATA[
<?php
// Arrays são comparados assim quando utilizando-se os operadores padrão e operador spaceship
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return 1;
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <warning>
    <title>Comparison of floating point numbers</title>

    <para>
     Por conta da forma que <type>float</type>s são representados internamente não
     se deve testar dois <type>float</type>s com o comparador de igualdade.
    </para>

    <para>
     Veja a documentação de <type>float</type> para mais detalhes.
    </para>
   </warning>

   <note>
    <simpara>
     Cuidado. A conversão automática de tipos do PHP não é sempre tão óbiva, quando comparando valores de tipos diferentes,
     particularmente comparando &integer;s para &boolean;s ou &integer;s para &string;s. No geral é
     recomendado utilizar as comparações <literal>===</literal> e <literal>!==</literal> em vez de utilizar
     <literal>==</literal> e <literal>!=</literal> na maioria dos casos.
    </simpara>
   </note>

   <sect2 xml:id="language.operators.comparison.incomparable">
    <title>Valores não comparáveis</title>
    <simpara>
     Embora a comparação de identidade (<literal>===</literal> e <literal>!==</literal>)
     possa ser aplicada para valores arbitrários, os outros operadores de comparação somente devem
     ser aplicados a valores comparáveis. O resultado de comparação de valores não comparáveis
     não é definida, e não pode ser garantida.
    </simpara>
   </sect2>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>strcasecmp</function></member>
      <member><function>strcmp</function></member>
      <member><link linkend="language.operators.array">Array operators</link></member>
      <member><link linkend="language.types">Types</link></member>
     </simplelist>
    </para>
   </sect2>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operador Ternário</title>
    <para>
     Outro operador condicional é o operador "?:" (ou ternário).
     <example>
      <title>Atribuindo um valor padrão</title>
      <programlisting role="php">
<![CDATA[
<?php
// Example usage for: Ternary Operator
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// The above is identical to this if/else statement
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
      </programlisting>
     </example>
     A expressão <literal>(expr1) ? (expr2) : (expr3)</literal>
     é avaliada para <replaceable>expr2</replaceable> se
     <replaceable>expr1</replaceable> é avaliada como &true;, ou
     <replaceable>expr3</replaceable> se
     <replaceable>expr1</replaceable> é avaliada como &false;.
    </para>
    <para>
     É possível deixar vazia a parte central do operador ternário.
     A expressão <literal>expr1 ?: expr3</literal> retorna
     o resultado de <replaceable>expr1</replaceable> se <replaceable>expr1</replaceable>
     avaliar para &true;, e <replaceable>expr3</replaceable> se não.
     <replaceable>expr1</replaceable> somente é avaliada nessa única situação.
    </para>
    <note>
     <simpara>
      Note que o operador ternário é uma expressão, e ele não é
      avaliado para uma variável, mas para o resultado de uma expressão. Isto é
      importante saber se você quer retornar uma variável por referência.
      A declaração <literal>return $var == 42 ? $a : $b;</literal> em uma
      função que retorna por referência conseqüêntemente não irá funcionar e será
      avisado.
     </simpara>
    </note>
    <note>
     <para>
      É recomendado evitar empilhar operadores ternários.
      O comportamento do PHP quando utilizando mais de um operador ternário sem parênteses numa única
      expressão é menos óbvia, comparada a outras linguagesn.
      Antes do PHP 8.0.0, os operadores ternários eram avaliados com associatividade à esquerda,
      em vez de associatividade à direta, como na maioria de outras linguagens.
      Depender da associatividade à esquerda está obsoleta desde o PHP 7.4.0.
      Desde o PHP 8.0.0, o operador ternário é não associativo.
      <example>
       <title>Comportamento não óbvio do ternário</title>
       <programlisting role="php">
<![CDATA[
<?php
// Pode parecer que a expressão a seguir imprime 'true'
echo (true ? 'true' : false ? 't' : 'f');

// No entanto, a saída é na verdade 't' antes do PHP 8.0.0
// Isto ocorre porque operadores ternários são associativos à esquerda

// O seguinte é a versão mais intuitiva do código acima
echo ((true ? 'true' : false) ? 't' : 'f');

// Aqui, é possível ver que a primeira expressão avalia para 'true', e então
// é avalidada para (bool)true, e portanto retorna o variante true da
// segunda expressão ternária
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <note>
     <para>
      Encadeamento de ternários curtos (<literal>?:</literal>), é estável, e comporta-se intuitivamente.
      Ele avaliará como o primeiro argumento que avalia para uma valor não falso. Observe que valores
      não definidos irão emitir um alerta.
      <example>
       <title>Encadeamento de ternários curtos</title>
       <programlisting role="php">
<![CDATA[
<?php
echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; //1
echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; //2
echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; //3
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>Operador de aglunitação null (Null Coalescing)</title>
    <para>
     Existe ainda o operador "??" (ou null coalescing).
     <example>
      <title>Atribuindo um valor padrão</title>
      <programlisting role="php">
<![CDATA[
<?php
// Exemplo do operador Null Coalesce
$action = $_POST['action'] ?? 'default';

// O conteúdo acima é idêntico à essa declaração if/else
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}
?>
]]>
      </programlisting>
     </example>
     A expressão <literal>(expr1) ?? (expr2)</literal> é avaliada para
     <replaceable>expr2</replaceable> se <replaceable>expr1</replaceable> for
     &null;, e <replaceable>expr1</replaceable> do contrário.
    </para>
    <para>
     Esse operador em particular não emite aviso caso o valor da esquerda
     não exista, assim como <function>isset</function>. Sendo especialmente
     útil em chaves de arrays.
    </para>
    <note>
     <simpara>
      Note que o operador null coalescing é uma expressão, e ele
      não é avaliado para uma variável, mas para o resultado de uma expressão. Isto
      é importante saber se você quer retornar uma variável por referência.
      A declaração <literal>return $foo ?? $bar;</literal> em uma
      função que retorna por referência conseqüêntemente não irá funcionar e será
      avisado.
     </simpara>
    </note>
    <note>
     <para>
      O operador de aglutinação null tem baixa precedência. Isso significa que misturá-lo
      com outros operadores (como por exemplo concatenação ou aritmética)
      irá provavelmente exigir parênteses.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// Emite um aviso que $name não está definido.
print 'Mr. ' . $name ?? 'Anonymous';

// Imprime "Mr. Anonymous"
print 'Mr. ' . ($name ?? 'Anonymous');
?>
]]>
     </programlisting>
    </note>
    <note>
     <para>
      Note que o operador null coalescing permite a criação de aninhamentos simples:
      <example>
       <title>Aninhando o operador null coalescing</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // exibe 1

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operadores de controle de erro</title>
   <simpara>
    O PHP suporta um operador de controle de erro: o sinal 'arroba' (<literal>@</literal>).
    Quando ele precede uma expressão em PHP, qualquer mensagem de erro que possa ser
    gerada por aquela expressão será ignorada.
   </simpara>
   <para>
    Se um manipulador de erro personalizado estiver configurado com
    <function>set_error_handler</function>, ele ainda assim será chamado,
    mesmo com a mensagem de diagnóstico suprimida.
   </para>

   <warning>
    <para>
     Antes do PHP 8.0.0, <function>error_reporting</function> chamada dentro de um manipulador de erro
     sempre retornava <literal>0</literal> se a mensagem de erro era suprimida pelo operador <literal>@</literal>.
     Desde o PHP 8.0.0, ele retorna o valor <literal>E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_RECOVERABLE_ERROR | E_PARSE</literal>.
    </para>
   </warning>

   <simpara>
    Quaisquer mensages de erro geradas an expressão fica disponível no elemento <literal>"message"</literal>
    do array retornado por <function>error_get_last</function>.
    O resultado daquela função irá se alterar em cada erro, então é necessário fazer a verificação imediatamente.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Erro de arquivo intencional */
$my_file = @file ('arquivo_nao_existente') or
    die ("Falha abrindo arquivo: erro foi '" . error_get_last()['message'] . "'");

// Isto funciona para qualquer expressão, não apenas para funções:
$value = @$cache[$key];
// você não receberá nenhum aviso se a chave $key não existir.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     O operador <literal>@</literal> funciona somente em
     <link linkend="language.expressions">expressões</link>.
     Uma regra simples para lembrar disso: se você pode pegar o valor de alguma coisa,
     você pode prefixar isso com o operador <literal>@</literal>.
     Por exemplo, ele pode prefixar variáveis, chamadas de funções,
     alguns constructos de linguagem (<function>include</function>),
     e assim por diante.
     O operador não pode ser prefixado em definições de classes ou funções,
     estruturas condicionais como <literal>if</literal>,
     &foreach;, e semelhantes.
    </simpara>
   </note>
   <warning>
    <para>
     Antes do PHP 8.0.0, o operador <literal>@</literal> conseguia
     inibir erros críticos que iriam encerrar a execução do script.
     Por exemplo, prefixar <literal>@</literal> numa chamada de uma função
     inexistente, por estar indisponível ou por erro de digitação, iria
     encerrar o script sem nenhuma indicação da causa.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>error_reporting</function></member>
      <member><link linkend="ref.errorfunc">Manipulação de erros e funções de log</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operadores de Execução</title>
   <para>
    O PHP suporta um operador de execução: acentos graves (``). Note que
    não são aspas simples! O PHP tentará executar
    o conteúdo dentro dos acentos graves como um comando do shell; a saída será
    retornada (isto é, ela não será simplesmente mostrada na tela;
    ela pode ser atribuída a uma variável). A utilização do operador acento grave é idêntica
    a da função <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     O operador de execução fica desabilitado quando
     <function>shell_exec</function> está desabilitado.
    </para>
   </note>
   <note>
    <para>
     Ao contrário de outras linguagens, acentos graves não tem sentido especial
     dentro de strings delimitadas por aspas.
    </para>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.exec">Funções de execução de programas</link></member>
      <member><function>popen</function></member>
      <member><function>proc_open</function></member>
      <member><link linkend="features.commandline">Utilizando o PHP em linha de comando</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operadores de Incremento/Decremento</title>
   <para>
    O PHP suporta operadores de pré e pós-incremento e decremento
    no estilo C.
   </para>
   <note>
    <simpara>
     Os operadores incremento/decremento afetam apenas números e strings.
     Arrays, objetos, booleanos e recursos não são afetados.
     Decrementar &null; não gera efeitos, mas incrementar resulta
     em <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operadores de Incremento/Decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Efeito</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pré-incremento</entry>
       <entry>Incrementa <varname>$a</varname> em um, e então retorna <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Pós-incremento</entry>
       <entry>Retorna <varname>$a</varname>, e então incrementa <varname>$a</varname> em um.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pré-decremento</entry>
       <entry>Diminuiu <varname>$a</varname> em um, e então retorna <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Pós-decremento</entry>
       <entry>Retorna <varname>$a</varname>, e então diminuir <varname>$a</varname> em um.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Aqui está um script de exemplo simples:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Pós-incremento</h3>";
$a = 5;
echo "Deve ser 5: " . $a++ . "<br />\n";
echo "Deve ser 6: " . $a . "<br />\n";

echo "<h3>Pré-incremento</h3>";
$a = 5;
echo "Deve ser 6: " . ++$a . "<br />\n";
echo "Deve ser 6: " . $a . "<br />\n";

echo "<h3>Pós-decremento</h3>";
$a = 5;
echo "Deve ser 5: " . $a-- . "<br />\n";
echo "Deve ser 4: " . $a . "<br />\n";

echo "<h3>Pré-decremento</h3>";
$a = 5;
echo "Deve ser 4: " . --$a . "<br />\n";
echo "Deve ser 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    O PHP segue a convenção Perl quando tratando operações aritmétricas
    em variavéis caracter em vez da convenção C. Por exemplo, em Perl
    <literal>$a = 'Z'; $a++;</literal> transforma <literal>$a</literal> em <literal>'AA'</literal> enquanto que em C
    <literal>a = 'Z'; a++;</literal> transforma <literal>a</literal> em <literal>'['</literal>
    (valor ASCII de <literal>'Z'</literal> é 90, valor ASCII <literal>'['</literal> é 91).
    Note que variáveis caracter podem ser incrementadas mas não decrementadas e
    somente letras e dígitos simples ASCII (a-z, A-Z and 0-9) são suportados.
    Incrementar ou decrementar outros caracteres não tem efeitos, a
    string original não sendo modificada.
    <example>
     <title>Operações aritmétricas em variáveis caractere</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Alphabetic strings ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// Alphanumeric strings behave differently
echo '== Alphanumeric strings ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Alphabetic strings ==
X
Y
Z
AA
AB
AC
== Alphanumeric strings ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementar ou decrementar booleanos não há efeito.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Operadores Lógicos</title>

   <table>
    <title>Operadores Lógicos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>E</entry>
       <entry>&true; se ambos <varname>$a</varname> e <varname>$b</varname> é &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>OU</entry>
       <entry>&true; se <varname>$a</varname> ou <varname>$b</varname> é &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>XOR</entry>
       <entry>&true; se <varname>$a</varname> ou <varname>$b</varname> é &true;, mas não ambos ao mesmo tempo.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Não</entry>
       <entry>&true; se <varname>$a</varname> não é &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>E</entry>
       <entry>&true; se ambos <varname>$a</varname> e <varname>$b</varname> são &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>OU</entry>
       <entry>&true; se <varname>$a</varname> ou <varname>$b</varname> é &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    A razão para as duas variantes dos operandos "and" e "or"
    é que eles operam com precedências diferentes. (Veja
    <link linkend="language.operators.precedence">Precedência
    de Operadores</link>.)
   </simpara>
   <example>
    <title>Ilustrando operadores lógicos</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() nunca será chamada porque toda a expressão sofre curto circuito

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" tem maior precedência que "or"

// O resultado da expressão (false || true) é atribuido em $e
// Funciona como: ($e = (false || true))
$e = false || true;

// A constante false é atribuída a $f antes que o "or" ocorra
// Funciona como: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" tem maior precedência que "and"

// O resultado da expressão (true && false) é atribuído em $g
// Funciona como: ($g = (true && false))
$g = true && false;

// A constante true é atribuída em $h antes que o "and" ocorra
// Funciona como: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operadores de String</title>
   <simpara>
    Há dois operadores de <type>string</type>. O primeiro é o operador de concatenação
    ('.'), que retorna a concatenação dos seus argumentos direito e
    esquerdo. O segundo é o operador de atribuição de concatenação
    ('<literal>.=</literal>'), que acrescenta o argumento do lado direito no
    argumento do lado esquerdo. Veja em <link
    linkend="language.operators.assignment">Operadores
    de Atribuição </link> para mais informações.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Olá ";
$b = $a . "mundo!"; // agora $b contém "Olá mundo!"

$a = "Olá ";
$a .= "mundo!";     // agora $a contém "Olá mundo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.string">Tipo string</link></member>
      <member><link linkend="ref.strings">Funções string</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Operadores de Arrays</title>
   <table>
    <title>Operadores de array</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemplo</entry>
       <entry>Nome</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>União</entry>
       <entry>União de <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Igualdade</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> tem as mesmas chaves e valores.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identidade</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> tem as mesmas chaves e valores, na mesma
        ordem e com os mesmos tipos.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Desigualdade</entry>
       <entry>&true; se <varname>$a</varname> não é igual <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Desigualdade</entry>
       <entry>&true; se <varname>$a</varname> não é igual <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Não identidade</entry>
       <entry>&true; se <varname>$a</varname> não é idêntico a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    O operador <literal>+</literal> retorna o array à direta anexado
    ao array da esquerda. Para chaves que existam nos dois arrays os elementos
    do array à esquerda serão mantidos, os valores de mesma chave no
    array da direita são ignorados.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Union of $b and $a
echo "Union of \$b and \$a: \n";
var_dump($c);

$a += $b; // Union of $a += $b is $a and $b
echo "Union of \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    Quando executado, o script produz uma saída assim:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
Union of $a += $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    Elementos do array são iguais para efeitos de comparação se eles possuem o mesmo
    valor e chave.
   </para>
   <para>
    <example>
     <title>Comparando arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("maçã", "banana");
$b = array(1 => "banana", "0" => "maçã");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.array">Tipo array</link></member>
      <member><link linkend="ref.array">Funções em arrays</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>Operadores de tipo</title>
   <para>
    <literal>instanceof</literal> é usado para determinar se um variável do PHP
    é uma objeto instânciado de uma certa
    <link linkend="language.oop5.basic.class">classe</link>:
    <example>
     <title>Usando <literal>instanceof</literal> com classes</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> pode também ser usado para determinar se uma variável
    é um objeto instânciado de uma classe que herda de uma classe pai:
    <example>
     <title>Usando <literal>instanceof</literal> com herança</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Para verificar se um objeto <emphasis>não</emphasis> é uma instância de uma classe, o
    <link linkend="language.operators.logical">operador lógico <literal>not</literal>
    </link> pode ser usado.
    <example>
     <title>Usando <literal>instanceof</literal> para verificar se o objeto <emphasis>não</emphasis> é uma
      instância da classe</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Por fim, <literal>instanceof</literal> pode também ser usado para determinar se
    uma variável é um objeto instânciado de uma classe que implementa uma
    <link linkend="language.oop5.interfaces">interface</link>:
    <example>
     <title>Usando <literal>instanceof</literal> para classe</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Embora <literal>instanceof</literal> é usualmente usado com um nome de classe literal,
    ele pode também ser usado com outro objeto ou uma variável string:
    <example>
     <title>Usando <literal>instanceof</literal> com outras variáveis</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b é umn objeto da classe MyClass
var_dump($a instanceof $c); // $c é uma string 'MyClass'
var_dump($a instanceof $d); // $d é uma string 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    instanceof não lança erros se a variável testada não for
    um objeto, apenas retorna &false;. Constantes não são permitidas
    anteriormente ao PHP 7.3.0.
    <example>
     <title>Utilizando <literal>instanceof</literal> para testar outras variáveis</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a é um inteiro
var_dump($b instanceof stdClass); // $b é NULL
var_dump($c instanceof stdClass); // $c é um resource
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    Desde oPHP 7.3.0, constantes são permitidas à esquerda do operador
    <literal>instanceof</literal>.
    <example>
     <title>Utilizando <literal>instanceof</literal> em constantes</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Desde o PHP 8.0.0, <literal>instanceof</literal> pode ser utilizado em expressões arbitrárias.
    A expressão precisa estar dentro parênteses e produzir uma <type>string</type>.
    <!-- RFC: https://wiki.php.net/rfc/variable_syntax_tweaks -->
    <example>
     <title>Usando <literal>instanceof</literal> em expressões arbitrárias</title>
     <programlisting role="php">
      <![CDATA[
<?php

class ClassA extends \stdClass {}
class ClassB extends \stdClass {}
class ClassC extends ClassB {}
class ClassD extends ClassA {}

function getSomeClass(): string
{
    return ClassA::class;
}

var_dump(new ClassA instanceof ('std' . 'Class'));
var_dump(new ClassB instanceof ('Class' . 'B'));
var_dump(new ClassC instanceof ('Class' . 'A'));
var_dump(new ClassD instanceof (getSomeClass()));
?>
]]>
     </programlisting>
     &example.outputs.8;
     <screen>
      <![CDATA[
bool(true)
bool(true)
bool(false)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    O operador <literal>instanceof</literal> tem uma variação funcional
    chamada <function>is_a</function> function.
   </simpara>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>get_class</function></member>
      <member><function>is_a</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
