<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.88 Maintainer: ae Status: ready -->
 <chapter id="language.types">
  <title>Tipos</title>

  <sect1 id="language.types.intro">
  <title>Introdução</title>

  <simpara>
   O PHP suporta os oitos tipos primitivos.
   <!-- (all types are primitive in php) -->
  </simpara>

  <para>
   São quatros tipos básicos:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">booleano</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">inteiro</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.float">número com ponto flutuante (float)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">string</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Dois tipos compostos:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">array</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">objeto</link>
     </simpara>
    </listitem>

   </itemizedlist>

   E finalmente dois tipos especiais:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">resource</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">NULL</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>
  
  <note>
   <simpara>
    Neste manual você encontrará parâmetros <literal>mixed</literal>. 
    Este pseudo tipo
    Indica múltiplas possibilidades para aquele parâmetro.
</simpara>
   <!--
   
   Just an idea, maybe useful for some func-defs?
   (at least it is for the operator-defs)

   <simpara>
    In parameter definitions you can also encounter the 'number' pseudo-type,
    that indicates a parameter that is either <type>integer</type> or
    <type>float</type>.
   </simpara>
   -->
  </note>


  <simpara>
   O tipo da variável geralmente não é configurado pelo programador: isto
   é decidido em tempo de execução pelo PHP, dependendo do contexto no qual a
   variável é usada.
  </simpara>
  <note>
   <simpara>
    Se você quiser checar o tipo e valor de uma certa <link
     linkend="language.expressions">expressão</link>, utilize
    <function>var_dump</function>.
   </simpara>
   <simpara>
    Se você simplesmente quiser uma representação legível de seu tipo para
    debugagem, use <function>gettype</function>. Para verificar por certos tipos,
    <emphasis>não use</emphasis> <function>gettype</function>, mas sim as funções
    <literal>is_<replaceable>type</replaceable></literal>.
   </simpara>
   <!-- TODO: example(s) would be maravilhoso -->
  </note>
  <simpara>
   Se você quiser forçar a conversão de uma variável para um certo tipo,
   você pode <link
   linkend="language.types.typecasting">moldar</link> (casting) a variável ou
   usar a função <function>settype</function> nela.
  </simpara>
  <simpara>
   Note que uma variável pode se comportar de maneiras diferentes em certas
   situações, dependendo de qual tipo ela é no momento. Para mais informações,
   veja a seção <link
   linkend="language.types.type-juggling">Manipulação de tipos</link>.
  </simpara>


   </sect1>

   <sect1 id="language.types.boolean">
    <title>Booleanos</title>

    <simpara>
     Este é o tipo mais fácil. Um<type>booleano</type> expressa um
     valor de verdade. Ele pode ser &true; ou
     &false;.
    </simpara>

    <note>
     <simpara>
      O tipo booleano foi introduzido no PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Sintaxe</title>
     <para>
      Para especificar um literal booleano, use as palavras chave &true;
      ou &false;. Ambas são insensitivas ao caso.
      <!-- technically they are just constants -->
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo = True; // assimila o valor TRUE para $foo
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Usualmente você pode
      utilizar algum tipo de <link linkend="language.operators">operador</link>
      que retorne um valor <type>booleano</type>, e passá-lo para
      uma <link linkend="control-structures">estrutura de
      controle</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == é um operador que retorna um booleano
if ($action == "mostrar_versao") {
    echo "A versão é 1.23";
}

// isto não é necessário
if ($exibir_separadores == TRUE) {
    echo "<hr>\n";
}

// porque você pode simplesmente escrever isso:
if ($exibir_separadores) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Convertendo para booleano</title>
      <simpara>
       Para converter explicitamente um valor para <type>booleano</type>, utilize-se dos
       modificadores <literal>(bool)</literal> ou <literal>(boolean)</literal>.
       Entretanto, na maioria dos casos, você não precisa utilizar o modificador, desde que qualquer valor
       será convertido automaticamente se um operador, função ou 
       estrutura de controle requerer um argumento <type>booleano</type>.
      </simpara>
      <simpara>
       Veja também <link linkend="language.types.type-juggling">Manipulação de tipos</link>.
      </simpara>

      <para>
       Quando convertendo para <type>booleano</type>, os seguintes valores
       são considerados &false;:

       <itemizedlist>
        <listitem>
         <simpara>o <link linkend="language.types.boolean">booleano</link>
          &false;<!-- duh... --></simpara>
        </listitem>
        <listitem>
         <simpara>o <link linkend="language.types.integer">inteiro</link
         > 0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>o <link linkend="language.types.float">ponto flutuante</link>
         0.0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>uma <link linkend="language.types.string"
           >string</link> vazia e a <link linkend="language.types.string"
           >string</link>
           "0"</simpara>
        </listitem>
        <listitem>
         <simpara>um <link linkend="language.types.array">array</link>
         sem elementos</simpara>
        </listitem>
        <listitem>
         <simpara>um <link linkend="language.types.object">objeto</link>
         sem elementos</simpara>
        </listitem>
        <listitem>
         <simpara>o tipo especial <link linkend="language.types.null"
           >NULL</link> (incluindo variáveis não definidas)
         </simpara>
        </listitem>
       </itemizedlist>

       Qualquer outro valor é considerado &true; (incluindo qualquer
       <link linkend="language.types.resource">recurso</link>).
       <warning>
        <simpara>
         <literal>-1</literal> é considerado
         &true;, como qualquer valor não zero (negativos
         ou positivos)!
        </simpara>
       </warning>
       <!-- TODO: add a few examples, for the people only looking at
            the examples... -->
      </para>

    </sect2>

   </sect1>

   <sect1 id="language.types.integer">
    <title>Inteiros</title>

    <simpara>
     Um <type>inteiro</type> é um número do conjunto
     Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>

    <para>
     Veja também:
     <link linkend="ref.gmp">Inteiros de tamanho arbitrário</link> e
     <link linkend="language.types.float">Números de ponto flutuante</link>
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Sintaxe</title>
     <simpara>
      Inteiros podem ser especificados em notação decimal (base 10), hexadecimal (base 16)
      ou octal (base 8), opcionalmente precedido de sinal (- ou +).
     </simpara>
     <para>
      Para usar a notação octal, você precisa preceder o número com um
      <literal>0</literal> (zero). Para utilizar a notação hexadecimal, preceda
      número com <literal>0x</literal>.
      <example>
       <title>Literais inteiras</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; # número decimal
$a = -123; # um número negativo
$a = 0123; # número octal (equivalente a 83 em decimal)
$a = 0x1A; # número hexadecimal (equivalente a 26 em decimal)
]]>
       </programlisting>
      </example>
      <!--

       decimal     : [1-9][0-9]*
                   | 0

       hexadecimal : 0[xX][0-9a-fA-F]+

       octal       : 0[0-7]+

       integer     : [+-]?decimal
                   | [+-]?hexadecimal
                   | [+-]?octal

       -->
      O tamanho de um inteiro é dependente de plataforma, sendo
      um numero aproximado a 2 bilhões o valor mais comum
      (número de 32 bits com sinal). O PHP não suporta inteiros
      não sinalizados.
     </para>
    </sect2>

    <sect2 id="language.types.integer.overflow">
     <title>Overflow de inteiros</title>
     <para>
      Se você especifica um número além dos limites do tipo <type>inteiro</type>,
      ele será interpretado como um <type>ponto flutuante</type>. Assim, se
      você realizar uma operação que resulte em um número além dos limites do
      tipo <type>inteiro</type>, um <type>ponto flutuante</type> será retornado
      também.

      <informalexample>
       <programlisting role="php">
<![CDATA[
$ numero_grande =  2147483647;
var_dump($numero_grande);
// saida: int(2147483647)

$numero_grande =  2147483648;
var_dump($numero_grande);
// saida: float(2147483648)

// isto também é permitido para especificação de números hexadecimais:
var_dump( 0x80000000 );
// saida: float(2147483648)

$milhao = 1000000;
$numero_grande =  50000 * $milhao;
var_dump($numero_grande);
// saida: float(50000000000)
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        Infelizmente, há um bug no PHP que faz que ele
        nem sempre trabalhe corretamente quando há números negativos
        envolvidos. Por exemplo, quando você faz <literal>-50000 *
        $milhao</literal>, o resultado será
        <literal>-429496728</literal>. Entretanto, quando ambos os operadores são
        positivos, isso não ocorre.
       </simpara>
       <simpara>
        Isto foi resolvido no PHP 4.1.0.
       </simpara>
      </warning>
     </para>
     <para>
      Não há operador de divisão inteira no PHP.
      <literal>1/2</literal> retorna o <type>ponto flutuante</type>
      <literal>0.5</literal>. <!-- See ??? for more information. (with the
      operators, or with type-jug) -->
      <informalexample>
       <programlisting role="php">
<![CDATA[
var_dump( 25/7 );
// saida: float(3.5714285714286)
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>


    <sect2 id="language.types.integer.casting">
     <title>Convertendo para inteiro</title>
      <simpara>
       Para converter explicitamente um valor para <type>inteiro</type>, utilize-se
       dos modificadores <literal>(int)</literal> ou <literal>(integer)</literal>.
       Entretanto, na maioria dos casos, você não precisa utilizar o modificador, desde que qualquer
       valor será automaticamente convertido se um operador, função ou
       estrutura de controle requerer um argumento <type>inteiro</type>.
      </simpara>
      <simpara>
       Veja também <link linkend="language.types.type-juggling">Manipulação de tipos</link>.
      </simpara>

      <sect3 id="language.types.integer.casting.from-boolean">
       <title>de <link linkend="language.types.boolean"
           >booleanos</link></title>
       <simpara>
        &false; será retornado como
        <literal>0</literal> (zero), e &true;
        como <literal>1</literal> (um).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>De <link linkend="language.types.float">números de ponto flutuante</link></title>
       <simpara>
        Quando convertendo de números de ponto flutuante para inteiros, o número será
        <emphasis>truncado</emphasis>.
       </simpara>

       <para>
        Se o número convertido estiver além dos limites de um inteiro
        <!-- usually, or is it 'always'? -->
        (usualmente <literal>+/- 2.15e+9 = 2^31</literal>),
        o resultado é indefinido, mesmo porque o ponto flutuante
        não tem a mesma precisão para fornecer um resultado inteiro exato.
        Não se preocupe, pois nenhum aviso será emitido neste
        caso!
       </para>

       <warning><para>
        Nunca modifique uma fração desconhecida para <type>inteiro</type>, porque isto pode
        fornecer resultados inesperados as vezes.
        <informalexample>
         <programlisting role="php">
<![CDATA[
echo (int) ( (0.1+0.7) * 10 ); // imprime 7!
]]>
         </programlisting>
        </informalexample>

        Para maiores informações, veja o <link
        linkend="warn.float-precision">alerta
        sobre a precisão de número flutuante.</link>.
       </para></warning>
      </sect3>

      <sect3 id="language.types.integer.casting.from-string">
       <title>De strings</title>
       <simpara>
        Veja <link linkend="language.types.string.conversion">Conversão
        de strings</link>
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-other">
       <title>De outros tipos</title>
       <para>
        <caution>
         <simpara>
          O comportamento da conversão de um inteiro é indefinido de outros
          tipos. Atualmente, o comportamento é o mesmo como se primeiro o
          valor fosse <link linkend="language.types.boolean.casting"
          >convertido para booleano</link>. Entretanto,
          <emphasis>não confie</emphasis> neste comportamento, pois ele pode
          mudar sem aviso.
         </simpara>
        </caution>
       </para>
       <!--

        IMO, it would more sense as (int) $arr returned the
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and
        (bool)(int) $arr will still behave the same.

        -->
      </sect3>

    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Números de ponto flutuante</title>
   <para>
    Números de ponto flutuante (AKA "floats", "doubles" ou "números reais") podem ser
    especificados utilizando qualquer uma das sintaxes seguintes:
    <synopsis>
$a = 1.234; $a = 1.2e3; $a = 7E-10;
    </synopsis>
    <!--

LNUM	[0-9]+
DNUM	([0-9]*[\.][0-9]+)|([0-9]+[\.][0-9]*)
EXPONENT_DNUM	(({LNUM}|{DNUM})[eE][+-]?{LNUM})

    -->
    O tamanho de um número de ponto flutuante é dependente de plataforma,
    sendo o máximo de ~1.8e308 com uma precisão de 14
    decimais digitais um valor comum (número de 64 bits no formato IEEE).
   </para>
   <warning id="warn.float-precision">
    <title>Precisão de números de ponto flutuante</title>
    <para>
     É sabido que frações simples como
     <literal>0.1</literal> ou <literal>0.7</literal> não podem ser
     convertidos em sua representação binária interna sem uma
     pequena perda de precisão. Isto pode causar erros confusos: por
     exemplo, <literal>floor((0.1+0.7)*10)</literal> irá retornar
     <literal>7</literal> em vez do esperado
     <literal>8</literal>, como resultado da representação interna
     realmente ser algo como <literal>7.9999999999...</literal>.
    </para>
    <para>
     Isto está relacionado ao fato de que é impossível expressar,
     exatamente, algumas frações em notação decimal com um número finito
     de dígitos. Por exemplo, <literal>1/3</literal> na forma decimal
     se torna <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Então, nunca confie em resultados com números de ponto flutuante até a última casa e
     nunca compare números de ponto flutuante em igualdades. Se você realmente
     precisar de alta precisão, você pode utilizar as <link
     linkend="ref.bc">funções matemáticas de precisão arbitrária</link>
     ou as funções relacionadas ao <link linkend="ref.gmp">gmp</link>.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.types.string">
   <title>Strings</title>
   <para>
    Uma <type>string</type> é uma série de caracteres. No PHP,
    um caracter é o mesmo que um byte, ou seja, há exatamente
    256 caracteres diferentes possíveis. Isto implica que o PHP
    não tem suporte nativo ao Unicode.
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     Não há nenhum problema nas strings se tornarem muito grandes.
     Não há nenhum limite para o tamanho de
     strings imposta pelo PHP, então não há razão
     para se preocupar com strings longas.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Sintaxe</title>
    <para>
     Uma string literal pode ser especificada de três formas
     diferentes.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">apóstrofo</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">aspas</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">sintaxe heredoc</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Apóstrofos</title>
     <para>
      A maneira mais simples para especificar uma string é
      delimitá-la entre apóstrofos (o caracter <literal>'</literal>).
     </para>
     <para>
      Para especificar um apóstrofo.
      você precisará "escapá-la" com uma contra barra
      (<literal>\</literal>), como em muitas outras linguagens.
      Se uma contra barra precisa ocorrer antes de um apóstrofo ou no
      final da string, você precisa duplicá-la.
      Note que se você tentar escapar qualquer
      outro caracter, a contra barra também será impressa! Então
      geralmente não é necessário escapar a própria contra barra.
      <note>
       <simpara>
        No PHP 3, um aviso
        com nível <literal>E_NOTICE</literal> será emitido quando
        isto acontecer.
       </simpara>
      </note>
      <note>
       <simpara>
        Diferentemente das duas outras sintaxes, variáveis <emphasis>não serão</emphasis>
        substituídas quando elas ocorrerem dentro de strings delimitadas por apóstrofes.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo 'isto é uma string comum';
echo 'Você pode incluir novas linhas em strings,
dessa maneira';
echo 'Arnold disse uma vez: "I\'ll be back"';
// saida: ... "I'll be back"
echo 'Você tem certeza em apagar C:\\*.*?';
// saida: ... apagar C:\*.*?
echo 'Você tem certeza em apagar C:\*.*?';
// output: ... apagar C:\*.*?
echo 'Estou tentando incluir uma nova linha \n neste ponto';
// output: ... nova linha \n neste ponto
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Aspas</title>
     <para>
      Se a string é delimitada entre aspas ("),
      o PHP entende mais seqüências de escape para caracteres
      especiais:
     </para>
     <table>
      <title>Seqüências de escape</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Seqüência</entry>
         <entry>Significado</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>fim de linha (linefeed ou LF ou 0x0A (10) em ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>retorno de carro (carriage return ou CR ou  0x0D (13) em ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>TAB horizontal (HT ou 0x09 (9) em ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>contra barra ou barra invertida</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>sinal de cifrão</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>aspas</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          a seqüência de caracteres batendo a expressão
          regular dos caracteres em notação octal
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          a seqüência de caracteres batendo a expressão
          regular de um caracter em notação hexadecimal
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Novamente se você tentar escapar qualquer outro caracter, a
      contra barra será impressa também!
     </para>
     <para>
      Mas o mais importante dado a respeito de strings delimitadas por aspas
      está no fato de que nome de variáveis serão substituídos.
      Veja <link linkend="language.types.string.parsing">interpretação de
      strings</link> para detalhes.
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Outra maneira para delimitar strings é utilizando a sintaxe heredoc
      ("&lt;&lt;&lt;"). É informado um identificador depois de
      <literal>&lt;&lt;&lt;</literal>, então a string, e então o
      mesmo identificador para fechar a delimitação.
     </simpara>
     <simpara>
      O identificador de fechamento <emphasis>precisa</emphasis> começar na
      primeira coluna da linha. Além, o identificador utilizado precisa seguir
      as mesmas regras de nomeação que qualquer outro rótulo no PHP: só pode conter
      caracteres alfanuméricos e sublinhados, e precisa começar com
      um caracter não numérico ou sublinhado.
     </simpara>

     <warning>
      <simpara>
       É muito importante verificar que a linha do identificador
       de fechamento não contenha nenhum outro caracter, exceto,
       <emphasis>possivelmente</emphasis> um ponto e vírgula (<literal>;</literal>).
       O que significa que o identificador
       <emphasis>não pode ser endentado</emphasis>, e que
       não pode haver nenhum espaço ou tabulações antes ou depois do ponto e vírgula.
      </simpara>
     </warning>

     <para>
      Textos heredoc se comportam como strings delimitadas por aspas, com
      apenas uma diferença. Você não precisa escapar apóstrofos e aspas
      em seus heredocs, mas você ainda pode continuar utilizando os códigos de escape listados
      acima. Variáveis são substituídas, mas o mesmo cuidado precisa ser tomado
      quando expressando variáveis complexas dentro de heredocs assim como
      nas strings.
      <example>
       <title>Exemplo de delimitação de strings heredoc</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Exemplo de uma string
distribuída em várias linhas
utilizando a sintaxe heredoc.
EOD;

/* Exemplo mais complexo, com variáveis */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Meu nome';

echo <<<EOT
Meu nome é "$name". Eu estou imprimindo $foo->foo.
Agora, eu estou imprimindo {$foo->bar[1]}.
Isto deve imprimir um 'A' maiúsculo: \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>

     <note>
      <para>
       O suporte a heredoc foi acrescentado no PHP 4.
      </para>
     </note>

    </sect3>
    <sect3 id="language.types.string.parsing">
     <title>Interpretação de variáveis</title>
     <simpara>
      Quando uma string é especificada dentro de aspas ou
      heredoc, variáveis são
      interpretadas dentro delas.
     </simpara>
     <simpara>
      Há dois tipos de sintaxe, um
      <link linkend="language.types.string.parsing.simple">simples</link>
      e um
      <link linkend="language.types.string.parsing.complex">complexo</link>
      .
      A sintaxe simples é a mais comum e conveniente, provendo uma maneira de
      interpretar uma variável, um valor de array ou uma propriedade de objeto.
     </simpara>
     <simpara>
      A sintaxe completa foi introduzida no PHP 4,
      <!-- XXX was it? and starting with what version exactly? -->
      e pode ser reconhecida
      por chaves ({}) envolvendo a expressão.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Sintaxe simples</title>
      <simpara>
       Se um sinal de cifrão (<literal>$</literal>) é encontrado, o
       interpretador tentará obter tantos identificadores quanto possíveis para formar um
       nome de variável válido. Envolva o nome da variável com chaves
       se você deseja explicitamente especificar o fim do nome.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$cerveja = 'Heineken';
echo "O sabor das '$cerveja's é otimo"; // funciona, "'" é um caracter inválido para nome de variáveis
echo "Ele bebeu algumas $cervejas";     // não funciona, 's' é um caracter válido para nome de variáveis
echo "Ele bebeu algumas ${cerveja}s";   // funciona
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Similarmente, você também pode interpretar um índice de array ou
       uma propriedade de objeto. Com índices de arrays, o colchete de fechamento
       (<literal>]</literal>) marca o final do índice. Para
       propriedades de objetos se aplicam as mesmas regras das variáveis comuns,
       embora não exista um truque para as propriedades de objetos como
       para as variáveis.

       <!-- XXX isn't &true; :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->

      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$frutas = array( 'morangos' => 'vermelho' , 'banana' => 'amarelo' );

// note que isto funciona diferentemente fora de delimitadores de string
echo "Uma banana é $frutas[banana].";

echo "Este quadrado tem $square->width metros de lado.";

// Não funciona. Para uma solução, veja a sintaxe complexa.
echo "Este quadrado tem $square->width00 centímetros de lado.";

]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad.";
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works,
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Para qualquer coisa mais complexa, você precisa utilizar a sintaxe complexa.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Sintaxe complexa (chaves)</title>
      <simpara>
       Isto não é chamado sintaxe complexa porque a sintaxe em si é complexa,
       mas porque você pode incluir expressões complexas desta maneira.
     </simpara>
     <simpara>
      De fato, você pode incluir qualquer valor no que esteja no espaço de nomes
      dentro de strings com esta sintaxe. Você simplesmente escreve a expressão
      da mesma maneira que faria fora da string, e então incluí-la
      entre chaves. Desde que você não pode escapar '{', esta sintaxe
      somente será reconhecida quando o $ é imediatamente seguido de um {.
      (Utilize "{\$" ou "\{$" para obter um literal "{$").
      Alguns exemplos para tornar isso mais claro:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$maravilhoso = 'fantástico';
echo "Isto é { $maravilhoso}"; // não funciona, imprime: Isto é { fantástico}
echo "Isto é {$maravilhoso}";  // funciona, imprime: Isto é fantástico
echo "Este quadrado tem {$square->width}00 centímetros de lado.";
echo "E isto funciona: {$arr[4][3]}";

// E isto está errado pela mesma razão
// como $foo[bar] é incorreto fora de uma string.
echo "Isto está errado: {$arr[foo][3]}";

echo "Você deve fazer desta maneira: {$arr['foo'][3]}";
echo "Você pode sempre escrever {$obj->values[3]->name}";
echo "Este é o valor da variável chamada $name: {${$name}}";
]]>
<!-- maybe it's better to leave this out??
// this works, but i disencourage its use, since this is NOT
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>

    <sect3 id="language.types.string.substr">
     <title>Acesso a caracteres da string</title>
     <para>
      Caracteres nas strings podem ser acessados apenas especificando o
      deslocamento baseado em zero do caracter desejado depois da string
      dentro de chaves.
     </para>
     <note>
      <simpara>
       Para manutenção de compatibilidade, você ainda pode utilizar colchetes.
       Entretanto, esta sintaxe for marcada como em extinção desde o PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Alguns exemplos com strings</title>
       <programlisting role="php">
<!-- TODO: either move these examples to a example section,
as with arrays, or distribute them under the applicable
sections. -->
<![CDATA[
<?php
/* Assimilando uma string. */
$str = "Isto é uma string";

/* Anexando a ela. */
$str = $str . " com uma pouco mais de texto";

/* Outra maneira de acrescentar, incluindo uma nova linha. */
$str .= " e um fim de linha no final (duh).\n";

/* Esta string será mostrada assim '<p>Número: 9</p>' */
$num = 9;
$str = "<p>Número: $num</p>";

/* Isto será apenas '<p>Número: $num</p>' */
$num = 9;
$str = '<p>Número: $num</p>';

/* Pega o primeiro caracter de uma string */
$str = 'Isto é um teste.';
$first = $str{0};

/* Pega o último caracter da string. */
$str = 'Isto ainda é um teste.';
$last = $str{strlen($str)-1};
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Funções úteis</title><!-- and operators -->
    <para>
     Strings podem ser concatenados utilizando o operador '.' (ponto). Note
     que o operador '+' (adição) não funciona para isso.
     Veja <link linkend="language.operators.string">operadores de
     string</link> para mais informações.
    </para>
    <para>
     Há uma grande quantidade de funções úteis para modificação de strings.
    </para>
    <simpara>
     Veja a seção de <link linkend="ref.strings">funções de string</link>
     para funções gerais e funções de expressões regulares para
     busca e substituição avançada.(em dois sabores:
     <link linkend="ref.pcre">Perl</link> e
     <link linkend="ref.regex">POSIX estendido</link>).
    </simpara>
    <simpara>
     Há também <link linkend="ref.url">funções para strings URL</link> e
     funções para criptografia e descriptografia de strings
     (<link linkend="ref.mcrypt">mcrypt</link> e
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalmente, se você ainda não encontrar o que está procurando,
     veja também as <link linkend="ref.ctype">funções de tipos de caracteres</link>.
    </simpara>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>Conversão de strings</title>

    <simpara>
     Quando uma string é avaliada como um valor numérico, o valor
     resultante e o tipo é determinado como segue.
    </simpara>
    <simpara>
     A string será avaliada como um <type>ponto flutuante</type> se conter qualquer um dos
     caracteres '.', 'e', ou 'E'. Em outros casos, ela será avaliada como
     um inteiro.
    </simpara>
    <para>
     O valor é obtido da porção inicial da string. Se a
     string começa com dados numéricos válidos, esse será o valor
     utilizado. Em outro caso, o valor será 0 (zero). Dados numéricos válidos
     são: um sinal opcional, seguido por um ou mais dígitos (opcionalmente
     contendo um ponto decimal), seguido de um expoente, também
     opcional. O expoente é um 'e' ou 'E' seguido de um ou mais
     dígitos.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$foo = 1 + "10.5";                // $foo é ponto flutuante (11.5)
$foo = 1 + "-1.3e3";              // $foo é ponto flutuante (-1299)
$foo = 1 + "bob-1.3e3";           // $foo é ponto inteiro (1)
$foo = 1 + "bob3";                // $foo é ponto inteiro (1)
$foo = 1 + "10 Small Pigs";       // $foo é ponto inteiro (11)
$foo = 4 + "10.2 Little Piggies"; // $foo é ponto flutuante (14.2)
$foo = "10.0 pigs " + 1;          // $foo é ponto flutuante (11)
$foo = "10.0 pigs " + 1.0;        // $foo é ponto flutuante (11)
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Para mais informações sobre esta conversão, veja página do manual UNIX
     de strtod(3).
    </simpara>
    <para>
     Se você deseja testar qualquer um dos exemplo dessa seção,
     você pode copiar e colar os exemplos e inserir as linhas seguintes
     para ver por si mesmo como isso funciona.
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo "\$foo==$foo; tipo " . gettype ($foo) . "<br />\n";
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Um array no PHP é atualmente um mapa ordenado. Um mapa é um tipo que
    relaciona <emphasis>valores</emphasis> para <emphasis>chaves</emphasis>.
    Este tipo é otimizado de várias maneiras,
    então você pode usá-lo como um array real, ou uma lista (vetor),
    hashtable (que é uma implementação de mapa),
    dicionário, <!-- is a map -->
    coleção,
    pilha, fila e provavelmente mais. Como você pode ter outro
    array PHP como um valor, você pode facilmente simular
    árvores.
   </para>
   <para>
    A explicação dessas estruturas estão além do escopo desse manual,
    mas você pode encontrar exemplos para cada uma dessas estruturas a seguir.
    Para mais informações sobre estruturas, refira-se a
    literatura externa sobre esses tópicos.
    <!-- like goodrich&tamassia: datastructures and algorithmes.
    Only, the subtitle is: in Java, and it's quite academic too -->
   </para>

   <sect2 id="language.types.array.syntax">
    <title>Sintaxe</title>

    <sect3 id="language.types.array.syntax.array-func">
     <title>Especificando com <function>array</function></title>
     <para>
      Um <type>array</type> pode ser criado com o construtor de linguagem
      <function>array</function>. Ele pega um certo número de pares separados por vírgula
      <literal><replaceable>chave</replaceable> =&gt; <replaceable
      >valor</replaceable></literal>
      .
     </para>
     <para>
      Uma <varname>chave</varname> pode ser tanto um <type>inteiro</type>
      ou uma <type>string</type>.
      Se a chave é uma representação padrão de um
      <type>inteiro</type>, ele será
      interpretado assim (por exemplo, <literal>"8"</literal> será interpretado
      como <literal>8</literal>, enquanto
      <literal>"08"</literal> será interpretado como <literal>"08"</literal>).
     </para>
     <para>
      O valor pode ser qualquer coisa.
     </para>
     <para>
      Se omitir a chave, o maior índice inteiro é obtido, e
      a nova chave será esse máximo + 1. Como inteiros podem ser negativos,
      isto também é verdadeiro para índices negativos. Sendo, por exemplo, o maior índice
      <literal>-6</literal>, resultará em um novo índice <literal>-5</literal>.
      Se nenhum índice inteiro existir
      ainda, a chave será <literal>0</literal> (zero). Se você especifica uma chave
      que já possui um valor assimilada a ela, então o valor é sobrescrito.
     </para>
     <para>
      Utilizar <literal>true</literal> como chave será interpretado como
      <type>inteiro</type> <literal>1</literal> na chave. Utilizando
      <literal>false</literal> como chave será avaliado como o <type>inteiro</type>
      <literal>0</literal>. Usar <literal>NULL</literal> como chave
      é interpretado como uma string vazia. Usar uma string vazia como chave irá
      criar (ou sobrescerver) uma chave com uma string vazia e seu valor, e isto
      não é o mesmo que usar colchetes vazios.
     </para>
     <para>
      Você não pode usar arrays ou objetos como chaves. Fazendo isso resultará em um
      alerta: <literal>Illegal offset type</literal>.
     </para>

     <para>
      <synopsis>
array( <optional> <replaceable>chave</replaceable> =&gt; </optional> <replaceable
>valor</replaceable>
     , ...
     )
// <replaceable>chave</replaceable> pode ser <type>string</type
                        > ou <type>integer</type> não negativo
// <replaceable>valor</replaceable> pode ser qualquer coisa
      </synopsis>
     </para>
    </sect3>

    <sect3 id="language.types.array.syntax.modifying">
     <title>Criando/modificando com a sintaxe de colchetes</title>
     <para>
      Você pode também modificar um array existente, explicitando assimilando
      valores.
     </para>
     <para>
      Isto é feito apenas assimilando valores para o array enquanto especificando a
      chave em colchetes. Você pode
      omitir a chave,
      colocando um par vazio
      de colchetes ("<literal>[]</literal>").
      <synopsis>
$arr[<replaceable>chave</replaceable>] = <replaceable>valor</replaceable>;
$arr[] = <replaceable>valor</replaceable>;
// <replaceable>chave</replaceable> tanto um <type>string</type
                        > ou <type>inteiro</type> não negativo
// <replaceable>valor</replaceable> pode ser qualquer coisa
      </synopsis>
      Se <varname>$arr</varname> não existir ainda, ele será criado.
      Então isto é
      um meio alternativo para especificar um array.
      Para mudar um certo valor, apenas assimile um novo valor
      para nele.
      Se você quiser remover um par chave/valor, você precisa
      aplicar <function>unset</function> nele.

     </para>

    </sect3>


   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>Funções úteis</title>
    <para>
     Há uma série de funções muito úteis para trabalhar
     com arrays, veja a seção sobre <link linkend="ref.array">arrays</link>
     .
    </para>
    <note>
     <para>
      A função <function>unset</function> permite apagar chaves de um
      array. Esteja avisado que o array NÃO vai ser reindexado.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$a = array( 1 => 'um', 2 => 'dois', 3 => 'três' );
unset( $a[2] );
/* irá produzir um array que pode ser definido como
   $a = array( 1=>'um', 3=>'três');
   e NÃO
   $a = array( 1 => 'um', 2 => 'três');
*/
]]>
      </programlisting>
     </informalexample>

     </para>
    </note>
    <para>
     <link linkend="control-structures.foreach">foreach</link>
     existe especificamente para lidar com arrays. Ele
     provém uma maneira fácil de percorrer qualquer array.
    </para>


   </sect2>

   <sect2 id="language.types.array.donts">
    <title>Array: faça e não faça</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Porque <literal>$foo[bar]</literal> está errado?</title>
     <para>
      Você sempre deve usar delimitadores em volta um índice de um array associativo.
      Por exemplo, utilizar $foo['bar'] e não $foo[bar]. Mas porque $foo[bar]
      está errado? Afinal de contas, você vê essa sintaxe nos scripts antigos:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo[bar] = 'inimigo';
echo $foo[bar];
// etc
]]>
       </programlisting>
      </informalexample>
      Isto está errado, mas funciona. Então, porque está errado? A razão está
      neste código, que tem uma constante indefinida (bar) em vez de uma string ('bar' -
      repare nos delimitadores), e o PHP pode no futuro definir constantes que,
      infelizmente em seu código, podem ter o mesmo nome. Isto funciona, porque
      constantes não definidas são convertidas em uma string com o mesmo nome.
     </para>
     <para>
      Como explicado na seção <link linkend="language.types.array.syntax"
      >sintaxe</link>, a chave precisa estar entre
      colchetes ('<literal>[</literal>' e '<literal>]</literal>').
      Isto significa que você pode escrever coisas como isso:
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo $arr[ foo(true) ];
]]>
       </programlisting>
      </informalexample>
      Isto é um exemplo de utilização de um valor de retorno de função
      como um índice de array. O PHP conhece constantes,
      como você deve ter visto
      <literal>E_*</literal> antes.

      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[E_ERROR] = "Um erro fatal ocorreu";
$error_descriptions[E_WARNING] = "O PHP emitiu um alarme";
$error_descriptions[E_NOTICE] = "Apenas um aviso informal";
]]>
       </programlisting>
      </informalexample>
      Note que <literal>E_ERROR</literal> é um identificador válido,
      assim como <literal>bar</literal> no primeiro exemplo. Mas no último
      exemplo seria a mesma coisa que escrevendo:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[1] = "Um erro fatal ocorreu";
$error_descriptions[2] = "O PHP emitiu um alarme";
$error_descriptions[8] = "Apenas um aviso informal";
]]>
       </programlisting>
      </informalexample>
      porque <literal>E_ERROR</literal> é igual a <literal>1</literal>, e assim por diante.
     </para>
     <para>
      Então, como é possível que <literal>$foo[bar]</literal> funcione?
      Funciona porque <literal>bar</literal>, na sintaxe onde é utilizada
      é esperada como uma expressão constante. Entretanto, nesse caso não
      existe constante com o nome <literal>bar</literal>. O PHP, hoje,
      assume que você quer <literal>bar</literal> literalmente,
      como a string <literal>"bar"</literal>, mas que você esqueceu
      de escrever os delimitadores.
     </para>
     <sect4>
      <title>Então, porque isso é tão mal?</title>
      <para>
       Se em algum ponto do futuro, o time do PHP quiser acrescentar outra
       constante ou palavra chave, você terá problemas. Por exemplo,
       se você já não pode utilizar as palavras <literal>empty</literal> e
       <literal>default</literal> dessa maneira, desde que elas são 
       <link linkend="reserved">palavras reservadas especiais</link>.
      </para>
      <note>
       <simpara>
        Quando você liga <link linkend="function.error-reporting"
        >error_reporting</link> em <literal>E_ALL</literal>,
        você irá ver as notícias que o PHP gera quando um
        <literal>índice</literal> é utilizado sem ser definido
        (coloque a linha <literal>error_reporting(E_ALL);</literal>
        em seu script).
       </simpara>
      </note>
      <note>
       <simpara>
        Com <type>string</type>s delimitadas por aspas, uma outra sintaxe
        é válida. Veja <link linkend="language.types.string.parsing"
        >interpretação de variáveis em string</link> para mais detalhes.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Exemplos</title>
    <para>
     O tipo array do PHP é muito versátil, por isso temos aqui alguns
     exemplos para mostrar todo o poder dos arrays.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
// isto
$a = array( 'color' => 'vermelha'
          , 'taste' => 'doce'
          , 'shape' => 'redonda'
          , 'name'  => 'maçã'
          ,            4        // a chave será 0
          );

// isto é equivalente a acima
$a['cor'] = 'vermelha';
$a['sabor'] = 'doce';
$a['formato'] = 'redonda';
$a['nome'] = 'maçã';
$a[]        = 4;        // a chave será 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// o mesmo de array( 0 => 'a' , 1 => 'b' , 2 => 'c' ),
// ou simplesmente array('a', 'b', 'c')
]]>
       </programlisting>
      </informalexample>
     </para>

    <example>
     <title>Utilizando array()</title>
     <programlisting role="php">
<![CDATA[
// Array como (propriedade-)mapa
$map = array( 'versão'     => 4
            , 'OS'         => 'Linux'
            , 'lang'       => 'inglês'
            , 'short_tags' => true
            );
            
// apenas chaves numéricas
$array = array( 7
              , 8
              , 0
              , 156
              , -10
              );
// que é o mesmo que array( 0 => 7, 1 => 8, ...)

$switching = array(         10 // chave = 0
                  , 5    =>  6
                  , 3    =>  7
                  , 'a'  =>  4
                  ,         11 // chave = 6 (o índice máximo era 5)
                  , '8'  =>  2 // chave = 8 (inteiro!)
                  , '02' => 77 // chave = '02'
                  , 0    => 12 // o valor 10 será sobrescrito por 12
                  );

// array vazio
$empty = array();
]]>
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Coleção</title>
     <programlisting role="php">
<![CDATA[
$cores = array('vermelho','azul','verde','amarelo');

foreach ( $cores as $cor ) {
    echo "Você gosta de $cor?\n";
}

/* saida:
Você gosta de vermelho?
Você gosta de azul?
Você gosta de verde?
Você gosta de amarelo?
*/
]]>
     </programlisting>
    </example>

    <para>
     Note que atualmente não se pode mudar os valores de um array
     diretamente dentro de um loop.
      <!--
       Should be made possible, if you write:
       foreach ( $cores as &$cor )
      
       See bug#3074
      -->
     Superar essa limitação é possível da seguinte forma:
     <example id="language.types.array.examples.changeloop">
      <title>Coleção</title>
      <programlisting role="php">
<![CDATA[
foreach ($cores as $key => $cor) {
    // não funciona:
    //$cor = strtoupper($cor);

    //funciona:
    $cores[$key] = strtoupper($cor);
}
print_r($cores);

/* saida:
Array
(
    [0] => VERMELHO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARELO
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Este exemplo cria um array na base 1.
     <example>
      <title>Array baseado em 1</title>
      <programlisting role="php">
<![CDATA[
$primeiroquarto  = array(1 => 'Janeiro', 'Fevereiro', 'Março');
print_r($primeiroquarto);

/* saida:
Array
(
    [1] => 'Janeiro'
    [2] => 'Fevereiro'
    [3] => 'Março'
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <example>
     <title>Preenchendo um array real</title>
     <programlisting role="php">
<![CDATA[
// preenchendo um array com todos os itens de um diretório
$handle = opendir('.');
while ($file = readdir($handle))
{
    $files[] = $file;
}
closedir($handle);
]]>
     </programlisting>
    </example>
    <para>
     Arrays são ordenados. Você pode mudar sua ordem utilizando vários
     funções de ordenação. Veja as <link linkend="ref.array">funções de arrays</link>
     para mais informações.
    </para>
    <example>
     <title>Ordenando arrays</title>
     <programlisting role="php">
<![CDATA[
sort($files);
print_r($files);
]]>
     </programlisting>
    </example>
    <para>
     Porque o valor de um array pode ser qualquer coisa, isto pode ser
     outro array. Isto pode criar arrays recursivos e
     multidimensionais.
    </para>
    <example>
     <title>Arrays recursivos e multidimensionais</title>
     <programlisting role="php">
<![CDATA[
$fruits = array ( "frutas"  => array ( "a" => "laranja"
                                     , "b" => "banana"
                                     , "c" => "maçã"
                                     )
                , "numeros" => array ( 1
                                     , 2
                                     , 3
                                     , 4
                                     , 5
                                     , 6
                                     )
                , "buracos" => array (      "primeiro"
                                     , 5 => "segundo"
                                     ,      "terceiro"
                                     )
                );
]]>
<!-- quite duplicate...
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);
-->
     </programlisting>
    </example>

   </sect2>

   <!-- TODO
   <sect2>
    <title>Misc</title>

   </sect2>

   - example multi-dim with $arr[bla][bla] syntax
   - converting to array
   - warning about references
   - note that assigning is copy (usually...)


   -->

<!-- there is no such thing as multi/singel dim arrays (at least in PHP4)
   <sect2 id="language.types.array.single-dim">
    <title>Single Dimension Arrays</title>

    <para>
     PHP supports both scalar and associative arrays. In fact, there
     is no difference between the two.  You can create an array using
     the

     <function>list</function>

     Nope




     or <function>array</function>
     functions, or you can explicitly set each array element value.
     <informalexample>
      <programlisting role="php">
$a[0] = "abc";
$a[1] = "def";
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can also create an array by simply adding values to the
     array. When you assign a value to an array variable using empty
     brackets, the value will be added onto the end of the array.
     <informalexample>
      <programlisting role="php">
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world"
      </programlisting>
     </informalexample>
    </para>
    <para>
     Arrays may be sorted using the <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, and
     <function>uksort</function> functions depending on the type of
     sort you want.
    </para>
    <para>
     You can count the number of items in an array using the
     <function>count</function> function.
    </para>
    <para>
     You can traverse an array using <function>next</function> and
     <function>prev</function> functions.  Another common way to
     traverse an array is to use the <function>each</function>
     function.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Multi-Dimensional Arrays</title>

    <para>
     Multi-dimensional arrays are actually pretty simple.  For each
     dimension of the array, you add another [key] value to the end:
     <informalexample>
      <programlisting role="php">
$a[1]      = $f;               # one dimensional examples
$a["foo"]  = $f;

$a[1][0]     = $f;             # two dimensional
$a["foo"][2] = $f;             # (you can mix numeric and associative indices)
$a[3]["bar"] = $f;             # (you can mix numeric and associative indices)

$a["foo"][4]["bar"][0] = $f;   # four dimensional!
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 3 it is not possible to reference multidimensional arrays
     directly within strings. For instance, the following will not
     have the desired result:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This won't work: $a[3][bar]";
      </programlisting>
     </informalexample>
     In PHP 3, the above will output <computeroutput>This won't work:
     Array[bar]</computeroutput>. The string concatenation operator,
     however, can be used to overcome this:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: " . $a[3]['bar'];
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 4, however, the whole problem may be circumvented by
     enclosing the array reference (inside the string) in curly
     braces:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can "fill up" multi-dimensional arrays in many ways, but the
     trickiest one to understand is how to use the
     <function>array</function> command for associative arrays.  These
     two snippets of code fill up the one-dimensional array in the
     same way:
     <informalexample>
      <programlisting role="php">
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     The <function>array</function> function can be nested for
     multi-dimensional arrays:
     <informalexample>
      <programlisting role="php">
&lt;?php
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>

   -->
  </sect1>

  <sect1 id="language.types.object">
   <title>Objetos</title>

   <sect2 id="language.types.object.init">
    <title>Inicialização de objetos</title>

    <para>
     Para inicializar um objeto, você usa a instrução <literal>new</literal>,
     criando uma instância do objeto em uma variável.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Fazendo foo.";
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Para uma explicação completa, consulte a seção <link
     linkend="language.oop">Classes e Objetos</link>.
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>

    <para>
     Recurso é uma variável especial, mantendo
     uma referência de recurso externo. Recursos
     são criados e utilizados por funções especiais.
     Veja o <link linkend="resource">apêndice</link>
     para uma lista de todas essas
     funções e seus tipos correspondentes.

    </para>

    <note>
     <simpara>
      O tipo resource foi incluído no PHP 4
     </simpara>
    </note>

    <sect2 id="language.types.resource.self-destruct">
     <title>Liberando recursos</title>

    <para>
     Através do sistema de contagem de referências introduzido
     com o engine da Zend no PHP 4, é automaticamente detectado
     quando um recurso não mais é referenciado (assim
     como o Java). Quando isto
     acontece, todos os recursos em uso por esse
     resource são liberados pelo coletor de lixo.
     Por essa razão, é raramente necessário
     liberar memória manualmente utilizando alguma função
     free_result.
     <note>
      <simpara>
       Conexões persistentes de bancos são especiais. Eles
       <emphasis>não são</emphasis> destruídos pelo
       coletor de lixo. Veja também <link
       linkend="features.persistent-connections">conexões
       permanentes</link>.
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.null">
   <title>NULL</title>

   <para>
    O valor especial &null; representa
    que a variável não tem valor. &null; é o único valor possível do tipo
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      O tipo NULL foi incluído no PHP 4
     </simpara>
    </note>
    <para>
     A variável é considerada &null; se
     <itemizedlist>
      <listitem>
       <para>
        ela foi assimilada com a constante &null;.
       </para>
      </listitem>
      <listitem>
       <para>
        ela ainda não recebeu nenhum valor ainda.
       </para>
      </listitem>
      <listitem>
       <para>
        ela foi apagada com <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   <sect2 id="language.types.null.syntax">
    <title>Sintaxe</title>
    <para>
     Há apenas um único valor do tipo &null;, e é
     a palavra (insensitiva ao caso)
     &null;.
     <informalexample>
      <programlisting role="php">
$var = NULL;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Veja também <function>is_null</function> e <function>unset</function>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Manipulação de tipos</title>

   <simpara>
    O PHP não requer (ou suporta) a definição de tipo explicita na
    declaração de variáveis: o tipo de uma variável é determinado pelo
    contexto em que a variável é utilizada. Isto significa que, se você
    assimila um valor string para a variável <parameter>var</parameter>,
    <parameter>var</parameter> se torna uma string. Se você então assimila um
    valor inteiro para <parameter>var</parameter>, ela se torna
    um inteiro.
   </simpara>
   <para>
    Um exemplo da conversão automática do PHP é o operador de
    adição '+'. Se qualquer um dos operadores for float, então todos
    os operadores são avaliados como floats, e o resultado será um
    float. De outra forma, se os operadores forem interpretados como inteiros
    então o resultado será um inteiro. Note que isso NÃO
    muda os tipos dos operadores: apenas muda em como
    esses operadores são avaliados.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo é string (ASCII 48)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)
-->
$foo += 2;   // $foo é agora um inteiro (2)
$foo = $foo + 1.3;  // $foo é agora um float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo é inteiro (15)
$foo = 5 + "10 Small Pigs";     // $foo é inteiro (15)
<!--

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Se os últimos dois exemplos lhe parecerem estranhos, veja <link
    linkend="language.types.string.conversion">Conversão de
    strings</link>.
   </simpara>
   <simpara>
    Se você deseja forçar uma variável para ser avaliada como um certo tipo,
    veja a seção <link linkend="language.types.typecasting">Moldando o
    tipo (casting)</link>. Se você deseja mudar o tipo de uma variável, veja
    <function>settype</function>.
   </simpara>
   <para>
    Se quiser testar qualquer um dos exemplo desta seção, você pode
    usar a função <function>var_dump</function>.
   </para>
   <note>
    <para>
     O comportamento de uma conversão automática para array é atualmente
     indefinida.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a é uma string
$a[0] = "f";  // E com relação aos índices da string? O que acontece?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Desde que o PHP suporta indexação de strings através de offsets utilizando a
     mesma sintaxe da indexação de arrays, o exemplo acima nos deixa um
     problema: $a se tornou um array sendo o primeiro elemento
     "f", ou será que "f" se tornou o primeiro caracter da string $a ?
    </para>
    <para>
     Por essa razão, como no PHP 3.0.12 e PHP 4.0b3-RC4, o resultado
     dessa conversão automática é considerada como indefinida. Correções,
     entretanto, estão sendo discutidas.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Moldando Tipos - Type Casting</title>

    <para>
     A moldagem de tipos no PHP funciona como no C: o nome de um
     tipo desejado é escrito entre parênteses antes da variável em
     que se deseja a moldagem.
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo é um inteiro
$bar = (float) $foo;   // $bar é um número de ponto flutuante
      </programlisting>
     </informalexample>
    </para>
    <para>
     As moldagens permitidas são:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - molde para inteiro</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - molde para booleano</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - molde para número de ponto flutuante</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - molde para string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - molde para array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - molde para objeto</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <note>
     <simpara>
      Em vez de moldar uma variável para string, você também pode circundar
      a variável entre aspas.
      <!-- TODO: example -->
     </simpara>
    </note>

    <para>
     Note que tabulações e espaços são permitidos dentro dos parênteses, então
     o seguinte são funcionalmente equivalentes:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Pode não ser tão óbvio o que exatamente ocorre quando se molda
     entre certos tipos. Para mais informações, veja essas seções:

     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Convertendo para
        booleano</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Convertendo para
        inteiro</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.float.casting">Converting to
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to
        resource</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>

    </para>
    <para>
     <!-- TODO: move to 'converting to string' -->
     Quando moldando ou forçando a conversão de um array para string,
     o resultado será a palavra <literal>Array</literal>. Quando moldando
     ou forçando o tipo de um objeto para string, o resultado será a
     palavra <literal>Object</literal>.

     <!-- not with my PHP, not even a notice... maybe in PHP3?
     Does someone know?

     In both cases a warning will
     be issued. -->
    </para>
    <para>
     Quando moldando de uma variável escalar ou string para um array, a
     variável se torna o primeiro elemento do array:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // outputs 'ciao'
      </programlisting>
     </informalexample>
    </para>
    <para>
     Quando moldando de uma variável escalar ou string para um objeto, a
     variável se torna um atributo do objeto: o nome do atributo se
     chamará 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // imprime 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
