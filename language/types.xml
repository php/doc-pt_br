<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.127 Maintainer: ae Status: ready -->
 <chapter id="language.types">
  <title>Tipos</title>

  <sect1 id="language.types.intro">
  <title>Introdução</title>

  <simpara>
   O PHP suporta os oitos tipos primitivos.
  </simpara>

  <para>
   São quatros tipos básicos:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>boolean</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>integer</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>float</type> (número de ponto flutuante, ou também '<type>double</type>')
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>

   </itemizedlist>

   Dois tipos compostos:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>array</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>object</type>
     </simpara>
    </listitem>

   </itemizedlist>

   E finalmente dois tipos especiais:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>resource</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>

   Este manual também introduz alguns
   <link linkend="language.pseudo-types">pseudo-tipos</link>
   por razões de legibilidade:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.mixed">mixed</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.number">number</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.mixed">callback</link>
     </simpara>
    </listitem>

   </itemizedlist>
   Você também pode encontrar algumas referências ao tipo "double". Considere o tipo
   double como sendo o float, e os dois nomes existem por razões
   históricas.
  </para>

  <simpara>
   O tipo da variável geralmente não é configurado pelo programador: isto
   é decidido em tempo de execução pelo PHP, dependendo do contexto no qual a
   variável é usada.
  </simpara>
  <note>
   <simpara>
    Se você quiser checar o tipo e valor de uma certa <link
     linkend="language.expressions">expressão</link>, utilize
    <function>var_dump</function>.
   </simpara>
   <para>
    Se você simplesmente quiser uma representação legível de seu tipo para
    debugagem, use <function>gettype</function>. Para verificar por certos tipos,
    <emphasis>não use</emphasis> <function>gettype</function>, mas sim as funções
    <literal>is_<replaceable>type</replaceable></literal>. Vejamos alguns
    exemplos:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // um booleano
$str  = "foo";  // uma string
$int  = 12;     // um inteiro

echo gettype($bool); // imprime "boolean"
echo gettype($str);  // imprime "string"

// Se é um inteiro, incrementa em quatro
if (is_int($int)) {
    $int += 4;
}

// Se $bool é string, imprime
// (e não faz nada se não for)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   Se você quiser forçar a conversão de uma variável para um certo tipo,
   você pode <link
   linkend="language.types.typecasting">moldar</link> (casting) a variável ou
   usar a função <function>settype</function> nela.
  </simpara>
  <simpara>
   Note que uma variável pode ser avaliada com valores diferentes em certas
   situações, dependendo de qual tipo ela é no momento. Para mais informações,
   veja a seção <link
   linkend="language.types.type-juggling">Manipulação de tipos</link>. Também possa
   ser interressante se interar da
   <link linkend="types.comparisons">tabela de conversão de tipos</link>,
   e seus exemplo de vários comparações relacionadas.
  </simpara>
 </sect1>

   <sect1 id="language.types.boolean">
    <title>Booleanos</title>

    <simpara>
     Este é o tipo mais fácil. Um <type>booleano</type> expressa um
     valor de verdade. Ele pode ser &true; ou &false;.
    </simpara>

    <note>
     <simpara>
      O tipo booleano foi introduzido no PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Sintaxe</title>
     <para>
      Para especificar um literal booleano, use as palavras chave &true;
      ou &false;. Ambas são insensitivas ao caso.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo = True; // assimila o valor TRUE para $foo
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Usualmente você pode
      utilizar algum tipo de <link linkend="language.operators">operador</link>
      que retorne um valor <type>booleano</type>, e passá-lo para
      uma <link linkend="control-structures">estrutura de
      controle</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// == é um operador que testa
// igualdade e retorna um booleano
if ($action == "mostrar_versao") {
    echo "A versão é 1.23";
}

// isto não é necessário ...
if ($exibir_separadores == TRUE) {
    echo "<hr>\n";
}

// ... porque você pode simplesmente escrever isso:
if ($exibir_separadores) {
    echo "<hr>\n";
}
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Convertendo para booleano</title>
      <simpara>
       Para converter explicitamente um valor para <type>booleano</type>, utilize-se dos
       modificadores <literal>(bool)</literal> ou <literal>(boolean)</literal>.
       Entretanto, na maioria dos casos, você não precisa utilizar o modificador, desde que qualquer valor
       será convertido automaticamente se um operador, função ou
       estrutura de controle requerer um argumento <type>booleano</type>.
      </simpara>
      <simpara>
       Veja também <link linkend="language.types.type-juggling">Manipulação de tipos</link>.
      </simpara>

      <para>
       Quando convertendo para <type>booleano</type>, os seguintes valores
       são considerados &false;:

       <itemizedlist>
        <listitem>
         <simpara>o próprio <link linkend="language.types.boolean">booleano</link>
          &false;</simpara>
        </listitem>
        <listitem>
         <simpara>o <link linkend="language.types.integer">inteiro</link
         > 0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>o <link linkend="language.types.float">ponto flutuante</link>
         0.0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>uma <link linkend="language.types.string"
           >string</link> vazia e a <link linkend="language.types.string"
           >string</link>
           "0"</simpara>
        </listitem>
        <listitem>
         <simpara>um <link linkend="language.types.array">array</link>
         sem elementos</simpara>
        </listitem>
        <listitem>
         <simpara>um <link linkend="language.types.object">objeto</link>
         sem elementos membros</simpara>
        </listitem>
        <listitem>
         <simpara>o tipo especial <link linkend="language.types.null"
           >NULL</link> (incluindo variáveis não definidas)
         </simpara>
        </listitem>
       </itemizedlist>

       Qualquer outro valor é considerado &true; (incluindo qualquer
       <link linkend="language.types.resource">recurso</link>).
       <warning>
        <simpara>
         <literal>-1</literal> é considerado
         &true;, como qualquer valor não zero (negativos
         ou positivos)!
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </informalexample>
      </para>
     </sect2>
   </sect1>

   <sect1 id="language.types.integer">
    <title>Inteiros</title>

    <simpara>
     Um <type>inteiro</type> é um número do conjunto
     Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>

    <para>
     Veja também:
     <link linkend="ref.gmp">Inteiros de tamanho arbitrário / GMP</link>, 
     <link linkend="language.types.float">Números de ponto flutuante</link> e 
     <link linkend="ref.bc">Precisão arbitrária / BCMath</link>.
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Sintaxe</title>
     <simpara>
      Inteiros podem ser especificados em notação decimal (base 10), hexadecimal (base 16)
      ou octal (base 8), opcionalmente precedido de sinal (- ou +).
     </simpara>
     <para>
      Para usar a notação octal, você precisa preceder o número com um
      <literal>0</literal> (zero). Para utilizar a notação hexadecimal, preceda
      número com <literal>0x</literal>.
      <example>
       <title>Literais inteiras</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = 1234; # número decimal
$a = -123; # um número negativo
$a = 0123; # número octal (equivalente a 83 em decimal)
$a = 0x1A; # número hexadecimal (equivalente a 26 em decimal)
?>
]]>
       </programlisting>
      </example>
      Formalmente, as possíveis representação de inteiros são:
      <informalexample>
       <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
       </programlisting>
      </informalexample>
      O tamanho de um inteiro é dependente de plataforma, sendo
      um numero aproximado a 2 bilhões o valor mais comum
      (número de 32 bits com sinal). O PHP não suporta inteiros
      sem sinal.
     </para>
    </sect2>

    <sect2 id="language.types.integer.overflow">
     <title>Overflow de inteiros</title>
     <para>
      Se você especifica um número além dos limites do tipo <type>inteiro</type>,
      ele será interpretado como um <type>ponto flutuante</type>. Assim, se
      você realizar uma operação que resulte em um número além dos limites do
      tipo <type>inteiro</type>, um <type>ponto flutuante</type> será retornado
      também.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$ numero_grande =  2147483647;
var_dump($numero_grande);
// saida: int(2147483647)

$numero_grande =  2147483648;
var_dump($numero_grande);
// saida: float(2147483648)

// isto também é permitido para especificação de números hexadecimais:
var_dump( 0x80000000 );
// saida: float(2147483648)

$milhao = 1000000;
$numero_grande =  50000 * $milhao;
var_dump($numero_grande);
// saida: float(50000000000)
?>
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        Infelizmente, há um bug no PHP que faz que ele
        nem sempre trabalhe corretamente quando há números negativos
        envolvidos. Por exemplo, quando você faz <literal>-50000 *
        $milhao</literal>, o resultado será
        <literal>-429496728</literal>. Entretanto, quando ambos os operadores são
        positivos, isso não ocorre.
       </simpara>
       <simpara>
        Isto foi resolvido no PHP 4.1.0.
       </simpara>
      </warning>
     </para>
     <para>
      Não há operador de divisão inteira no PHP.
      <literal>1/2</literal> retorna o <type>ponto flutuante</type>
      <literal>0.5</literal>. Você pode moldar (cast) o valor para
      inteiro para sempre truncar o número, ou você pode
      usar a função <function>round</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>


    <sect2 id="language.types.integer.casting">
     <title>Convertendo para inteiro</title>
      <simpara>
       Para converter explicitamente um valor para <type>inteiro</type>, utilize-se
       dos modificadores <literal>(int)</literal> ou <literal>(integer)</literal>.
       Entretanto, na maioria dos casos, você não precisa utilizar o modificador, desde que qualquer
       valor será automaticamente convertido se um operador, função ou
       estrutura de controle requerer um argumento <type>inteiro</type>.
       Você também pode converter o valor de um inteiro com a função
       <function>intval</function>.
      </simpara>
      <simpara>
       Veja também <link linkend="language.types.type-juggling">Manipulação de tipos</link>.
      </simpara>

      <sect3 id="language.types.integer.casting.from-boolean">
       <title>de <link linkend="language.types.boolean"
           >booleanos</link></title>
       <simpara>
        &false; será retornado como
        <literal>0</literal> (zero), e &true;
        como <literal>1</literal> (um).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>De <link linkend="language.types.float">números de ponto flutuante</link></title>
       <simpara>
        Quando convertendo de números de ponto flutuante para inteiros, o número será
        <emphasis>truncado</emphasis>.
       </simpara>

       <para>
        Se o número convertido estiver além dos limites de um inteiro
        (usualmente <literal>+/- 2.15e+9 = 2^31</literal>),
        o resultado é indefinido, mesmo porque o ponto flutuante
        não tem a mesma precisão para fornecer um resultado inteiro exato.
        Não se preocupe, pois nenhum aviso será emitido neste
        caso!
       </para>

       <warning><para>
        Nunca modifique uma fração desconhecida para <type>inteiro</type>, porque isto pode
        fornecer resultados inesperados as vezes.
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // imprime 7!
?>
]]>
         </programlisting>
        </informalexample>

        Para maiores informações, veja o <link
        linkend="warn.float-precision">alerta
        sobre a precisão de número flutuante.</link>.
       </para></warning>
      </sect3>

      <sect3 id="language.types.integer.casting.from-string">
       <title>De strings</title>
       <simpara>
        Veja <link linkend="language.types.string.conversion">Conversão
        de strings para números</link>
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-other">
       <title>De outros tipos</title>
       <para>
        <caution>
         <simpara>
          O comportamento da conversão de um inteiro é indefinido de outros
          tipos. Atualmente, o comportamento é o mesmo como se primeiro o
          valor fosse <link linkend="language.types.boolean.casting"
          >convertido para booleano</link>. Entretanto,
          <emphasis>não confie</emphasis> neste comportamento, pois ele pode
          mudar sem aviso.
         </simpara>
        </caution>
       </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Números de ponto flutuante</title>
   <para>
    Números de ponto flutuante (AKA "floats", "doubles" ou "números reais") podem ser
    especificados utilizando qualquer uma das sintaxes seguintes:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    Formalmente:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    O tamanho de um número de ponto flutuante é dependente de plataforma,
    sendo o máximo de ~1.8e308 com uma precisão de 14
    decimais digitais um valor comum (número de 64 bits no formato IEEE).
   </para>

   <warning id="warn.float-precision">
    <title>Precisão de números de ponto flutuante</title>
    <para>
     É sabido que frações simples como
     <literal>0.1</literal> ou <literal>0.7</literal> não podem ser
     convertidos em sua representação binária interna sem uma
     pequena perda de precisão. Isto pode causar erros confusos: por
     exemplo, <literal>floor((0.1+0.7)*10)</literal> irá retornar
     <literal>7</literal> em vez do esperado
     <literal>8</literal>, como resultado da representação interna
     realmente ser algo como <literal>7.9999999999...</literal>.
    </para>
    <para>
     Isto está relacionado ao fato de que é impossível expressar,
     exatamente, algumas frações em notação decimal com um número finito
     de dígitos. Por exemplo, <literal>1/3</literal> na forma decimal
     se torna <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Então, nunca confie em resultados com números de ponto flutuante até a última casa e
     nunca compare números de ponto flutuante em igualdades. Se você realmente
     precisar de alta precisão, você pode utilizar as <link
     linkend="ref.bc">funções matemáticas de precisão arbitrária</link>
     ou as funções relacionadas ao <link linkend="ref.gmp">gmp</link>.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>Convertendo para float</title>

    <para>
     Para informações em como e quando strings são convertidas para floats,
     veja a seção entitulada <link linkend="language.types.string.conversion">Conversão de
     Strings para números</link>. Para valores de outros tipos, a conversão
     é a mesma se o valor puder ser convertido para inteiro
     e então para float. Veja a seção <link linkend="language.types.integer.casting">Convertendo
     para inteiro</link> para mais informações.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>Strings</title>
   <para>
    Uma <type>string</type> é uma série de caracteres. No PHP,
    um caracter é o mesmo que um byte, ou seja, há exatamente
    256 caracteres diferentes possíveis. Isto implica que o PHP
    não tem suporte nativo ao Unicode. Veja <function>utf8_encode</function>
    e <function>utf8_decode</function> para suporte ao Unicode.
   </para>
   <note>
    <simpara>
     Não há nenhum problema nas strings se tornarem muito grandes.
     Não há nenhum limite para o tamanho de
     strings imposta pelo PHP, então não há razão
     para se preocupar com strings longas.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Sintaxe</title>
    <para>
     Uma string literal pode ser especificada de três formas
     diferentes.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">apóstrofo</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">aspas</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">sintaxe heredoc</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Apóstrofos</title>
     <para>
      A maneira mais simples para especificar uma string é
      delimitá-la entre apóstrofos (o caracter <literal>'</literal>).
     </para>
     <para>
      Para especificar um apóstrofo.
      você precisará "escapá-la" com uma contra barra
      (<literal>\</literal>), como em muitas outras linguagens.
      Se uma contra barra precisa ocorrer antes de um apóstrofo ou no
      final da string, você precisa duplicá-la.
      Note que se você tentar escapar qualquer
      outro caracter, a contra barra também será impressa! Então
      geralmente não é necessário escapar a própria contra barra.
      <note>
       <simpara>
        No PHP 3, um aviso
        com nível <literal>E_NOTICE</literal> será emitido quando
        isto acontecer.
       </simpara>
      </note>
      <note>
       <simpara>
        Diferentemente das duas outras sintaxes, <link
        linkend="language.variables">variables</link> e seqüências de escape
        para caracteres especiais <emphasis>não</emphasis> serão substituídas 
        quando elas ocorrerem dentro de strings delimitadas por apóstrofes.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'isto é uma string comum';

echo 'Você pode incluir novas linhas em strings,
dessa maneira que estará
tudo bem';

// Imprime: Arnold disse uma vez: "I\'ll be back"
echo 'Arnold once said: "I\'ll be back"';

// Imprime: Você tem certeza em apagar C:\*.*?
echo 'Você tem certeza em apagar C:\\*.*?';

// Imprime: Você tem certeza em apagar C:\*.*?
echo 'Você tem certeza em apagar C:\*.*?';

// Imprime: Isto não será substituido: \n uma nova linha
echo 'Isto não será substituido: \n uma nova linha';

// Imprime: Variaveis $também não $expandem
echo 'Variaveis $também não $expandem';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Aspas</title>
     <para>
      Se a string é delimitada entre aspas ("),
      o PHP entende mais seqüências de escape para caracteres
      especiais:
     </para>
     <table>
      <title>Seqüências de escape</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Seqüência</entry>
         <entry>Significado</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>fim de linha (linefeed ou LF ou 0x0A (10) em ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>retorno de carro (carriage return ou CR ou  0x0D (13) em ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>TAB horizontal (HT ou 0x09 (9) em ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>contra barra ou barra invertida</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>sinal de cifrão</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>aspas</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          a seqüência de caracteres batendo a expressão
          regular dos caracteres em notação octal
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          a seqüência de caracteres batendo a expressão
          regular de um caracter em notação hexadecimal
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Novamente se você tentar escapar qualquer outro caracter, a
      contra barra será impressa também!
     </para>
     <para>
      Mas o mais importante recurso de strings delimitadas por aspas
      está no fato de que nome de variáveis serão substituídos.
      Veja <link linkend="language.types.string.parsing">interpretação de
      strings</link> para detalhes.
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Outra maneira para delimitar strings é utilizando a sintaxe heredoc
      ("&lt;&lt;&lt;"). É informado um identificador depois de
      <literal>&lt;&lt;&lt;</literal>, então a string, e então o
      mesmo identificador para fechar a delimitação.
     </simpara>
     <simpara>
      O identificador de fechamento <emphasis>precisa</emphasis> começar na
      primeira coluna da linha. Além, o identificador utilizado precisa seguir
      as mesmas regras de nomeação que qualquer outro rótulo no PHP: só pode conter
      caracteres alfanuméricos e sublinhados, e precisa começar com
      um caracter não numérico ou sublinhado.
     </simpara>

     <warning>
      <simpara>
       É muito importante verificar que a linha do identificador
       de fechamento não contenha nenhum outro caracter, exceto,
       <emphasis>possivelmente</emphasis> um ponto e vírgula (<literal>;</literal>).
       O que significa que o identificador
       <emphasis>não pode ser indentado</emphasis>, e que
       não pode haver nenhum espaço ou tabulações antes ou depois do ponto e vírgula.
       É também importante perceber que o primeiro caracter antes
       do identificador de fechamento precisa ser um caracter de nova linha como esperada por
       seu sistema operacional. Por exemplo, <literal>\r</literal> em sistemas
       Macintosh.
      </simpara>
      <simpara>
       Se essa regra for quebrada e o identificador de fechamento não estiver perfeito,
       então ele não será considerado como identificador de fechamento e o PHP
       irá continuar procurando por um. Se, neste caso, um identificador de fechamento
       apropriado não for encontrado, então um erro de interpretação (parse) será lançado
       na linha final do script.
      </simpara>
     </warning>

     <para>
      Textos heredoc se comportam como strings delimitadas por aspas, com
      apenas uma diferença. Você não precisa escapar apóstrofos e aspas
      em seus heredocs, mas você ainda pode continuar utilizando os códigos de escape listados
      acima. Variáveis são substituídas, mas o mesmo cuidado precisa ser tomado
      quando expressando variáveis complexas dentro de heredocs assim como
      nas strings.
      <example>
       <title>Exemplo de delimitação de strings heredoc</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Exemplo de uma string
distribuída em várias linhas
utilizando a sintaxe heredoc.
EOD;

/* Exemplo mais complexo, com variáveis */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Meu nome';

echo <<<EOT
Meu nome é "$name". Eu estou imprimindo $foo->foo.
Agora, eu estou imprimindo {$foo->bar[1]}.
Isto deve imprimir um 'A' maiúsculo: \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>

     <note>
      <para>
       O suporte a heredoc foi acrescentado no PHP 4.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Interpretação de variáveis</title>
     <simpara>
      Quando uma string é especificada dentro de aspas ou
      heredoc, <link linkend="language.variables">variáveis</link> são
      interpretadas dentro delas.
     </simpara>
     <simpara>
      Há dois tipos de sintaxe: um
      <link linkend="language.types.string.parsing.simple">simples</link>
      e um
      <link linkend="language.types.string.parsing.complex">complexo</link>
      .
      A sintaxe simples é a mais comum e conveniente, provendo uma maneira de
      interpretar uma variável, um valor de <type>array</type> ou uma propriedade de <type>
      object</type>.      
     </simpara>
     <simpara>
      A sintaxe completa foi introduzida no PHP 4, e pode ser reconhecida
      por chaves ({}) envolvendo a expressão.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Sintaxe simples</title>
      <simpara>
       Se um sinal de cifrão (<literal>$</literal>) é encontrado, o
       interpretador tentará obter tantos identificadores quanto possíveis para formar um
       nome de variável válido. Envolva o nome da variável com chaves
       se você deseja explicitamente especificar o fim do nome.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$cerveja = 'Heineken';
echo "O sabor das '$cerveja's é otimo"; // funciona, "'" é um caracter inválido para nome de variáveis
echo "Ele bebeu algumas $cervejas";     // não funciona, 's' é um caracter válido para nome de variáveis
echo "Ele bebeu algumas ${cerveja}s";   // funciona
echo "Ele bebeu algumas {$cerveja}s";   // funciona
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Similarmente, você também pode interpretar um índice de <type>array</type> ou
       uma propriedade de <type>objeto</type>. Com índices de arrays, o colchete de fechamento
       (<literal>]</literal>) marca o final do índice. Para
       propriedades de objetos se aplicam as mesmas regras das variáveis comuns,
       embora não exista um truque para as propriedades de objetos como
       para as variáveis.

       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->

      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Esses exemplos são específicos para utilização de arrays dentro de strings
// Quando fora de strings, sempre delimite suas chaves de array strings
// e nao use {colchetes} fora das strings tambem.

// Vamos ver todos os erros
error_reporting(E_ALL);

$fruits = array('morango' => 'vermelho', 'banana' => 'amarelo');

// Funciona, mas note que funciona de maneira diferente fora dos delimitadores de strings
echo "A banana é $fruits[banana].";

// Funciona
echo "A banana é {$fruits['banana']}.";

// Funciona, mas o PHP procura por uma constante chamada 'banana' antes,
// como descrito a seguir
echo "A banana é {$fruits[banana]}.";

// Nao funciona, use colchetes. Isto lanca um parse error.
echo "A banana é $fruits['banana'].";

// Funciona
echo "A banana é " . $fruits['banana'] . ".";

// Funciona
echo "Este quadrado tem $square->width metros de lado.";

// Nao funciona. Para uma solução, veja a sintaxe complexa.
echo "Este quadrado tem $square->width00 centímetros de lado.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad.";
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works,
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Para qualquer coisa mais complexa, você precisa utilizar a sintaxe complexa.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Sintaxe complexa (chaves)</title>
      <simpara>
       Isto não é chamado sintaxe complexa porque a sintaxe em si é complexa,
       mas porque você pode incluir expressões complexas desta maneira.
     </simpara>
     <simpara>
      De fato, você pode incluir qualquer valor no que esteja no espaço de nomes
      dentro de strings com esta sintaxe. Você simplesmente escreve a expressão
      da mesma maneira que faria fora da string, e então incluí-la
      entre chaves. Desde que você não pode escapar '{', esta sintaxe
      somente será reconhecida quando o $ é imediatamente seguido de um {.
      (Utilize "{\$" ou "\{$" para obter um literal "{$").
      Alguns exemplos para tornar isso mais claro:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Vamos ver todos os erros
error_reporting(E_ALL);

$bom = 'fantastico';

// Não funciona, imprimindo: Isto é { fantastico}
echo "Isto é { $bom}";

// Funciona, imprimindo: Isto é fantástico
echo "Isto é {$bom}";
echo "Isto é ${bom}";

// Funciona
echo "Este quadrado tem {$square->width}00 centímetros de lado.";

// Funciona
echo "Isto funciona: {$arr[4][3]}";

// Isto está errado pela mesma razao que $foo[bar] eh errado
// fora de uma string. Em outras palavras, isto ainda funciona MAS
// porque o PHP primeiro procura pro uma constante nomeada foo, e ele
// lancara um erro do tipo E_NOTICE (undefined constant).
echo "Isto é errado: {$arr[foo][3]}";

// Funciona. Quanto mexendo com arrays multi dimensionais, sempre use
// colchetes em volta dos arrays quando detro de strings
echo "Isto funciona: {$arr['foo'][3]}";

// Funciona
echo "Isto funciona: " . $arr['foo'][3];

echo "Você pode escrever também {$obj->values[3]->name}";

echo "Este é o valor da variável chamada $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out??
// this works, but i disencourage its use, since this is NOT
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>

    <sect3 id="language.types.string.substr">
     <title>Acesso a caracteres da string</title>
     <para>
      Caracteres nas strings podem ser acessados apenas especificando o
      deslocamento baseado em zero do caracter desejado depois da string
      dentro de chaves.
     </para>
     <note>
      <simpara>
       Para manter a compatibilidade, você ainda pode usar colchetes de array
       para o mesmo propósito. Entretanto, esse sintaxe é obsoleta desde
       o PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Alguns exemplos com strings</title>
       <programlisting role="php">
<![CDATA[
<?php
// Pega o primeiro caracter da string
$str = 'Isto é um teste.';
$first = $str{0};

// Pega o terceiro caracter da string
$third = $str{2};

// Pega o último caracter da string
$str = 'Isto ainda é um teste.';
$last = $str{strlen($str)-1};
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Funções e operadores úteis</title>
    <para>
     Strings podem ser concatenados utilizando o operador '.' (ponto). Note
     que o operador '+' (adição) não funciona para isso.
     Veja <link linkend="language.operators.string">operadores de
     string</link> para mais informações.
    </para>
    <para>
     Há uma grande quantidade de funções úteis para modificação de strings.
    </para>
    <simpara>
     Veja a seção de <link linkend="ref.strings">funções de string</link>
     para funções gerais e funções de expressões regulares para
     busca e substituição avançada.(em dois sabores:
     <link linkend="ref.pcre">Perl</link> e
     <link linkend="ref.regex">POSIX estendido</link>).
    </simpara>
    <simpara>
     Há também <link linkend="ref.url">funções para strings URL</link> e
     funções para criptografia e descriptografia de strings
     (<link linkend="ref.mcrypt">mcrypt</link> e
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalmente, se você ainda não encontrar o que está procurando,
     veja também as <link linkend="ref.ctype">funções de tipos de caracteres</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Convertendo para strings</title>

    <para>
     Você pode converter um valor para string utilizando o molde <literal>(string)</literal>,
     ou a função <function>strval</function>. Conversão para string
     é automaticamente realizada no escopo de uma expressão para você onde uma
     string é necessária. Isto acontece quando você usa as funções <function>echo</function>
     ou <function>print</function>, ou quando você compara o valor de uma
     variável com uma string. Lendo as seções do manual sobre <link
     linkend="language.types">Tipos</link> e <link
     linkend="language.types.type-juggling">Conversão de Tipos</link> tornará o
     que se segue um pouco mais claro. Veja também <function>settype</function>.
    </para>

    <para>
     O valor <type>boolean</type> &true; é convertido para a string <literal>"1"</literal>,
     o valor &false; é representado como <literal>""</literal> (string vazia).
     Desta forma, você pode converter livremente entre os tipos booleano e string.
    </para>
    <para>
     Um <type>integer</type> ou número de ponto flutuante (<type>float</type>)
     é convertido para a representação string do número em dígitos arábicos
     (incluindo a parte expoente para números de ponto flutuante).
    </para>
    <para>
     Arrays são sempre convertidos para a string <literal>"Array"</literal>,
     então você não pode exportar o conteúdo de um <type>array</type> com
     <function>echo</function> ou <function>print</function> para ver o que há dentro
     dela. Para ver um elemento, você precisa fazer algo como <literal>
     echo $arr['foo']</literal>. Veja abaixo dicas de como exportar/ver todo
     seu conteúdo.
    </para>
    <para>
     Objetos são sempre convertidos para a string <literal>"Object"</literal>.
     Se você quiser imprimir os valores das variáveis membro de um
     <type>object</type> por razão de debug, leia os parágrafos
     abaixo. Se você quiser encontrar o nome da classe do qual o objeto
     é uma instância, use <function>get_class</function>.
    </para>
    <para>
     Recursos são sempre convertidos para strings na estrutura
     <literal>"Resource id #1"</literal> onde <literal>1</literal> é
     o número único do <type>resource</type> assimilado pelo PHP na execução.
     Se você quiser obter o tipo do recurso, utilize
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; é sempre convertido para uma string vazia.
    </para>

    <para>
     Como você viu acima, imprimir arrays, objetos ou recursos não
     fornece qualquer informação útil sobre os seus próprios valores. Veja as
     funções <function>print_r</function> e <function>var_dump</function>
     para melhores maneiras de imprimir valores para debug.
    </para>

    <para>
     Você também pode converter valores PHP para strings para armazená-los permanentemente. Este
     método é chamado serialização, e pode ser feito com a função
     <function>serialize</function>. Você também pode serializar valores PHP para
     estruturas XML , se você ativou o suporte a <link linkend="ref.wddx">WDDX</link>
     na configuração do seu PHP.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Conversão de strings para números</title>

    <simpara>
     Quando uma string é avaliada como um valor numérico, o valor
     resultante e o tipo é determinado como segue.
    </simpara>
    <simpara>
     A string será avaliada como um <type>ponto flutuante</type> se conter qualquer um dos
     caracteres '.', 'e', ou 'E'. Em outros casos, ela será avaliada como
     um inteiro.
    </simpara>
    <para>
     O valor é obtido da porção inicial da string. Se a
     string começa com dados numéricos válidos, esse será o valor
     utilizado. Em outro caso, o valor será 0 (zero). Dados numéricos válidos
     são: um sinal opcional, seguido por um ou mais dígitos (opcionalmente
     contendo um ponto decimal), seguido de um expoente, também
     opcional. O expoente é um 'e' ou 'E' seguido de um ou mais
     dígitos.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo é float (11.5)
$foo = 1 + "-1.3e3";              // $foo é float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo é integer (1)
$foo = 1 + "bob3";                // $foo é integer (1)
$foo = 1 + "10 Small Pigs";       // $foo é integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo é float (14.2)
$foo = "10.0 pigs " + 1;          // $foo é float (11)
$foo = "10.0 pigs " + 1.0;        // $foo é float (11)
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Para mais informações sobre esta conversão, veja página do manual UNIX
     de strtod(3).
    </simpara>
    <para>
     Se você deseja testar qualquer um dos exemplo dessa seção,
     você pode copiar e colar os exemplos e inserir as linhas seguintes
     para ver por si mesmo como isso funciona.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; tipo " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Não espere obter o código de um caracter por convertê-lo
     para inteiro (como você teria em C, por exemplo). Use as funções
     <function>ord</function> e <function>chr</function> para converter
     entre código de caracteres e os próprios caracteres.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Um array no PHP é atualmente um mapa ordenado. Um mapa é um tipo que
    relaciona <emphasis>valores</emphasis> para <emphasis>chaves</emphasis>.
    Este tipo é otimizado de várias maneiras,
    então você pode usá-lo como um array real, ou uma lista (vetor),
    hashtable (que é uma implementação de mapa),
    dicionário, coleção,
    pilha, fila e provavelmente mais. Como você pode ter outro
    array PHP como um valor, você pode facilmente simular
    árvores.
   </para>
   <para>
    A explicação dessas estruturas estão além do escopo desse
    manual, mas você pode encontrar exemplos para cada uma dessas estruturas a seguir.
    Para mais informações sobre estruturas, refira-se a literatura externa sobre 
    esses tópicos.
   </para>

   <sect2 id="language.types.array.syntax">
    <title>Sintaxe</title>

    <sect3 id="language.types.array.syntax.array-func">
     <title>Especificando com <function>array</function></title>
     <para>
      Um <type>array</type> pode ser criado com o construtor de linguagem
      <function>array</function>. Ele pega um certo número de pares separados por vírgula
      <literal><replaceable>chave</replaceable> =&gt; <replaceable
      >valor</replaceable></literal>
      .
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>chave</replaceable> =&gt; </optional> <replaceable>valor</replaceable>
     , ...
     )
// <replaceable>chave</replaceable> pode ser tanto <type>string</type> ou um <type>integer</type>
// <replaceable>valor</replaceable> pode ser qualquer coisa
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      A <varname>chave</varname> pode ser tanto um
      <type>integer</type> ou uma <type>string</type>. Se a chave
      é uma representação padrão de um <type>integer</type>, ele será 
      interpretado assim (por exemplo, <literal>"8"</literal> será 
      interpretado como <literal>8</literal>, enquanto 
      <literal>"08"</literal> será interpretado como
      <literal>"08"</literal>). Não há diferença entre arrais indexados e
      associativos em PHP, apenas um tipo de array,
      que pode ter índices inteiros ou string.
     </para>
     <para>
      O valor pode ser qualquer tipo PHP:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Se omitir a chave quando fornece um novo item, o maior
      índice inteiro é obtido, e a nova chave será esse
      máximo + 1. Se você especificar uma chave que já possui um valor 
      assimilada a ela, então o valor é sobrescrito.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Esse array eh como ...
array(5 => 43, 32, 56, "b" => 12);

// ... este array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
       A partir do PHP 4.3.0, o comportamento da geração de índice descrito
       acima foi modificado. Agora, se você aumentar um array em que
       o maior índice atual for negativo, então a próxima chave
       criada será zero (<literal>0</literal>). Antes, o novo
       índice seria o maior índice existente mais 1,
       do mesmo jeito que os índices positivos.
      </simpara>
     </warning>
     <para>
      Utilizar &true; como chave será interpretado como o <type>integer</type>
      <literal>1</literal> na chave. Utilizando &false; como chave será 
      avaliado como o <type>integer</type> <literal>0</literal>. 
      Usar <literal>NULL</literal> como chave é interpretado como uma string 
      vazia. Usar uma string vazia como chave irá criar (ou sobrescerver) 
      uma chave com uma string vazia e seu valor, e isto não é o mesmo que 
      usar colchetes vazios.
     </para>
     <para>
      Você não pode usar arrays ou objetos como chaves. Fazendo isso resultará em um
      alerta: <literal>Illegal offset type</literal>.
     </para>
    </sect3>

    <sect3 id="language.types.array.syntax.modifying">
     <title>Criando/modificando com a sintaxe de colchetes</title>
     <para>
      Você pode também modificar um array existente explicitamente assimilando
      valores nele.
     </para>
     <para>
      Isto é feito apenas assimilando valores para o array enquanto especificando a
      chave em colchetes. Você pode omitir a chave, colocando um par vazio
      de colchetes ("<literal>[]</literal>").
      <synopsis>
$arr[<replaceable>chave</replaceable>] = <replaceable>valor</replaceable>;
$arr[] = <replaceable>valor</replaceable>;
// <replaceable>chave</replaceable> tanto um <type>integer</type> ou <type>string</type>
// <replaceable>valor</replaceable> pode ser qualquer coisa
      </synopsis>
      Se <varname>$arr</varname> não existir ainda, ele será criado.
      Então isto é um meio alternativo para especificar um array.
      Para mudar um certo valor, apenas assimile um novo valor
      para um elemento especificado por sua chave. Se você quiser
      remover um par chave/valor, você precisa aplicar <function>unset</function> nele.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Isto eh o mesmo que $arr[13] = 56;
                // nesse ponto do script

$arr["x"] = 42; // Isto acrescenta um novo elemento
                // para o array com a chave "x"

unset($arr[5]); // Isto remove um elemento do array

unset($arr);    // E isto apaga todo o array
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       Como mencionado acima, não informar a chave dentro dos
       colchetes, então o maior índice inteiro é
       obtido, e a nova chave será esse  máximo + 1. Se nenhum 
       índice inteiro existir ainda, a chave será <literal>0</literal> 
       (zero). Se você especificar uma chave que já possui um valor assimilada 
       a ela, então o valor é sobrescrito.
      </para>
      <para>
       <warning>
        <simpara>
         A partir do PHP 4.3.0, o comportamento da geração de índice descrito
         acima foi modificado. Agora, se você aumentar um array em que
         o maior índice atual for negativo, então a próxima chave
         criada será zero (<literal>0</literal>). Antes, o novo
         índice seria o maior índice existente mais 1,
         do mesmo jeito que os índices positivos.
        </simpara>
       </warning>
      </para>
      <para>
       Note que a chave inteira maior utilizada para isso <emphasis>não
       precisa necessariamente existir no array</emphasis>. Ele pode ter
       existido no array desde a última vez que o
       array foi indexado. Veja o seguinte exemplo:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Criando um array normal
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Agora apagando todos os itens, mas deixando o array intacto:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Acrescentando um item (note que a chabe eh 5, em vez de zero
// como voce pode ter esperado).
$array[] = 6;
print_r($array);

// Reindexando:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
       </programlisting>
       <para>
        O exemplo acima deve produzir a seguinte saída:
        <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
        </screen>
       </para>
      </informalexample>

     </note>
    </sect3>
   </sect2><!-- end syntax -->

   <sect2 id="language.types.array.useful-funcs">
    <title>Funções úteis</title>
    <para>
     Há uma série de funções muito úteis para trabalhar com arrays.
     Veja a seção sobre <link linkend="ref.array">arrays</link>.
    </para>
    <note>
     <para>
      A função <function>unset</function> permite apagar chaves de um
      array. Esteja avisado que o array NÃO vai ser reindexado. Se você somente
      usa "índices inteiros comuns" (começando do zero, aumentando um a um),
      você pode conseguir reindexar o aaray utilizando <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array( 1 => 'um', 2 => 'dois', 3 => 'três' );
unset( $a[2] );
/* irá produzir um array que pode ser definido como
   $a = array( 1=>'um', 3=>'três');
   e NÃO
   $a = array( 1 => 'um', 2 => 'três');
*/

$b = array_values($a);
// Agora b eh o  array(1 => 'um', 2 =>'três')
?>
]]>
      </programlisting>
     </informalexample>

     </para>
    </note>
    <para>
     <link linkend="control-structures.foreach">foreach</link>
     existe especificamente para lidar com arrays. Ele
     provém uma maneira fácil de percorrer qualquer array.
    </para>
   </sect2>

   <sect2 id="language.types.array.donts">
    <title>Array: faça e não faça</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Porque <literal>$foo[bar]</literal> está errado?</title>
     <para>
      Você sempre deve usar delimitadores em volta um índice 
      de um array associativo. Por exemplo, utilizar $foo['bar'] e não 
      $foo[bar]. Mas porque $foo[bar] está errado? Afinal de contas, você vê 
      essa sintaxe nos scripts antigos:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'inimigo';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      Isto está errado, mas funciona. Então, porque está errado? A razão está
      neste código, que tem uma constante indefinida (bar) em vez de uma
      string ('bar' - repare nos delimitadores), e o PHP pode no futuro definir
      constantes que, infelizmente em seu código, podem ter o mesmo
      nome. Isto funciona, porque o PHP automaricamente converte uma
      <emphasis>string base</emphasis> (uma string não delimitada que
      não corresponde a nenhum símbolo conhecido) em uma string que contém
      a string base. Por exemplo, se não existir uma constante definida com o
      nome <constant>bar</constant>, então o PHP irá substituí-la pela
      string <literal>'bar'</literal> e usá-la.
     </para>
     <note>
      <simpara>
       Isto não significa que você <emphasis>sempre deve</emphasis> delimitar as
       chaves nos arrays. Você não deve delimitar chaves que sejam <link
       linkend="language.constants">constantes</link> ou <link
       linkend="language.variables">variáveis</link>, porque isso vai
       impedir o PHP de interpretá-las.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Arrays simples:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nVerificando $i: \n";
    echo "Ruim: " . $array['$i'] . "\n";
    echo "Bom: " . $array[$i] . "\n";
    echo "Ruim: {$array['$i']}\n";
    echo "Bom: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      <para>
       A saída do código acima deve ser:
       <screen>
<![CDATA[
Verificando 0:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Ruim:
Bom: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Ruim:
Bom: 1

Verificando 1:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Ruim:
Bom: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Ruim:
Bom: 2
]]>        
       </screen>
      </para>
     </note>
     <para>
      Mais exemplos para demonstrar esse fato:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Vamos ver todos os erros
error_reporting(E_ALL);

$arr = array('fruta' => 'maçã', 'legume' => 'cenoura');

// Correto
print $arr['fruta'];  // maçã
print $arr['legume']; // cenoura

// Errado. Isto funciona mas lança um erro PHP do
// nível E_NOTICE porque é utilizada uma constante indefinida (fruta)
// 
// Repare: Quando utiliza-se a constrante indefinida fruta, o PHP assume 'fruta'
print $arr[fruta];    // maçã

// Agora vamos definir uma constante para demonstrar o que pode acontecer. Nós
// vamos assimilar o valor 'legume' para a constante de nome fruta
define('fruta', 'legume');

// Observe a diferenca agora
print $arr['fruit'];  // maçã
print $arr[fruit];    // cenoura

// O exemplo seguinte é normal dentro de uma string. Constantes não são
// observadas dentro de strings e por isso nenhum E-NOTICE não é lançado aqui
print "Olá $arr[fruta]";      // Olá maçã

// Com uma exceção: chaves envolvendo arrays dentro de strings
// ativam a checagem de constantes, como em
print "Olá {$arr[fruta]}";    // Hello cenoura
print "Olá {$arr['fruta']}";  // Hello maçã

// E isso não funciona, resultando em um erro de interpretação do tipo:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Isso se aplica ao uso de autoglobais em strings
print "Olá $arr['fruta']";
print "Olá $_GET['foo']";

// Nesse caso, use concatenacao
print "Olá " . $arr['fruta']; // Olá maçã
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Quando você ativa <function>error_reporting</function> para mostrar erros de nível
      <constant>E_NOTICE</constant> (como configurando-a
      para <constant>E_ALL</constant>) você vê esses
      erros. Por padrão, <link linkend="ini.error-reporting">
      error_reporting</link> esté configurada para não mostrar esse nível de erro.
     </para>
     <para>
      Como explicado na seção <link 
      linkend="language.types.array.syntax">sintaxe</link>, 
      a chave precisa estar entre colchetes 
      ('<literal>[</literal>' e '<literal>]</literal>'). Isto significa 
      que você pode escrever coisas como isso:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[algumafuncao($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      Isto é um exemplo de utilização de um valor de retorno de função
      como um índice de array. O PHP conhece constantes,
      como você deve ter visto algumas <literal>E_*</literal>
      antes.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR] = "Um erro fatal ocorreu";
$error_descriptions[E_WARNING] = "O PHP emitiu um alarme";
$error_descriptions[E_NOTICE] = "Apenas um aviso informal";
?>
]]>
       </programlisting>
      </informalexample>
      Note que <literal>E_ERROR</literal> é um identificador válido,
      assim como <literal>bar</literal> no primeiro exemplo. Mas no último
      exemplo seria a mesma coisa que escrevendo:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Um erro fatal ocorreu";
$error_descriptions[2] = "O PHP emitiu um alarme";
$error_descriptions[8] = "Apenas um aviso informal";
?>
]]>
       </programlisting>
      </informalexample>
      porque <literal>E_ERROR</literal> é igual a <literal>1</literal>, e assim por diante.
     </para>
     <para>
      Como nós mostramos nos exemplos anteriores,
      <literal>$foo[bar]</literal> funciona mas está errado.
      Funciona porque <literal>bar</literal>, na sintaxe onde é utilizada
      é esperada como uma expressão constante. Entretanto, nesse caso não
      existe constante com o nome <literal>bar</literal>. O PHP, hoje,
      assume que você quer <literal>bar</literal> literalmente,
      como a string <literal>"bar"</literal>, mas que você esqueceu
      de escrever os delimitadores.
     </para>
     <sect4>
      <title>Então, porque isso é tão mal?</title>
      <para>
       Se em algum ponto do futuro, o time do PHP quiser acrescentar outra
       constante ou palavra chave, ou você mesmo introduzir outra constante na
       sua aplicação, você terá problemas. Por exemplo,
       se você já não pode utilizar as palavras <literal>empty</literal> e
       <literal>default</literal> dessa maneira, desde que elas são
       <link linkend="reserved">palavras reservadas especiais</link>.
      </para>
      <note>
       <simpara>
        Só para fixar, dentro de uma <type>string</type> delimitada por aspas, é
        válido não englobar índices de arrays com apóstrofos, de forma que
        <literal>"$foo[bar]"</literal> é válido. Veja os exemplos
        anteriores para detalhes bem como na seção sobre
        <link linkend="language.types.string.parsing">interpretação de variáveis
        em strings</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Convertendo para array</title>

    <para>
     Para qualquer dos tipos: <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>boolean</type> e <type>resource</type>,
     se você converte um valor para um <type>array</type>, você obtêm um array
     com um elemento (de índice 0) contendo o valor escalar
     informado.
    </para>

    <para>
     Se você converte um tipo <type>object</type> para um array, você obtêm
     as propriedades (variáveis membro) do objeto com elementos do array.
     As chaves serão o nome das variáveis membro.
    </para>

    <para>
     Se você converter um valor &null; para um array, você terá um array vazio.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Exemplos</title>
    <para>
     O tipo array do PHP é muito versátil, por isso temos aqui alguns
     exemplos para mostrar todo o poder dos arrays.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// isto
$a = array( 'cor'   => 'vermelha',
            'sabor' => 'doce',
            'forma' => 'redonda',
            'nome'  => 'maçã',
                       4        // a chave será 0
          );

// isto é equivalente a acima
$a['cor']   = 'vermelha';
$a['sabor'] = 'doce';
$a['forma'] = 'redonda';
$a['nome']  = 'maçã';
$a[]        = 4;        // a chave será 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// o mesmo de array( 0 => 'a' , 1 => 'b' , 2 => 'c' ),
// ou simplesmente array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>

    <example>
     <title>Utilizando array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array como (propriedade-)mapa
$map = array( 'versao'     => 4,
              'OS'         => 'Linux',
              'lang'       => 'inglês',
              'short_tags' => true
            );

// apenas chaves numéricas
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// que é o mesmo que array( 0 => 7, 1 => 8, ...)

$switching = array(         10, // chave = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // chave = 6 (o índice máximo era 5)
                    '8'  =>  2, // chave = 8 (inteiro!)
                    '02' => 77, // chave = '02'
                    0    => 12  // o valor 10 será sobrescrito por 12
                  );

// array vazio
$empty = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Coleção</title>
     <programlisting role="php">
<![CDATA[
<?php
$cores = array('vermelho', 'azul', 'verde', 'amarelo');

foreach ($cores as $cor) {
    echo "Você gosta de $cor?\n";
}

/* saida:
Você gosta de vermelho?
Você gosta de azul?
Você gosta de verde?
Você gosta de amarelo?
*/
?>
]]>
     </programlisting>
    </example>

    <para>
     Note que atualmente não se pode mudar os valores de um array
     diretamente dentro de um loop.
      <!--
       Should be made possible, if you write:
       foreach ( $cores as &$cor )

       See bug#3074
      -->
     Superar essa limitação é possível da seguinte forma:
     <example id="language.types.array.examples.changeloop">
      <title>Coleção</title>
      <programlisting role="php">
<![CDATA[
<?php
foreach ($cores as $key => $cor) {
    // não funciona:
    //$cor = strtoupper($cor);

    //funciona:
    $cores[$key] = strtoupper($cor);
}
print_r($cores);

/* saida:
Array
(
    [0] => VERMELHO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARELO
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Este exemplo cria um array na base 1.
     <example>
      <title>Array baseado em 1</title>
      <programlisting role="php">
<![CDATA[
<?php
$primeiroquarto  = array(1 => 'Janeiro', 'Fevereiro', 'Março');
print_r($primeiroquarto);

/* saida:
Array
(
    [1] => 'Janeiro'
    [2] => 'Fevereiro'
    [3] => 'Março'
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <example>
     <title>Preenchendo um array real</title>
     <programlisting role="php">
<![CDATA[
<?php
// preenchendo um array com todos os itens de um diretório
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle); 
?>
]]>
     </programlisting>
    </example>
    <para>
     Arrays são ordenados. Você pode mudar sua ordem utilizando vários
     funções de ordenação. Veja as <link linkend="ref.array">funções
     de arrays</link> para mais informações. Você pode contar
     o número de itens de um array com a função
     <function>count</function>.
    </para>
    <example>
     <title>Ordenando arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Porque o valor de um array pode ser qualquer coisa, isto pode ser
     outro array. Isto pode criar arrays recursivos e
     multidimensionais.
    </para>
    <example>
     <title>Arrays recursivos e multidimensionais</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "frutas"  => array ( "a" => "laranja",
                                       "b" => "banana",
                                       "c" => "maçã",
                                     ),
                  "numeros" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "buracos" => array (      "primeiro",
                                       5 => "segundo",
                                            "terceiro",
                                     ),
                );

// Alguns exemplo de enderecos dos valores do array acima
echo $fruits["buracos"][5];   // prints "segundo"
echo $fruits["frutas"]["a"];  // prints "laranja"
unset($fruits["buracos"][0]); // remove "primeiro"

// Criando um novo array multidimensional
$sucos["maca"]["verde"] = "bom";
?>
]]>
     </programlisting>
    </example>
    <para>
     Você precisa estar ciente que a atribuição sempre envolve
     cópia de valor. Você precisa utilizar o operadore de referência para
     copiar um array por referência.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 eh modificado,
             // $arr1 continua sendo apenas array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // agora $arr1 e $arr3 sao os mesmos
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objetos</title>

   <sect2 id="language.types.object.init">
    <title>Inicialização de objetos</title>

    <para>
     Para inicializar um objeto, você usa a instrução <literal>new</literal>,
     criando uma instância do objeto em uma variável.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Fazendo foo.";
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Para uma explicação completa, consulte a seção <link
     linkend="language.oop">Classes e Objetos</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.object.casting">
    <title>Convertendo para objeto</title>

    <para>
     Se um objeto é convertido para objeto, ele não é modificado. Se um valor
     de um outro tipo é convertido para objeto, uma nova instância da
     <literal>stdClass</literal> é criada. Se o valor
     é NULL, a nova instância estará vazia. Para qualquer outro valor, uma
     variável menbro chamada <literal>scalar</literal> irá conter
     valor.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // exibe 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>

    <para>
     Recurso é uma variável especial, mantendo
     uma referência de recurso externo. Recursos
     são criados e utilizados por funções especiais.
     Veja o <link linkend="resource">apêndice</link>
     para uma lista de todas essas
     funções e seus tipos correspondentes.
    </para>

    <note>
     <simpara>
      O tipo resource foi incluído no PHP 4
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>Convertendo para recurso</title>

    <para>
     Como os tipos resource sustentam manipuladores especiais para arquivos
     abertos, conexões de bancos de dados, pinceis de desenho e coisas
     assim, você não pode converter nenhum valor para o tipo resource.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Liberando recursos</title>

    <para>
     Através do sistema de contagem de referências introduzido
     com o engine da Zend no PHP 4, é automaticamente detectado
     quando um recurso não mais é referenciado (assim
     como o Java). Quando isto
     acontece, todos os recursos em uso por esse
     resource são liberados pelo coletor de lixo.
     Por essa razão, é raramente necessário
     liberar memória manualmente utilizando alguma função
     free_result.
     <note>
      <simpara>
       Conexões persistentes de bancos são especiais. Eles
       <emphasis>não são</emphasis> destruídos pelo
       coletor de lixo. Veja também <link
       linkend="features.persistent-connections">conexões
       permanentes</link>.
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.null">
   <title>NULL</title>

   <para>
    O valor especial &null; representa
    que a variável não tem valor. &null; é o único valor possível do tipo
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      O tipo NULL foi incluído no PHP 4
     </simpara>
    </note>
    <para>
     A variável é considerada &null; se
     <itemizedlist>
      <listitem>
       <para>
        ela foi assimilada com a constante &null;.
       </para>
      </listitem>
      <listitem>
       <para>
        ela ainda não recebeu nenhum valor ainda.
       </para>
      </listitem>
      <listitem>
       <para>
        ela foi apagada com <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>

   <sect2 id="language.types.null.syntax">
    <title>Sintaxe</title>
    <para>
     Há apenas um único valor do tipo &null;, e é
     a palavra (insensitiva ao caso) &null;.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Veja também <function>is_null</function> e <function>unset</function>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.pseudo-types">
   <title>Pseudo-tipos utilizados nesta documentação</title>

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> indica que um parâmetro pode aceitar vários (mas não
     necessariamente todos) os tipos
    </para>
    <para>
     <function>gettype</function>, por exemplo, aceita todos os tipos do PHP,
     enquanto <function>str_replace</function> somente aceita strings e arrays.
    </para>
   </sect2>

   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> indica que um parâmetro pode ser tanto um
     <type>integer</type> ou <type>float</type>.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     Some functions like <function>call_user_func</function>
     or <function>usort</function> accept user defined
     callback functions as a parameter. Callback functions can not only
     be simple functions but also object methods including static class
     methods.
    </para>
    <para>
     A PHP function is simply passed by its name as a string. You can
     pass any builtin or user defined function with the exception of
     <function>array</function>,
     <function>echo</function>,
     <function>empty</function>,
     <function>eval</function>,
     <function>exit</function>,
     <function>isset</function>,
     <function>list</function>,
     <function>print</function> and
     <function>unset</function>.
    </para>
    <para>
     A method of an instantiated object is passed as an array containing
     an object as the element with index 0 and a method name as the
     element with index 1.
    </para>
    <para>
     Static class methods can also be passed without instantiating an
     object of that class by passing the class name instead of an
     object as the element with index 0.
    </para>

    <para>
     <example>
      <title>
       Exemplo de funções callback
      </title>
      <programlisting role="php">
<![CDATA[
<?php

// Exemplo simples de callback
function my_callback_function() {
    echo 'Olá Mundo!';
}
call_user_func('my_callback_function');

// Exemplo de metodo callback
class MyClass {
    function myCallbackMethod() {
        echo 'Olá Mundo!';
    }
}

// Metodo estatico de classe chamado sem qualquer instância do método
call_user_func(array('MyClass', 'myCallbackMethod'));

// Chamada de metodo de objeto
$obj = new MyClass();
call_user_func(array(&$obj, 'myCallbackMethod'));
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Manipulação de tipos</title>

   <simpara>
    O PHP não requer (ou suporta) a definição de tipo explicita na
    declaração de variáveis: o tipo de uma variável é determinado pelo
    contexto em que a variável é utilizada. Isto significa que, se você
    assimila um valor string para a variável <parameter>$var</parameter>,
    <parameter>$var</parameter> se torna uma string. Se você então assimila um
    valor inteiro para <parameter>$var</parameter>, ela se torna
    um inteiro.
   </simpara>
   <para>
    Um exemplo da conversão automática do PHP é o operador de
    adição '+'. Se qualquer um dos operadores for float, então todos
    os operadores são avaliados como floats, e o resultado será um
    float. De outra forma, se os operadores forem interpretados como inteiros
    então o resultado será um inteiro. Note que isso NÃO
    muda os tipos dos operadores: apenas muda em como
    esses operadores são avaliados.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo eh string (ASCII 48)
$foo += 2;   // $foo eh agora um interio (2)
$foo = $foo + 1.3;  // $foo eh agora um float (3.3)
$foo = 5 + "10 pequenos porcos";   // $foo eh inteiro (15)
$foo = 5 + "10 minúsculos porcos"; // $foo eh inteiro (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Se os últimos dois exemplos lhe parecerem estranhos, veja <link
    linkend="language.types.string.conversion">Conversão de
    strings para números</link>.
   </simpara>
   <simpara>
    Se você deseja forçar uma variável para ser avaliada como um certo tipo,
    veja a seção <link linkend="language.types.typecasting">Moldando o
    tipo (casting)</link>. Se você deseja mudar o tipo de uma variável, veja
    <function>settype</function>.
   </simpara>
   <para>
    Se quiser testar qualquer um dos exemplo desta seção, você pode
    usar a função <function>var_dump</function>.
   </para>
   <note>
    <para>
     O comportamento de uma conversão automática para array é atualmente
     indefinida.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a é uma string
$a[0] = "f";  // E com relação aos índices da string? O que acontece?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Desde que o PHP (por razões históricas) suporta indexação de strings 
     através de offsets utilizando a mesma sintaxe da indexação de arrays, o exemplo 
     acima nos deixa um problema: $a se tornou um array sendo o primeiro 
     elemento "f", ou será que "f" se tornou o primeiro caracter 
     da string $a ?
    </para>
    <para>
     As versões atuais do PHP interpretam a segunda assimilacao como
     identificação de deslocamento na string, então $a se torna "f", o resultado
     desta conversão automática entretanto pode ser considerada
     indefinida. O PHP 4 introduziu a nova sintaxe de chaves para acessar
     caracteres na string. Utilize esta sintaxe em vez do exemplo apresentado
     acima:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a eh uma string
$a{1} = "f";   // $a eh agora "afc"
?>
]]>
      </programlisting>
     </informalexample>
     Veja a seção entitulada <link linkend="language.types.string.substr">Acessando
     caracteres da string</link> para mais informações.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Moldando Tipos - Type Casting</title>

    <para>
     A moldagem de tipos no PHP funciona como no C: o nome de um
     tipo desejado é escrito entre parênteses antes da variável em
     que se deseja a moldagem.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;             // $foo eh um inteiro
$bar = (boolean) $foo; // $bar eh um booleano
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     As moldagens permitidas são:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - molde para inteiro</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - molde para booleano</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - molde para número de ponto flutuante</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - molde para string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - molde para array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - molde para objeto</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note que tabulações e espaços são permitidos dentro dos parênteses, então
     o seguinte são funcionalmente equivalentes:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Em vez de moldar uma variável para string, você também pode englobar
      a variável entre aspas duplas.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo eh um interio
$str = "$foo";        // $str eh uma string
$fst = (string) $foo; // $fst tambem eh uma string

// Isto imprimirah "eles são o mesmo"
if ($fst === $str) {
    echo "eles são o mesmo";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>

    <para>
     Pode não ser tão óbvio o que exatamente ocorre quando se molda
     entre certos tipos. Para mais informações, veja essas seções:

     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Convertendo para
        booleano</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Convertendo para
        inteiro</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Convertendo para
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Convertendo para
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Convertendo para
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Convertendo para
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Convertendo para
        resource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to
        &null;</link></simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">Tabela de comparação entre tipos</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
