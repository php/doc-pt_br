<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.154 Maintainer: felipe Status: ready --><!-- CREDITS: ae -->
<chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Estruturas de Controle</title>

  <simpara>
   Qualquer script PHP é construído por uma série de instruções. Uma instrução
   pode ser uma atribuição, uma chamada de função, um 'loop', uma instrução
   condicional, ou mesmo uma instrução que não faz nada (um comando vazio).
   Instruções geralmente terminam com um ponto e vírgula. Além disso, as
   instruções podem ser agrupados em um grupo de comandos através do encapsulamento
   de um grupo de comandos com chaves. Um grupo de comandos é uma instrução
   também. Os vários tipos de instruções são
   descritos neste capítulo.
  </simpara>

  <sect1 xml:id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    A construção <literal>if</literal> é uma das mais importantes implementações de
    muitas linguagens, incluindo o PHP. Ela permite a execução condicional de fragmentos
    de código. O PHP implementa uma estrutura <literal>if</literal>
    que é similar aquela do C:
    <informalexample>
     <programlisting>
<![CDATA[
if (expressao)
    instrucoes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Como descrita na <link linkend="language.expressions">seção sobre
    expressões </link>, <replaceable>expressao</replaceable> é avaliado por seu
    contexto Booleano. Se <replaceable>expressao</replaceable> for avaliado como &true;,
    o PHP executará <replaceable>instrucoes</replaceable>, e se for avaliado
    como &false;, ele será ignorado. Maiores informações sobre a avaliação
    para &false; podem ser encontradas na seção <link
    linkend="language.types.boolean.casting">Convertendo para Booleanos</link>
    .
   </simpara>
   <para>
    Os exemplos a seguir mostrariam que <computeroutput>a é maior que
    b</computeroutput> se <varname>$a</varname> for maior que
    <varname>$b</varname>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a é maior que b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Normalmente você vai querer ter mais que uma instrução seja executado
    condicionalmente. E é claro, não há necessidade de englobar cada instrução
    com uma cláusula <literal>if</literal>. Em vez disso, você pode colocar
    várias instruções em um agrupamento de comandos. Por exemplo, este código
    mostraria <computeroutput>a é maior que b</computeroutput>
    se <varname>$a</varname> for maior que
    <varname>$b</varname>, e então atribuiria o valor de
    <varname>$a</varname> para <varname>$b</varname>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a é maior que b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Comandos <literal>if</literal> podem ser aninhados indefinidamente dentro de outros comandos
    <literal>if</literal>, o que faz com que você complete a flexibilidade para a
    execução condicional de várias partes do seu
    programa.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Normalmente você vai querer executar uma instrução se uma certa condição for
    encontrada, e uma instrução diferente se a condição não for encontrada. Isto
    é o que o <literal>else</literal> faz. <literal>else</literal>
    estende um comando <literal>if</literal> para executar uma instrução
    caso a expressão no comando <literal>if</literal>
    seja avaliada como &false;. Por exemplo, o código a
    seguir mostraria <computeroutput>a é maior que
    b</computeroutput> se <varname>$a</varname> for maior que
    <varname>$b</varname>, e <computeroutput>a NÃO é maior que
    b</computeroutput> caso contrário:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a é maior que b";
} else {
    echo "a NÃO é maior que b";
}
?>
]]>
     </programlisting>
    </informalexample>

    O comando <literal>else</literal> só é executado se a expressão
    <literal>if</literal> for avaliada como
    &false;, e se havendo qualquer expressão
    <literal>elseif</literal>, somente se todas elas forem avaliadas como
    &false; também (veja <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, como seu nome sugere, é uma combinação
    de <literal>if</literal> e <literal>else</literal>. Da mesma forma que o
    <literal>else</literal>, ele estende um comando <literal>if</literal>
    para executar uma instrução diferente no caso de a expressão
    <literal>if</literal> original ser avaliada como
    &false;. Porém, ao contrário de
    <literal>else</literal>, ele executará aquela expressão alternativa
    somente se a expressão condicional do <literal>elseif</literal> for
    avaliada como &true;. Por exemplo, o código a seguir
    mostraria <computeroutput>a é maior que
    b</computeroutput>, <computeroutput>a é igual a b</computeroutput>
    ou <computeroutput>a é menor que b</computeroutput>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a é maior que b";
} elseif ($a == $b) {
    echo "a é igual a b";
} else {
    echo "a é menor que b b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Podem haver vários <literal>elseif</literal>s dentro da mesma instrução
    <literal>if</literal>. A primeira expressão
    <literal>elseif</literal> (se houver) que for avaliada como
    &true; será executada. No PHP, você também pode
    escrever 'else if' (em duas palavras) e o comportamento será idêntico a um
    'elseif' (em uma só palavra). O significado sintático
    é ligeiramente diferente (se você está familiarizado com C, eles tem o mesmo
    comportamento), mas no final das contas ambos teriam exatamente
    o mesmo comportamento.
   </simpara>
   <simpara>
    O comando <literal>elseif</literal> só é executado se a expressão
    <literal>if</literal> precedente e quaisquer expressões
    <literal>elseif</literal> anteriores forem avaliadas como
    &false;, e a expressão
    <literal>elseif</literal> atual for avaliada como
    &true;.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>Sintaxe alternativa para estruturas de controle</title>
   <para>
    O PHP oferece uma sintaxe alternativa para algumas das suas estruturas
    de controle: <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> e <literal>switch</literal>.
    Em cada caso, a forma básica da sintaxe alternativa é mudar
    o sinal de abertura para dois-pontos (:) e o sinal de fechamento para
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal> ou
    <literal>endswitch;</literal>, respectivamente.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A é igual a 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    No exemplo acima, o bloco HTML "A é igual a 5" está aninhado dentro de uma instrução
    <literal>if</literal> escrito na sintaxe alternativa.
    O bloco HTML será mostrado somente se <varname>$a</varname> é igual a 5.
   </simpara>
   <para>
    A sintaxe alternativa se aplica a <literal>else</literal> e
    <literal>elseif</literal> também.  A seguir temos uma estrutura
    <literal>if</literal> com <literal>elseif</literal> e
    <literal>else</literal> no formato alternativo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a igual a 5";
    echo "...";
elseif ($a == 6):
    echo "a igual a 6";
    echo "!!!";
else:
    echo "a não é nem 5 nem 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Veja também: <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link> e <link
    linkend="control-structures.if">if</link> para mais exemplos.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    Loops <literal>while</literal> são o tipo mais simples de criar um 'loop' em
    PHP. Eles se comportam como seus compatíveis em C. O formato básico de um comando
    <literal>while</literal> é:
    <informalexample>
     <programlisting>
<![CDATA[
while (expressao)
  instrucoes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    O significado de um comando <literal>while</literal> é simples. Ele
    pede que o PHP execute os comandos aninhados repetidamente, enquanto
    a expressão do <literal>while</literal> é avaliada como
    &true;. O valor da expressão é verificada
    cada vez que se passa no começo do 'loop', desta forma, mesmo que este valor
    mude durante a execução do(s) comando(s) aninhado(s), a execução
    não parará até que o fim da iteração (cada vez que o PHP executa
    os comandos dentro do 'loop' é uma iteração). Às vezes, se a
    expressão <literal>while</literal> é avaliada como
    &false; logo no início, o(s) comando(s)
    aninhado(s) não será(ão) rodado(s) nem uma vez sequer.
   </simpara>
   <para>
    Como no comando <literal>if</literal>, você pode agrupar
    múltiplos comandos dentro do mesmo laço <literal>while</literal>
    englobando um grupo de instruções com chaves, ou
    usando a sintaxe alternativa:
    <informalexample>
     <programlisting>
<![CDATA[
while (expressao):
 instrucoes
 ...
 endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Os exemplos a seguir são idênticos, e ambos imprimem números de
    1 até 10:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* exemplo 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* o valor impresso será
                   $i depois do acréscimo
                   (post-increment) */
}

/* exemplo 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    Loops <literal>do-while</literal> são bem similares aos loops
    <literal>while</literal>, exceto pelo fato de que a condição
    é verificada no fim de cada iteração em vez de no começo.
    A diferença principal dos loops <literal>while</literal> regulares é que
    a primeira iteração de um loop <literal>do-while</literal> é garantidamente
    executada (a condição só é verificada no fim
    da iteração) enquanto que ele pode não rodar necessariamente em um loop
    <literal>while</literal> normal (a condição é
    verificada no começo de cada iteração, se ela é avaliada como
    &false; logo no começo, a execução do loop
    terminaria imediatamente).
   </simpara>
   <para>
    Há apenas uma sintaxe para loops <literal>do-while</literal>:

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     O loop acima rodaria exatamente uma vez, desde que depois da primeira
     iteração, quando a condição é verificada, ela é avaliada como
     &false; ($i não é maior que zero 0) e a execução do loop
     termina.
   </simpara>
   <para>
    Usuários avançados de C podem estar familiarizados com o uso diferenciado do
    loop <literal>do-while</literal>, para permitir o fim da execução no
    meio dos blocos de código, englobando-os com
    <literal>do-while</literal> (0), e usando a instrução <link
    linkend="control-structures.break"><literal>break</literal></link>
    . O fragmento de código a seguir demonstra isso:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i não é grande o suficiente";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "i está Ok";

    /* process i */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Não se preocupe se você não entendeu isto da forma certa ou de jeito nenhum.
    Você pode codificar scripts simples ou mesmo poderosos sem usar esse
    'recurso'.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Loops <literal>for</literal> são os laços mais complexos em PHP.
    Eles se comportam como os seus compatíveis em C. A sintaxe de um loop
    <literal>for</literal> é:
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3)
  instrucoes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
       A primeira expressão (<varname>expr1</varname>) é
    avaliada (executada) uma vez incondicionalmente no começo do
    loop.
   </simpara>
   <simpara>
    No começo de cada iteração,
    <varname>expr2</varname> é avaliada. Se ela é avaliada como
    &true;, o loop continua e o(s) comando(s)
    aninhado(s) é(são) executado(s). Se é avaliada como
    &false;, a execução do 'loop' termina.
   </simpara>
   <simpara>
       No fim de cada iteração, <varname>expr3</varname> é avaliada
    (executada).
   </simpara>
   <simpara>
    Cada uma das expressões pode ser vazia ou conter múltiplas
    expressões separadas por vírgulas. Espressões separadas por vírgula em expr2
    são tradadas similarmente a ser separada pelo <link
    linkend="language.operators.logical">|| operador</link> mas a
    menor precedencia do que ||.
    <varname>expr2</varname> vazia significa que o loop pode rodar
    indefinidamente (PHP considera-a implicitamente como
    &true;, como em C). Isto pode não ser tão inútil quanto
    você pode pensar, pois freqüentemente você pode querer terminar o 'loop'
    usando uma instrução <link
    linkend="control-structures.break"><literal>break</literal></link>
    condicional em vez de usar a expressão-verdade do <literal>for</literal>.

   </simpara>
   <para>
    Considere os seguintes exemplos. Todos eles mostram números de
    1 até 10:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* exemplo 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* exemplo 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* exemplo 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* exemplo 4 */

for ($i = 1, $j = 0; $i <= 10; $j += $i, print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Obviamente, o primeiro exemplo parece ser o mais bonito (ou
    talvez o quarto), mas você pode perceber que a possível utilização de expressões
    vazias em laços <literal>for</literal> se torna prático em algumas
    ocasiões.
   </simpara>
   <para>
    O PHP também suporta a "sintaxe de dois-pontos" alternativa para
    laços <literal>for</literal>:
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3):
 instrucoes;
 ...;
 endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    O PHP4 inclui um construtor <literal>foreach</literal>, muito
    parecido com o Perl e outras linguagens. Isto oferece uma maneira fácil de
    iterar sobre matrizes. <literal>foreach</literal> funciona somente com arrays, e
    lançará um erro se tentar utilizá-lo em uma variável de qualquer tipo
    diferente ou em variáveis não inicializadas. Há duas sintaxes; a
    segunda é uma abreviatura, mas bem útil do que primeira:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (expressao_array as $valor)
  instrucoes
foreach (expressao_array as $chave => $valor)
 instrucoes
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    A primeira forma varre uma dada matriz dada por
    <literal>expressao_array</literal>. Em cada 'loop', o valor do elemento
    corrente é atribuído a <literal>$valor</literal> e o ponteiro interno da
    matriz é avançado em uma posição (assim, no próxima iteração você estará
    olhando para o próximo elemento).
   </simpara>
   <simpara>
    A segunda forma faz a mesma coisa, exceto pelo fato de que a chave do elemento
    atual será atribuído à variável
    <literal>$chave</literal> em cada iteração.
   </simpara>
   <simpara>
    A partir do PHP 5, é possível
    <link linkend="language.oop5.iterations">iterar objetos</link> também.
    </simpara>
   <para>
    <note>
     <para>
      Quando o <literal>foreach</literal> inicia sua primeira execução, o ponteiro
      interno da matriz é zerado automaticamente para o primeiro elemento do array.
      Isto significa que você não precisa chamar
      <function>reset</function> antes de um loop <literal>foreach</literal>
      .
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Note também que <literal>foreach</literal> opera sobre uma cópia do
      array especificado, não o próprio array. <literal>foreach</literal>
      tem é semelhante um array de ponteiros. Não confie no ponteiro do
      array durante ou após o foreach sem resetá-lo.
     </para>
    </note>
   </para>
   <para>
    A partir do PHP 5, você pode modificar facilmente os elementos da matriz precedendo
    <literal>$value</literal> com &amp;. Isto irá definir uma
    <link linkend="language.references">referência</link> ao invés de copiar o valor.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr is now array(2, 4, 6, 8)
unset($value); // quebra a referência com o último elemento
?>
]]>
     </programlisting>
    </informalexample>
    Isto é possível apenas se a matriz iterada puder ser referenciada
    (isto é, uma variável).
   </para>
   <warning>
    <para>
     Reference of a <literal>$value</literal> and the last array element
     remain even after the <literal>foreach</literal> loop. It is recommended
     to destroy it by <function>unset</function>.
   </para>
  </warning>
   <para>
    <note>
     <para>
      <literal>foreach</literal> tem a habilidade de
      evitar mensagens de erro com '@'.
     </para>
    </note>
   </para>
   <para>
    Você pode ter notado que os seguintes itens são funcionalmente
    idênticos:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("um", "dois", "três");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Valor: $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valor: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Os seguintes também são funcionalmente idênticos:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset($arr);
while (list($key, $value) = each ($arr)) {
    echo "Chave: $key; Valor: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Chave: $key; Valor: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Mais alguns exemplos para demonstrar os usos:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* exemplo foreach 1: somente valores */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "Valor atual de \$a: $v.\n";
}

/* exemplo foreach 2: valores (com as chaves impressas para ilustração) */

$a = array(1, 2, 3, 17);

$i = 0; /* para exemplo somente */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* exemplo foreach 3: chaves e valores */

$a = array (
    "um" => 1,
    "dois" => 2,
    "três" => 3,
    "dezessete" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* exemplo foreach 4: arrays multidimensionais */

$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* exemplo foreach 5: arrays dinâmicos */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> cancela a execução do comando
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal> ou
    <literal>switch</literal> atual.
   </simpara>
   <simpara>
    <literal>break</literal> aceita um argumento numérico opcional
    que diz a ele quantas estruturas aninhadas englobadas devem
    ser quebradas.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('um', 'dois', 'três', 'quatro', 'PARE', 'cinco');
while (list (, $val) = each ($arr)) {
    if ($val == 'PARE') {
        break;    /* Você poderia colocar 'break 1;' aqui. */
    }
    echo "$val<br />\n";
}

/* Utilizando o argumento opcional. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "No 5<br />\n";
        break 1;  /* Sai somente do switch. */
    case 10:
        echo "No 10; saindo<br />\n";
        break 2;  /* Sai do switch e while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> é usado dentro de estruturas de loops
    para saltar o resto da iteração do loop atual e continuar a execução
    na avaliação e no início da próxima iteração.
   </simpara>
   <note>
    <simpara>
     Note que no PHP a instrução
     <link linkend="control-structures.switch">switch</link> é
     considerada uma estrutura de loop quando relacionada ao comando
     <literal>continue</literal>.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> aceita um argumento numérico opcional que diz
    a ele de quantos níveis de loops aninhados ele deve saltar
    até o fim.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // pula itens pares
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Fora<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Meio<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Dentro<br />\n";
            continue 3;
        }
        echo "Isto nunca será exibido.<br />\n";
    }
    echo "Nem isso.<br />\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Omitindo o ponto e vírgula depois do <literal>continue</literal> pode resultar em
     confusão. Este é um exemplo do que você não deve fazer.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Um resultado esperado poderia ser:
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       mas esse script somente exibirá:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       porque o valor de retorno da chamada a <function>print</function>
       é <literal>int(1)</literal>, e então ele se parecerá como
       o argumento numérico opcional mencionado acima.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    A instrução <literal>switch</literal> é similar a uma série de
    instruções IFs seguidas. Em muitas ocasiões, você poderá ter
    que comparar a mesma variável (ou expressão) com muitos
    valores diferentes, executando códigos diferentes dependendo
    com qual valor ele se encaixar. É exatamente para isso que a
    instrução <literal>switch</literal> faz.
   </simpara>
   <note>
    <simpara>
     Note que diferentemente de outras linguagens, a instrução
     <link linkend="control-structures.continue">continue</link>
     se aplica a switch e age similarmente a um <literal>break</literal>. Se você
     tem um switch dentro de um loop e deseja continuar para a próxima iteração do
     loop, use <literal>continue 2</literal>.
    </simpara>
   </note>
   <note>
    <para>
     Note que switch/case fazem
     <link linkend="types.comparisions-loose">comparações soltas</link>.
    </para>
   </note>
   <para>
    Os exemplos seguintes mostram duas maneiras diferentes de escrever a
    mesma coisa, uma utilizando uma série de <literal>if</literal>s e
    <literal>elseif</literal>s e a outra utlizando a instrução
    <literal>switch</literal>:
    <example>
     <title>Estrutura <literal>switch</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i igual a 0";
} elseif ($i == 1) {
    echo "i igual a 1";
} elseif ($i == 2) {
    echo "i igual a 2";
}

switch ($i) {
    case 0:
        echo "i igual a 0";
        break;
    case 1:
        echo "i igual a 1";
        break;
    case 2:
        echo "i igual a 2";
        break;
}
?>
]]>
     </programlisting>
   </example>
   <example>
    <title>A estrutura <literal>switch</literal> permite uso de strings</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case "apple":
        echo "i is apple";
        break;
    case "bar":
        echo "i is bar";
        break;
    case "cake":
        echo "i is cake";
        break;
    }
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    É importante entender como a instrução <literal>switch</literal>
    funciona para evitar enganos. A instrução
    <literal>switch</literal> executa linha a linha
    (atualmente, instrução a instrução). No início, nenhum código é
    executado. Somente quando uma instrução <literal>case</literal> é encontrada
    com um valor que combina com a expressão do
    <literal>switch</literal> faz com que o PHP execute as
    instruções a partir daí. O PHP continua executando as instruções até o fim
    do bloco <literal>switch</literal> ou na primeira vez que encontrar
    uma instrução <literal>break</literal>. Se você não escrever uma
    instrução <literal>break</literal> no fim das instruções
    <literal>case</literal>, o PHP continuará executando os
    <literal>case</literal>s seguintes. Exemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        echo "i igual a 0";
    case 1:
        echo "i igual a 1";
    case 2:
        echo "i igual a 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Aqui, se <varname>$i</varname> é igual a zero, o PHP executará todas as instruções
    echo! Se <varname>$i</varname> é igual a 1, o PHP executará os últimas duas
    instruções echo, e somente se <varname>$i</varname> for igual a 2, você terá o
    comportamento 'esperado' apenas onde 'i igual a 2' será mostrado. Então
    é importante não se esquecer das instruções <literal>break</literal>
    (e as vezes não colocá-las para obter esse resultado em
    certas circunstâncias).
   </simpara>
   <simpara>
    Em uma instrução <literal>switch</literal>, a condição
    somente será avaliada e resultado comparado para cada
    instrução <literal>case</literal>. Em uma instrução
    <literal>elseif</literal>, a condição é avaliada novamente. Se sua condição é
    mais complicada que um simples comparação e/ou e dentro de um loop,
    um <literal>switch</literal> é mais rápido.
   </simpara>
   <para>
    Um case pode não ter nenhuma instrução dentro, o que simplesmente
    passa o controle para o próximo case.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
    case 1:
    case 2:
        echo "i é menor que 3 mas não negativo";
        break;
    case 3:
        echo "i é 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Um case especial é o <literal>default</literal>. Esse case é executado quando
    nenhum outro case combina. Por exemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        echo "i igual a 0";
        break;
    case 1:
        echo "i igual a 1";
        break;
    case 2:
        echo "i igual a 2";
        break;
    default:
        echo "i não é igual a 0, 1 ou 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    A expressão avaliada pelo <literal>case</literal> precisa
    ser um tipo simples, ou seja, inteiros, números de ponto flutuante
    e strings. Arrays ou objetos não podem ser utilizados a não ser
    que eles impliquem num tipo simples.
   </para>
   <para>
    A sintaxe alternativa para estruturas de controle é suportada para os
    switches. Para maiores informações, veja <link
    linkend="control-structures.alternative-syntax">Sintaxe alternativa
    para estruturas de controle</link>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
    case 0:
        echo "i igual a 0";
        break;
    case 1:
        echo "i igual a 1";
        break;
    case 2:
        echo "i igual a 2";
        break;
    default:
        echo "i não é igual a 0, 1 ou 2";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    O construtor <literal>declare</literal> é utilizado para
    configurar diretivas de execução para blocos de código.
    A sintaxe do <literal>declare</literal> é similar
    a sintaxe de outros construtores de controle.
    <informalexample>
     <programlisting>
<![CDATA[
declare (diretiva)
  instrucao
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    A seção <literal>diretiva</literal> permite o
    comportamento do bloco <literal>declare</literal> a
    ser configurado.
    Atualmente somente uma diretiva é reconhecida: a
    diretiva <literal>ticks</literal>. (veja abaixo para maiores
    informações em
    <link linkend="control-structures.declare.ticks">diretiva
    ticks</link>)
   </para>
   <para>
    A parte <literal>instrucao</literal> do
    bloco <literal>declare</literal> será executada. Como
    ela é executada e que efeitos colaterais que podem ocorrem durante a execução
    dependem da configuração
    <literal>diretiva</literal>.
   </para>
   <para>
    O construtor <literal>declare</literal> também pode ser utilizado no escopo
    global, afetando todo o código que se seguir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// isso eh o mesmo:

// voce pode fazer isso:
declare(ticks=1) {
    // script inteiro aqui
}

// ou pode fazer isto:
declare(ticks=1);
// sctipt inteiro aqui
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>Um tick é um evento que ocorre para cada
    <varname>N</varname> níveis de instruções executados
    pelo interpretador com o bloco <literal>declare</literal>.
    O valor para <varname>N</varname> é especificado
    utilizando <code>ticks=<varname>N</varname></code>
    nos blocos <literal>declare</literal> das
    seções <literal>diretiva</literal>.
   </para>
   <para>
    O(s) evento(s) que ocorre(m) em cada tick são especificados utilizando
    <function>register_tick_function</function>. Veja o exemplo
    abaixo para maiores detalhes. Note que mais de um evento pode ocorrer
    em cada tick.
   </para>
   <para>
    <example>
     <title>Histórico de um trecho de código PHP</title>
     <programlisting role="php">
<![CDATA[
<?php
// Uma função que grava o tempo entre as chamadas
function profile ($dump = FALSE)
{
    static $profile;

    // Retorna os tempos preservados no histórico, então apaga
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return $temp;
    }

    $profile[] = microtime ();
}

// Ativa o manipulador do tick
register_tick_function("profile");

// Inicializa a função antes de declarar o bloco
profile();

// Roda um trecho de código, disparando um tick a cada duas instruções
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Mostra os dados guardados no histórico
print_r(profile (TRUE));
?>
]]>
     </programlisting>
    </example>
    No exemplo acima, o bloco 'declare'
    grava os tempos a cada segundo nível dentro das
    instruções no bloco enquanto executam. Esta informação pode
    ser utilizada para encontrar áreas lentas em segmentos
    particulares de código. Este processo pode ser realizado de outras
    formas, mas a utilização de ticks é mais conveniente e fácil de
    implementar.
   </para>
   <simpara>
    Ticks são idealizados para debug, implementação de multitask
    simples, processos de I/O em background e afins.
   </simpara>
   <simpara>
    Veja também: <function>register_tick_function</function> e
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
    Se chamada em uma função, a instrução <function>return</function>
    termina imediatamente a execução da função atual e retorna
    seu argumento como o valor da função.
    <function>return</function> também termina a execução de
    uma instrução <function>eval</function> ou de um script.
   </simpara>
   <simpara>
    Se chamada no escopo global, a execução do script
    atual será terminada. Se o arquivo do script atual foi
    incluído com <function>include</function> ou <function>require</function>,
    então a execução é devolvida para o arquivo chamador. Especificamente para
    arquivos de script incluídos com <function>include</function>, o
    valor fornecido para <function>return</function> será devolvido como
    o valor da chamada <function>include</function>. Se
    <function>return</function> for chamado do arquivo de script
    principal, então o programa pára. Se o arquivo de script atual é
    o configurado em <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> ou <link
    linkend="ini.auto-append-file">auto_append_file</link>
    do &php.ini;,
    então a execução desses scripts é finalizada.
   </simpara>
   <simpara>Para maiores informações, veja <link
   linkend="functions.returning-values">Retornando Valores</link>.
   </simpara>
   <para>
    <note>
     <simpara>
      Note que <function>return</function> é um construtor
      de linguagem e não uma função, e parênteses em volta do
      argumento não é requerido. è comum deixa-los, e você atualmente
      deve faze-lo, já que o PHP tem menos trabalho para fazer neste caso.
     </simpara>
    </note>

    <note>
     <simpara>
     Você <emphasis>jamais</emphasis> deve usar parênteses em torno da sua
     variável retornada ao retornar por referência, já que isto não irá funcionar. Você pode
     retornar apenas variáveis por referência, não o resultado de um comando. Se
     você usar <literal>return ($a);</literal> então você não esta retornando
     uma variável, mas o resultado da expressão <literal>($a)</literal>
     (o qual é, claro, o valor de <varname>$a</varname>).
     </simpara>
    </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><function>require</function></title>

   <simpara>
    A instrução <function>require</function> inclui e avalia
    um arquivo específico.
   </simpara>
   <simpara>
     Informações detalhadas de como essa inclusão funciona está descrita na
     documentação do <function>include</function>.
   </simpara>
   <simpara>
     <function>require</function> e <function>include</function>
     são idênticos em todas as formas exceto pela manipulação de erros.
     Ambas produzem um <link linkend="errorfunc.constants.errorlevels.e-warning">Warning</link>, mas
     <function>require</function> resultará em um  <link linkend="errorfunc.constants.errorlevels.e-error">
     Fatal Error</link>. Em outras palavras, não hesite em utilizar
     <function>require</function> se na falta de um arquivo quiser parar o processamento
     da página. <function>include</function> não se comporta da mesma maneira, e o
     script poderá continuar nessa situação. Em todo caso, vale a pena confirmar a configuração da diretiva
     <link linkend="ini.include-path">include_path</link>.
   </simpara>
   <para>
    <example>
     <title>Exemplos simples de <function>require</function>s</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Veja a documentação de <function>include</function> para mais exemplos.
   </simpara>
   <para>
    <note>
     <simpara>
      Até o PHP 4.0.2, havia o seguinte comportamento: <function>require</function>
      sempre tentará ler o arquivo informado, mesmo que que a linha do require
      nunca seja executada. É por isso que instruções condicionais não afetam
      <function>require</function>. Entretanto, se a linha onde ocorre o
      <function>require</function> não for executada, nada
      do código incluído do arquivo também será. Similarmente, estruturas de
      loop não afetam o funcionamento do <function>require</function>. Mas
      o código incluído pela função será submetida ao loop. A instrução
      <function>require</function> apenas ocorre uma vez.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
    Veja também: <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>get_included_files</function>,
    <function>eval</function>, <function>file</function>, <function>readfile</function>,
    <function>virtual</function> e <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><function>include</function></title>
   <simpara>
    A instrução <function>include</function> inclui e avalia o
    arquivo informado.
   </simpara>
   <simpara>
     A documentação a seguir se aplica também a <function>require</function>.
     Esses dois construtores são idênticos a exceção de como eles manipulam
     erros. Ambas produzem um <link linkend="errorfunc.constants.errorlevels.e-warning">Warning</link> mas <function>require</function>
     resultará em um <link linkend="errorfunc.constants.errorlevels.e-error">Fatal Error</link>.
     Em outras palavras, utilize <function>require</function> se você deseja
     que um arquivo faltando interrompa o processamento da página. <function>include</function>
     não se comporta da mesma maneira, permitindo que o script continue nessas situações. Em todo caso,
     vale a pena confirmar a configuração da diretiva <link linkend="ini.include-path">include_path</link>.
     Esteja avisado que um erro de interpretação no arquivo incluído não causa a parada do
     processamento em versões do PHP anteriores a PHP 4.3.5. A partir desta versão, causa.
   </simpara>
   <simpara>
    Arquivos a incluir são procurados primeiramente no include_path relativo ao diretório atual de trabalho,
    e então no diretório atual do script. Por exemplo, se seu include_path
    é <literal>libraries</literal>, o diretório atual é <filename class="directory">/www/</filename>,
    se você incluiu <filename>include/a.php</filename> e há um <filename>b.php</filename>
    nesse arquivo, <filename>b.php</filename> será procurado primeiro em <filename class="directory">/www/libraries/</filename>
    e somente depois em <filename class="directory">/www/include/</filename>.0
    Se o nome do arquivo começa com <literal>./</literal> ou <literal>../</literal>, ele
    é procurado apenas no diretório atual.
   </simpara>
   <simpara>
     Quando um arquivo é incluído, seu código entra no
     <link linkend="language.variables.scope">escopo de variável</link> da
     linha onde a inclusão ocorre. Qualquer variável disponível da linha onde
     a chamada da inclusão ocorre estará disponível para o arquivo incluído, daquele
     ponto em diante.
     Entretanto, todas as funções e classes definidas no arquivo incluído
     tem um escopo global.
   </simpara>
   <para>
     <example>
      <title>Exemplos de <function>include</function>s simples</title>
      <programlisting role="php">
<![CDATA[
variaveis.php
<?php

$cor = 'verde';
$fruta = 'maçã';

?>

teste.php
<?php

echo "Uma $fruta $cor"; // Uma

include 'vars.php';

echo "Uma $fruta $cor"; // Uma maçã verde

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     Se o include ocorre dentro de uma função do arquivo principal,
     então todo o código incluído será executado como
     se ele tivesse sido definido dentro daquela função. Da mesma forma,
     ele seguirá o escopo de variáveis da função.
     Uma exceção para esta regra são as <link
     linkend="language.constants.predefined">constantes mágicas</link> que são
     avaliadas pelo parser antes dos includes ocorrerem.
   </simpara>
   <para>
     <example>
     <title>Incluindo dentro de funções</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $cor;

    include 'variaveis.php';

    echo "Uma $fruta $cor";
}

/* variaveis.php está no escopo de foo(),   *
.* então $fruta NÃO está disponível fora de *
.* seu escopo. $cor estará porque ela foi   *
.* declarada como global                    */

foo();                    // Uma maçã verde
echo "A $fruta $cor";   // Uma maçã

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Quando um arquivo é incluído, o interpretador sai do modo PHP e
     entra no modo HTML (no começo do arquivo incluído), e alterna
     novamente no seu fim. Por isso, qualquer código dentro do arquivo
     incluído que precisa ser executado como código PHP tem de ser delimitado por
     <link linkend="language.basic-syntax.phpmode">tags válidas
     de abertura e fechamento</link>.
   </simpara>
   <simpara>
     Se "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     estão ativas no PHP (normalmente na configuração default),
     você pode especificar um arquivo utilizando uma URL (via HTTP ou
     qualquer outro wrapper suportado --- veja <xref linkend="wrappers"/> para uma lista
     dos protocolos) em vez de uma caminho local. Se o servidor apontado interpreta
     o arquivo informado como código PHP, variáveis podem ser passadas ao arquivo
     incluído na URL de requisição como num HTTP GET. Isto não
     é necessariamente a mesma coisa que incluir o arquivo e
     compartilhar o escopo de variável do arquivo principal: o script
     será executado no servidor remoto e apenas seu resultado será
     incluído no script local.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> através de HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Este exemplo assume que www.exemplo.com está configurado para interpretar
 * arquivos .php mas não .txt. Além, 'Funciona' aqui significa que as
 * variáveis $foo e $bar estão disponíveis no arquivo incluído */

// Não funciona: arquivos txt não são manipulados em www.example.com como PHP
include 'http://www.exemplo.com/arquivo.txt?foo=1&bar=2';

// Não funciona: procura por um arquivo chamado 'arquivo.php?foo=1&bar=2' no
// sistemas de arquivo local.
include 'arquivo.php?foo=1&bar=2';

// Funciona.
include 'http://www.exemplo.com/arquivo.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'arquivo.txt';  // Funciona.
include 'arquivo.php';  // Funciona.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Security warning</title>
     <para>
      O arquivo remoto pode ser processado pelo servidor remoto (dependendo da extensão do arquivo
      e do fato de o servidor remoto executar o PHP ou não) mas ainda tem
      que produzir um script PHP válido porque ele será processado
      pelo servidor local. Se o arquivo do servidor remoto deve ser processado
      lá e apenas exibido, a função, <function>readfile</function> é
      muito melhor para ser usada. Entretanto, um cuidado especial deve ser tomado para se assegurar
      que o script remoto irá produzir um código válido e desejado.
     </para>
    </warning>
    <para>
     Veja também: <link linkend="features.remote-files">Arquivos Remotos</link>,
     <function>fopen</function> e <function>file</function> para informações
     relacionadas.
   </para>
   <simpara>
    Manipulando retornos: é possível executar um comando <function>return</function>
    dentro de um arquivo incluído para terminar o processamento naquele arquivo
    e retornar para o script que o chamou. Também é possível retornar
    valores dos arquivos incluídos. Você pode usar o valoe de uma chamada include como
    você faria com uma função normal. isto não é, entretanto, possível ao incluir
    arquivos remotos a menos que a saída do arquivo remoto tenha
    <link linkend="language.basic-syntax.phpmode">tags de início e
    final do PHP válidas</link> (como qualquer arquivo local).  Você pode declarar as
    variáveis necessárias dentro destas tags e elas serão introduzidas em qualquer ponto
    que o arquivo seja incluído.
   </simpara>
   <para>
    Devido a <function>include</function> ser um construtor especial da linguagem,
    parentesis não são necessários ao redor do seu argumento. Tenha cuidado ao
    comparar o valor de retorno.
   </para>
   <para>
    <example>
     <title>Comparando o valor de retorno de include</title>
     <programlisting role="php">
<![CDATA[
<?php
// não funciona, avaliado como(('vars.php') == 'OK'), ex, include('')
if (include('vars.php') == 'OK') {
   echo 'OK';
}
// funciona
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
      No PHP 3, o return não pode aparecer dento de um bloco a não ser que ele
      seja um bloco de função, e nesse caso <function>return</function> se aplica
      apenas para a função e não para todo o arquivo.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title>Instruções <function>include</function> e <function>return</function></title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // imprime 'PHP'

$bar = include 'noreturn.php';

echo $bar; // imprime 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> assimila o valor <literal>1</literal> porque a inclusão
    foi realizada com sucesso. Verifique a diferença entre os exemplo. O primeiro utiliza
    <function>return</function> dentro do arquivo incluído enquanto que o outro não.
    If the file can't be included, &false; is returned and
    <literal>E_WARNING</literal> is issued.
   </simpara>
   <para>
    Se houverem funções definidas no arquivo incluído, elas podem sr usadas no
    arquivo principal independentemente se elas foram antes de <function>return</function> ou depois.
    Se o arquivo for incluído duas vezes, o PHP 5 causa um erro fatal por as funções
    já foram declaradas, em quanto o PHP 4 não reclama sobre funções
    definidas após <function>return</function>.
    è remendado usar <function>include_once</function> ao invés de
    conferir se o arquivo já foi incluído e condicionalmente retornar dentro
    do arquivo incluído.
   </para>
   <simpara>
    Outra maneira de "incluir" um arquivo PHP em uma variável e capturar a
    saída usando <link linkend="ref.outcontrol">Funções de Controle
    de Saída</link> com <function>include</function>. Por exemplo:
   </simpara>
   <para>
    <example>
     <title>Usando o buffer de saída para incluir um arquivo PHP em uma string</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}
?>
]]>
      </programlisting>
      </example>
     </para>
   <para>
    Para poder incluir automaticamente arquivos em um script, veja também
    as opções de configuração <link linkend="ini.auto-prepend-file">auto_prepend_file</link> e
    <link linkend="ini.auto-append-file">auto_append_file</link>
    no &php.ini;.
   </para>

   &note.language-construct;

   <simpara>
    Veja também: <function>require</function>, <function>require_once</function>,
    <function>include_once</function>,  <function>get_included_files</function>,
    <function>readfile</function>, <function>virtual</function> e
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 xml:id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    A instrução <function>require_once</function> incluí e avalia
    o arquivo especificado durante a execução do script.
    Seu comportamento é similar ao da instrução <function>require</function>,
    a não ser que o arquivo informado já tenha sido
    incluído, não refazendo a operação novamente. Veja a documentação de
    <function>require</function> para maiores informações sobre como essa instrução
    funciona.
   </para>
   <para>
    <function>require_once</function> pode ser utilizado nos casos em
    que o mesmo arquivo pode acabar sendo incluído mais de uma vez durante a
    execução de um script em particular, quando na verdade ele só pode ser
    incluído apenas uma, para evitar problemas com redefinições de funções,
    alterações nos valores de variáveis, etc.
   </para>
   <para>
     Para exemplos de utilização de <function>require_once</function> e
     <function>include_once</function>, veja o código do
     <link xlink:href="&url.php.pear;">PEAR</link> incluído nas
     últimas distribuições do código fonte do PHP.
   </para>
   <para>
    Os valores de retorno são os mesmos que <function>include</function>. Se o arquivo
    já tiver sido incluído, esta função retorna &true;
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> foi acrescentado a partir PHP 4.0.1
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Esteja avisado que o comportamento de <function>require_once</function>
      e <function>include_once</function> pode não ser o que você espera
      em um sistema operacional insensitivo ao caso (como o Windows).
      <example>
       <title><function>require_once</function> não diferencia maiúsculas e minúsculas no Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once "a.php"; // isto irá incluir a.php
require_once "A.php"; // isto irá incluir a.php novamente no Windows! (Apenas PHP 4)
?>
]]>
        </programlisting>
      </example>
       Este funcionamento mudou no  PHP 5 - o caminho é normalizado primeiro, assim
       <filename>C:\PROGRA~1\A.php</filename> é realizado como o mesmo que
       <filename>C:\Program Files\a.php</filename> e o arquivo é requerido apenas uma vez.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Veja também <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    e <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    A instrução <function>include_once</function> inclui e avalia
    o arquivo especificado durante a execução de um script.
    Seu comportamento é similar a instrução <function>include</function>,
    a não ser que o arquivo informado já tenha sido
    incluído, não refazendo a operação novamente. Como o nome sugere,
    ele será incluído apenas uma vez.
   </para>
   <para>
    <function>include_once</function> pode ser utilizado nos casos em
    que o mesmo arquivo pode acabar sendo incluído mais de uma vez durante a
    execução de um script em particular, quando na verdade ele só pode ser
    incluído apenas uma para evitar problemas com redefinições de funções,
    alterações nos valores de variáveis, etc.
   </para>
   <para>
    Para maiores informações utilizando <function>require_once</function> e
    <function>include_once</function>, veja o código do
    <link xlink:href="&url.php.pear;">PEAR</link> incluído nas
    últimas distribuições do código fonte do PHP.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> foi acrescentado a partir PHP 4.0.1
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Esteja avisado que o comportamento de <function>include_once</function>
      e <function>require_once</function> pode não ser o que você espera
      em um sistema operacional insensitivo ao caso (como o Windows).
      <example>
       <title><function>include_once</function> não diferencia maiúsculas e minuúsculas no Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once "a.php"; // isto irá incluir a.php
include_once "A.php"; // isto irá incluir a.php novamente no Windows! (Apenas PHP 4)
?>
]]>
       </programlisting>
      </example>
       Este funcionamento mudou no  PHP 5 - o caminho é normalizado primeiro, assim
       <filename>C:\PROGRA~1\A.php</filename> é realizado como o mesmo que
       <filename>C:\Program Files\a.php</filename> e o arquivo é incluído apenas uma vez.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Veja também: <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    e <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
