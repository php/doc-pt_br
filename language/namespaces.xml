<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1431d18dc4ee8056f2958d2b6af559c9e5478f61 Maintainer: ae Status: ready --><!-- CREDITS: dcbmariano,lhsazevedo,ae,nawarian -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
 version="1.1">
 <title>Namespaces</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>Visão geral de Namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <simpara>
   O que são namespaces? Na definição mais ampla, os namespaces (na tradução literal, "espaços de nomes") são uma forma de encapsular
   itens. Isso pode ser visto com um conceito abstrato em muitos lugares. Por exemplo, em qualquer
   sistema operacional os diretórios servem para agrupar arquivos relacionados, e agem como um namespace para
   os arquivos dentro dele. Como um exemplo concreto, o arquivo <literal>foo.txt</literal> pode
   existir em ambos os diretórios <literal>/home/greg</literal> e <literal>/home/other</literal>,
   mas duas cópias de <literal>foo.txt</literal> não podem coexistir em um mesmo diretório. Além
   disso, para acessar o arquivo <literal>foo.txt</literal> fora do
   diretório <literal>/home/greg</literal>, devemos informar o nome do diretório antes do nome
   do arquivo usando o separador de diretórios para obter <literal>/home/greg/foo.txt</literal>. Esse
   mesmo princípio se estende a namespaces no mundo da programação.
  </simpara>

  <simpara>
   No mundo PHP, os namespaces são projetados para resolver dois problemas que os autores
   de bibliotecas e aplicativos encontram ao criar elementos de código reutilizáveis,
   como classes ou funções:
  </simpara>
  <para>
   <orderedlist>
    <listitem>
     <simpara>
      Nomear as colisões entre o código que você cria e
      classes/funções/constantes internas do PHP ou classes/funções/constantes de terceiros.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Capacidade de criar apelidos (ou encurtar) Nomes_Extra_Longos projetados para aliviar o primeiro problema,
      melhorando a legibilidade do código-fonte.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <simpara>
   Os Namespaces do PHP fornecem uma maneira de agrupar classes, interfaces,
   funções e constantes relacionadas. Aqui está um exemplo da sintaxe de namespace em PHP:
  </simpara>
  <example>
   <title>Exemplo da sintaxe de namespace</title>
   <programlisting role="php">
   <![CDATA[
<?php
namespace meu\nome; // veja a seção "Definindo Namespaces"

class MinhaClasse {}
function minhafuncao() {}
const MINHACONST = 1;

$a = new MinhaClasse;
$c = new \meu\nome\MinhaClasse; // veja a seção "Espaço Global"

$a = strlen('oi'); // veja a seção "Usando namespaces: fallback para
                   // função/constante global"

$d = namespace\MINHACONST; // veja a seção "operador de namespace
                        // e constante __NAMESPACE__"
$d = __NAMESPACE__ . '\MINHACONST';
echo constant($d); // veja a seção "Namespaces e funcionalidades dinâmicas da linguagem" section
?>
    ]]>
   </programlisting>
  </example>
   <note>
    <simpara>
     Os nomes de namespace não diferenciam maiúsculas de minúsculas.
    </simpara>
   </note>
  <note>
   <para>
    O nome de Namespace <literal>PHP</literal> e nomes compostos que começam
    com esse nome (como <literal>PHP\Classes</literal>) são reservados para uso interno da linguagem
    e não devem ser usados no código de espaço de usuário.
   </para>
  </note>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>Definindo namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Embora qualquer código PHP válido possa estar contido em um namespace, apenas os seguintes
   tipos de código são afetados por namespaces: classes (incluindo abstratas e traits), interfaces, funções e constantes.
  </para>
  <para>
   Namespaces são declarados usando a palavra-chave <literal>namespace</literal>.
   Um arquivo contendo um namespace deve declarar o namespace
   na parte superior do arquivo antes de qualquer outro código - com uma exceção: a
   palavra-chave <xref linkend="control-structures.declare" />.
   <example>
    <title>Declarando um único namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */ }

?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Nomes totalmente qualificados (ou seja, nomes que começam com uma barra invertida) não são permitidos em declarações
     de namespace, porque esses construtos são interpretadas como expressões de namespace relativos.
    </simpara>
   </note>
   O único construto de código permitido antes de uma declaração de namespace é a
   declaração <literal>declare</literal>, para definir a codificação de um arquivo fonte. Além disso,
   nenhum código não-PHP pode preceder uma declaração de namespace, incluindo espaço em branco extra:
   <example>
    <title>Declarando um único namespace</title>
    <programlisting role="php">
     <![CDATA[
<html>
<?php
namespace MeuProjeto; // fatal error - namespace must be the first statement in the script
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Além disso, diferente de qualquer outro construto do PHP, o mesmo namespace pode ser definido
   em vários arquivos, permitindo a divisão do conteúdo de um namespace no sistema de arquivos.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nested">
  <title>Declarando sub namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Assim como diretórios e arquivos, os namespaces do PHP são capazes de especificar
   uma hierarquia de namespaces. Assim, um namespace pode ser definido com
   subníveis.
   <example>
    <title>Declarando um namespace com hierarquia</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto\Nivel\SubNivel;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   O exemplo acima cria a constante <literal>MeuProjeto\Nivel\SubNivel\CONEXAO_OK</literal>,
   a classe <literal>MeuProjeto\Nivel\SubNivel\Conexao</literal> e a função
   <literal>MeuProjeto\Nivel\SubNivel\conectar</literal>.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.definitionmultiple">
  <title>Definindo múltiplos namespaces no mesmo arquivo</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Múltiplos namespaces também podem ser declarados no mesmo arquivo. Existem duas sintaxes
   permitidas.
  </para>
  <para>
   <example>
    <title>Declarando múltiplos namespaces, sintaxe de combinação simples</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }

namespace OutroProjeto;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Essa sintaxe não é recomendada para combinar namespaces em um único arquivo.
   Em vez disso, é recomendado usar a sintaxe de colchetes como alternativa.
  </para>
  <para>
   <example>
    <title>Declarando múltiplos namespaces, sintaxe de colchetes</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}

namespace OutroProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   É fortemente desencorajado como prática de programação combinar vários namespaces no
   mesmo arquivo. O caso de uso principal é combinar múltiplos scripts PHP no mesmo
   arquivo.
  </para>
  <para>
   Para combinar código global sem namespace e código com namespace, apenas a sintaxe de colchetes é
   suportada. Código global deve ser
   envolto em uma declaração de namespace sem nome de namespace, como em:
   <example>
    <title>Declarando múltiplos namespaces e código sem namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}

namespace { // código global
session_start();
$a = MeuProjeto\conectar();
echo MeuProjeto\Conexao::iniciar();
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Nenhum código PHP pode existir fora dos colchetes de namespace, exceto uma declaração
   declare de abertura.
   <example>
    <title>Declarando múltiplos namespaces e código sem namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
declare(encoding='UTF-8');
namespace MeuProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}

namespace { // código global
session_start();
$a = MeuProjeto\conectar();
echo MeuProjeto\Conexao::iniciar();
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.basics">
  <title>Usando namespaces: Fundamentos</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Antes de discutir o uso de namespaces, é importante entender como o PHP
   sabe qual elemento de namespace o seu código está solicitando. Uma analogia simples pode ser feita
   entre os namespaces do PHP e um sistema de arquivos. Existem três maneiras de acessar um arquivo em um
   sistema de arquivos:
   <orderedlist>
    <listitem>
     <simpara>
      Nome de arquivo relativo como <literal>foo.txt</literal>. É resolvido para
      <literal>diretorioatual/foo.txt</literal> onde diretorioatual é o
      diretório ocupado atualmente. Então, se o diretório atual for
      <literal>/home/foo</literal>, o nome resolve para <literal>/home/foo/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome de caminho relativo como <literal>subdiretorio/foo.txt</literal>. É resolvido
      para <literal>diretorioatual/subdiretorio/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome de caminho absoluto como <literal>/main/foo.txt</literal>. É resolvido
      para <literal>/main/foo.txt</literal>.
     </simpara>
    </listitem>
   </orderedlist>
   O mesmo princípio pode ser aplicado para elementos com namespace no PHP. Por
   exemplo, um nome de classe pode ser referenciado em três maneiras:
   <orderedlist>
    <listitem>
     <simpara>
      Nome não qualificado, ou nome de classe sem prefixo como
      <literal>$a = new foo();</literal> ou
      <literal>foo::metodoestatico();</literal>. Se o namespace atual for
      <literal>namespaceatual</literal>, ele é resolvido para
      <literal>namespaceatual\foo</literal>. Se
      o código for global, sem namespace, ele é resolvido para <literal>foo</literal>.
     </simpara>
     <simpara>
      Uma ressalva: nomes não qualificados para funções e constantes
      resolverão para funções e constantes globais se a função ou constante com namespace
      não estiver definida. Veja <link linkend="language.namespaces.fallback">Usando namespaces:
      fallback para função/constante global</link> para detalhes.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome qualificado, ou nome de classe prefixado como
      <literal>$a = new subnamespace\foo();</literal> ou
      <literal>subnamespace\foo::metodoestatico();</literal>. Se o namespace atual for
      <literal>namespaceatual</literal>, ele resolve para
      <literal>namespaceatual\subnamespace\foo</literal>.  Se
      o código for global, sem namespace, ele resolve para <literal>subnamespace\foo</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome totalmente qualificado, ou nome prefixado com um operador de prefixo global como
      <literal>$a = new \namespaceatual\foo();</literal> ou
      <literal>\namespaceatual\foo::metodoestatico();</literal>. Ele sempre resolve
      para o nome literal especificado no código, <literal>namespaceatual\foo</literal>.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Aqui está um exemplo dos três tipos de sintaxe em código real:
   <informalexample>
    <simpara>arquivo1.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo\Bar\subnamespace;

const FOO = 1;
function foo() {}
class foo
{
    static function metodoestatico() {}
}
?>
     ]]>
    </programlisting>
    <simpara>arquivo2.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo\Bar;
include 'arquivo1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function metodoestatico() {}
}

/* Nome não qualificado */
foo(); // resolve para a função Foo\Bar\foo
foo::metodoestatico(); // resolve para a classe Foo\Bar\foo, método metodoestatico
echo FOO; // resolve para a constante Foo\Bar\FOO

/* Nome qualificado */
subnamespace\foo(); // resolve para a função Foo\Bar\subnamespace\foo
subnamespace\foo::metodoestatico(); // resolve para a classe Foo\Bar\subnamespace\foo,
                                  // método metodoestatico
echo subnamespace\FOO; // resolve para a constante constant Foo\Bar\subnamespace\FOO

/* Nome totalmente qualificado */
\Foo\Bar\foo(); // resolve para a função Foo\Bar\foo
\Foo\Bar\foo::metodoestatico(); // resolve para a classe Foo\Bar\foo, método metodoestatico
echo \Foo\Bar\FOO; // resolve para a constante Foo\Bar\FOO
?>
     ]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Note que para acessar qualquer classe,
   função ou constante global, um nome totalmente qualificado pode ser usado, como
   <function>\strlen</function> ou <classname>\Exception</classname> ou
   <literal>\INI_ALL</literal>.
   <example>
    <title>Acessando classes, funções e constantes globais de dentro de um namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('oi'); // chama a função global strlen
$b = \INI_ALL; // acessa a constante global INI_ALL
$c = new \Exception('erro'); // instancia a classe global Exception
?>
     ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.dynamic">
  <title>Namespaces e funcionalidades de linguagem dinâmica</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   A implementação de namespaces do PHP é influenciada por sua natureza dinâmica como uma linguagem
   de programação. Portanto, para converter código como o seguinte para código com namespace:
   <example>
    <title>Acessando elementos dinamicamente</title>
    <simpara>exemplo1.php:</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
class namedaclasse
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function nomedafuncao()
{
    echo __FUNCTION__,"\n";
}
const nomedaconstante = "global";

$a = 'namedaclasse';
$obj = new $a; // imprime namedaclasse::__construct
$b = 'nomedafuncao';
$b(); // imprime nomedafuncao
echo constant('nomedaconstante'), "\n"; // imprime global
?>
    ]]>
    </programlisting>
   </example>
   Deve-se usar o nome totalmente qualificado (nome de classe prefixado com namespace).
   Observe que, como não há diferença entre um nome qualificado e um totalmente qualificado
   dentro de um nome de classe, nome de função ou nome de constante dinâmico, a barra invertida inicial não
   é necessária.
   <example>
    <title>Acessando dinamicamente elementos com namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace nomedonamespace;
class nomedaclasse
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function nomedafuncao()
{
    echo __FUNCTION__,"\n";
}
const nomedaconstante = "comnamespace";

/* Observe que, ao usar aspas duplas, "\\nomedonamespace\\nomedaclasse" deve ser usado */
$a = '\nomedonamespace\nomedaclasse';
$obj = new $a; // imprime nomedonamespace\nomedaclasse::__construct
$a = 'nomedonamespace\nomedaclasse';
$obj = new $a; // também imprime nomedonamespace\nomedaclasse::__construct
$b = 'nomedonamespace\nomedafuncao';
$b(); // imprime nomedonamespace\nomedafuncao
$b = '\nomedonamespace\nomedafuncao';
$b(); // também imprime nomedonamespace\nomedafuncao
echo constant('\nomedonamespace\nomedaconstante'), "\n"; // imprime comnamespace
echo constant('nomedonamespace\nomedaconstante'), "\n"; // também imprime comnamespace
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   Certifique-se de ler a <link linkend="language.namespaces.faq.quote">nota sobre
   escapamento de namespaces em strings</link>.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nsconstants">
  <title>Palavra-chave namespace e constante __NAMESPACE__</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   O PHP suporta duas maneiras de acessar elementos de forma abstrata dentro do namespace atual,
   a constante mágica <constant>__NAMESPACE__</constant>, e a palavra-chave
   <literal>namespace</literal>.
  </para>
  <para>
   O valor de <constant>__NAMESPACE__</constant> é uma string que contém o nome do namespace
   atual. Em código global, sem namespace, ela contém uma string vazia.
   <example>
    <title>Exemplo da __NAMESPACE__, código com namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

echo '"', __NAMESPACE__, '"'; // produz "MeuProjeto"
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Exemplo da __NAMESPACE__, código global</title>
    <programlisting role="php">
     <![CDATA[
<?php

echo '"', __NAMESPACE__, '"'; // produz ""
?>
]]>
    </programlisting>
   </example>
   A constante <constant>__NAMESPACE__</constant> é útil para construir nomes de forma
   dinâmica, por exemplo:
   <example>
    <title>Usando __NAMESPACE__ para construção dinâmica de nomes</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

function get($nomedaclasse)
{
    $a = __NAMESPACE__ . '\\' . $nomedaclasse;
    return new $a;
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   A palavra-chave <literal>namespace</literal> pode ser usada para solicitar explicitamente
   um elemento do namespace atual ou um sub-namespace. Ela é o equivalente
   para os namespaces do operador <literal>self</literal> para classes.
   <example>
    <title>O operador namespace, dentro de um namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

use bla\bla as meu; // Veja "Usando namespaces: Apelidando/Importando"

bla\meu(); // chama a função MeuProjeto\bla\meu()
namespace\bla\meu(); // chama a função MeuProjeto\bla\meu()

namespace\func(); // chama a função MeuProjeto\func()
namespace\sub\func(); // chama a função MeuProjeto\sub\func()
namespace\cname::metodo(); // chama o método estático "metodo" da classe MeuProjeto\cname
$a = new namespace\sub\cname(); // instancia um objeto da classe MeuProjeto\sub\cname
$b = namespace\CONSTANTE; // atribui o valor da constante MeuProjeto\CONSTANTE à $b
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>O operador namespace, em código global</title>
    <programlisting role="php">
     <![CDATA[
<?php

namespace\func(); // chama a função func()
namespace\sub\func(); // chama a função sub\func()
namespace\cname::metodo(); // chama o método estático "metodo" da classe cname
$a = new namespace\sub\cname(); // instancia um objeto da classe sub\cname
$b = namespace\CONSTANTE; // atribui o valor da constante CONSTANTE à $b
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.importing">
  <title>Usando namespaces: Apelidando/Importando</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   A possibilidade de referir a um nome qualificado com um apelido, ou importação,
   é uma característica importante de namespaces. Isto é similar à
   habilidade de sistemas Unix de criar nomes simbólicos para um arquivo ou diretório.
  </para>
  <para>
   O PHP pode apelidar ou importar constantes, funções, classes, interfaces, traits, enums e namespaces.
  </para>
  <para>
   Apelidar é realizad com o operador <literal>use</literal>.
   A seguir exemploes mostrantos todos os tipos de importação:
   <example>
    <title>Importanto ou apelidando com o operador use</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace foo;
use Caminho\Completo\Classe as Outra;

// Isto é o mesmo que use Caminho\Completo\NomeNS as NomeNS
use Caminho\Completo\NomeNS;

// Importanto uma classe global
use ArrayObject;

// Importanto a função
use function Caminho\Completo\nomeFuncao;

// Apelidando uma função
use function Caminho\Completo\nomeFuncao as funcao;

// Importanto uma constante
use const Caminho\Completo\CONSTANTE;

$obj = new foo\Outra; // Instancia um objeto da classe foo\Outra
$obj = new Outra;     // Instancia um objeto da classe Caminho\Completo\Classe
NomeNS\SubNS\func();  // Chama uma função de Caminho\Completo\NomeNS\SubNS\func
$a = new ArrayObject(array(1)); // Instancia um objeto da classe ArrayObject
// Sem o "use ArrayObject" teria sido instanciado um objeto da classe foo\ArrayObject
nomeFuncao();   // chama a função Caminho\Completo\nomeFuncao
echo CONSTANTE; // imprime Caminho\Completo\CONSTANTE
?>
]]>
    </programlisting>
   </example>
   Observe que nomes de namespaces (nomes totalmente qualificados contendo
   o separador de namespace, como <literal>Foo\Bar</literal>, em oposição a nomes gloabais sem
   separadores, como <literal>FooBar</literal>), a contrabarra final não é necessária e não
   é recomendada, porque importação de nomes precisam
   ser totalmente qualificados, e não são processados relativos ao namespace corrente.
  </para>
  <para>
   O PHP também permite informar várias instruções use
   na mesma linha
   <example>
    <title>Importando ou apelidando várias nomes com operador use</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Caminho\Completo\Calsse as Outra, Caminho\Completo\NomeNS;

$obj = new Outra;    // Instancia um objeto da classe Caminho\Completo\Classe
NomeNS\SubNS\func(); // Chama a função Caminho\Completo\NomeNS\SubNS\func
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Importação é realizada em tempo de compilação, e portanto não é modificada por classes, funções
   ou nomes de constantes gerados dinâmicamente.
   <example>
    <title>Importação e nomes dinâmicos</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Caminho\Completo\Calsse as outra, Caminho\Completo\NomeNS;

$obj = new Outra; // Instancia objeto da classe Caminho\Completo\Classe
$a = 'Outra';
$obj = new $a;    // Instancia objeto da classe Outra
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Importação afeta apenas nomes parcialmente qualificados ou sem qualificação. Nomes completamente
   qualificados são absolutos, não afetados por importações.
   <example>
    <title>Importação e nomes completamente qualificados</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Caminho\Completo\Classe as Outra, Caminho\Completo\NomeNS;

$obj = new Outra;          // Instancia objeto da classe Caminho\Completo\Classe
$obj = new \Another;       // Instancia onjeto da classe Outra
$obj = new Outra\Coisa;    // Instancia objeto da classe Caminho\Completo\Classe\Coisa
$obj = new \Outra\Coisa;   // Instancia objeto da classe Outra\Coisa
?>
]]>
    </programlisting>
   </example>
  </para>
  <sect2 xml:id="language.namespaces.importing.scope">
   <title>Regras de escopo na impotação de namespaces</title>
   <para>
    A instrução <literal>use</literal> precisa ser declarada no
    escopo mais externo do arquivo (no escopo global) ou dentro de declarações
    de namespaces. Isso decorre da importação ser realizada em tempo
    compilação, de forma que não pode ocorrer em escopo de bloco. O exemplo
    seguinte mostra um uso inválido da instrução
    <literal>use</literal>:
   </para>
   <para>
    <example>
     <title>Importação inválida</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace Linguas;

function toGreenlandic()
{
    use Linguas\Dinamarques;

    // ...
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Regras de importação são limitadas a arquivos, significando que arquivos incluídos
     <emphasis>NÃO</emphasis> herdam as regras de importação do arquivo que incli o arquivo importado.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="language.namespaces.importing.group">
   <title>Declarações <literal>use</literal> em grupo</title>
   <para>
    Classes, funcções e constantes importados de
    um mesmo &namespace; pode ser agrupados numa única instrução
    &use.namespace;.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

use algum\namespace\ClasseA;
use algum\namespace\ClasseB;
use algum\namespace\ClasseC as C;

use function algum\namespace\fn_a;
use function algum\namespace\fn_b;
use function algum\namespace\fn_c;

use const algum\namespace\ConstA;
use const algum\namespace\ConstB;
use const algum\namespace\ConstC;

// É equivalente a seguinte declaração agrupada
use algum\namespace\{ClasseA, ClasseB, ClasseC as C};
use function algum\namespace\{fn_a, fn_b, fn_c};
use const algum\namespace\{ConstA, ConstB, ConstC};
]]>
    </programlisting>
   </informalexample>
  </sect2>
 </sect1>
 <sect1 xml:id="language.namespaces.global">
  <title>Espaço global</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Quando um namespace não é definido, todas as definições de classes e funções são
   colocadas no espaço global, como era no PHP antes dos namespaces serem
   suportados. Prefixar um nome com <literal>\</literal> especificará que
   o nome é requerido do espaço global mesmo no contexto do
   namespace.
   <example>
    <title>Usando especificação de espaço global</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

/* Esta função é A\B\C\fopen */
function fopen() {
     /* ... */
     $f = \fopen(...); // chama a fopen global
     return $f;
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.fallback">
  <title>Usando namespaces: fallback para função/constante global</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Dentro de um namespace, quando o PHP encontra um nome não qualificado em um nome de classe, função ou
   contexto constante, ele resolve com diferentes prioridades. Nomes de classe sempre
   são resolvidos para o nome do namespace atual. Assim para o acessar classes de usuário internas
   ou sem namespace, deve-se referir a elas como nome totalmente qualificado como em:
   <example>
    <title>Acessando classes globais dentro de um namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('oi'); // $a é um objeto da classe A\B\C\Exception
$b = new \Exception('oi'); // $b é um objeto da classe Exception

$c = new ArrayObject; // erro fatal, classe A\B\C\ArrayObject não encontrada
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   Para funções e constantes, o PHP retornará para funções ou constantes globais
   se a função ou constante com namespace não existir.
   <example>
    <title>Fallback de funções/constantes globais dentro de um namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

const E_ERROR = 45;
function strlen($str)
{
    return \strlen($str) - 1;
}

echo E_ERROR, "\n"; // imprime "45"
echo INI_ALL, "\n"; // imprime "7" - fallback para INI_ALL global

echo strlen('oi'), "\n"; // imprime "1"
if (is_array('oi')) { // imprime "não é array"
    echo "é array\n";
} else {
    echo "não é array\n";
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>Regras de resolução de nomes</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Para efeitos dessas regras de resolução, aqui estão algumas definições importantes:
   <variablelist>
    <title>Definições de nomes de namespace</title>
    <varlistentry>
     <term>Nome não qualificado</term>
     <listitem>
      <para>
       Esse é um identificador sem o separador de namespace, tal como <literal>Foo</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Nome qualificado</term>
     <listitem>
      <para>
       Esse é um identificador com separador de namespace, tal como <literal>Foo\Bar</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Nome totalmente qualificado</term>
     <listitem>
      <para>
       Esse é um identificador com separador de namespace que começa com um
       separador de namespace, tal como <literal>\Foo\Bar</literal>. O namespace
       <literal>\Foo</literal> também é um nome totalmente qualificado.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Nome relativo</term>
     <listitem>
      <para>
       Esse é um identificador que começa com <literal>namespace</literal>, tal como
       <literal>namespace\Foo\Bar</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Os nomes são resolvidos seguindo estas regras de resolução:
   <orderedlist>
    <listitem>
     <simpara>
      Nomes totalmente qualificados sempre resolvem para o nome sem separador de namespace à esquerda.
      Por exemplo, <literal>\A\B</literal> resolve para <literal>A\B</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nomes relativos sempre resolvem para nome com <literal>namespace</literal> substituído
      pelo namespace atual. Se o nome ocorrer no namespcace global, o
      prefixo do <literal>namespace\</literal> é removido. Por exemplo <literal>namespace\A</literal>
      dentro do namespace <literal>X\Y</literal> resolve para <literal>X\Y\A</literal>. O mesmo nome
      dentro do namespace global resolve para <literal>A</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para nomes qualificados, o primeiro segmento do nome é traduzido de acordo com a atual
      tabela de importação de classe/namespace. Por exemplo, se o namespace <literal>A\B\C</literal> é
      importado como <literal>C</literal>, o nome <literal>C\D\E</literal> é traduzido para
      <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para nomes qualificados, se nenhuma regra de importação se aplica, o namespace atual será anexado ao
      nome. Por examplo, o nome <literal>C\D\E</literal> dentro do namespace <literal>A\B</literal>,
      resolve para <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para nomes não qualificados, o nome é traduzido de acordo com a atual tabela de importação para o
      respectivo tipo de simbolo. Isso significa que nomes semelhantes a classes são traduzidos de acordo com a
      tabela de importação de classe/namespace, nomes de funções de acordo com a tabela de importação de funções e
      constantes de acordo com a tabela de importação de constantes. Por exemplo, após o
      <literal>use A\B\C;</literal> um uso como <literal>new C()</literal> resolve para o nome
      <literal>A\B\C()</literal>. Da mesma forma, após o <literal>use function A\B\fn;</literal> um uso
      como <literal>fn()</literal> resolve para o nome <literal>A\B\fn</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para nomes não qualidaficado, se nenhuma regra de importação se aplicar e o nome se referir a um símbolo de classe,
      o namespace atual será prefixado. Por exemplo <literal>new C()</literal> dentro do namespace
      <literal>A\B</literal> resolve para o nome <literal>A\B\C</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Para nomes não qualificados, se nenhuma regra de importação se aplicar e o nome se referir a uma função ou constante
      e o codigo está fora do namespace global, o nome é resolvido em tempo de execução.
      Supondo que o código seja no namespace <literal>A\B</literal>, aqui é como uma chamada para a função
      <literal>foo()</literal> é resolvida:
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         Ele procura por uma função do namespace atual:
         <literal>A\B\foo()</literal>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Ele tenta encontrar a chamar a função <emphasis>global</emphasis>
         <literal>foo()</literal>.
        </simpara>
       </listitem>
      </orderedlist>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>Resoluções de nomes ilustradas</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;
use B\D, C\E as F;

// chamadas de funções

foo();      // primeiro tenta chamar "foo" definido no namespace "A"
            // então chama a função global "foo"

\foo();     // chama a função "foo" definida no escopo global

my\foo();   // chama a função "foo" definida no namespace "A\my"

F();        // primeiro tenta chamar "F" definida no namespace "A"
            // e depois chama a função global "F"

// referência de classe

new B();    // cria objeto da classe "B" definida no namespace "A"
            // se não encontrou, ele tenta carregar autolomaticamente a classe  "A\B"

new D();    // usando regras de importação, cria objeto de classe "D" definido no namespace "B"
            // se não for encontrado, ele tenta carregar automaticamente a classe "B\D"

new F();    // usando regras de importação, cria objeto de classe "E" definido no namespace "C"
            // se não for encontrado, ele tenta carregar automaticamente a classe "C\E"

new \B();   // cria objeto de classe "B" definida no escopo global
            // se não for encontrado, ele tenta carregar automaticamente a classe "B"

new \D();   // cria objeto de classe "D" definida no escopo global
            // se não for encontrado, ele tenta carregar automaticamente a classe "D"

new \F();   // cria objeto de classe "F" definido no escopo global
            // se não for encontrado, ele tenta carregar automaticamente a classe "F"

// métodos estáticos/funções de namespace de outro namespace

B\foo();    // chama a função "foo" do namespace "A\B"

B::foo();   // chama o método "foo" da classe "B" definida no namespace "A"
            // se classe "A\B" não for encontrada, ele tenta carregar automaticamente a classe "A\B"

D::foo();   // usando regras de importação, chama o método "foo" da classe "D" definida no namespace "B"
            // se a classe "B\D" não for encontrada, ele tenta carregar automaticamente a classe "B\D"

\B\foo();   // chama a função "foo" do namespace "B"

\B::foo();  // chama o método "foo" da classe "B" do escopo global
            // se classe "B" não for encontrada, ele tenta carregar automaticamente a classe "B"

// métodos estáticos/funções de namespace do namespace atual

A\B::foo();   // chama o método "foo" da classe "B" do namespace "A\A"
              // se a classe "A\A\B" não for encontrada, ele tenta carregar automaticamente a class "A\A\B"

\A\B::foo();  // chama o método "foo" da classe "B" do namespace "A"
              // se a classe "A\B" não for encontrada, ele tenta carregar automaticamente a classe "A\B"
?>
]]>
   </programlisting>
  </example>
 </sect1>
 <sect1 xml:id="language.namespaces.faq">
  <title>Perguntas Frequentes (FAQ): Coisas que você precisa saber sobre namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Este FAQ se divide em duas seções: perguntas comuns e alguns detalhes de
   implementação úteis de se entender completamente.
  </para>
  <para>
   Primeiro, as perguntas comuns.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shouldicare">Se eu não utilizo namespames, devo me importar
      com esta documentação?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.globalclass">Como utilizar classes internas ou globais
      dentro de um namespace?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.innamespace">Como utilizar classes,
      funções ou constantes em um namespace, dentro de seu próprio namespace?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.full">
       Como nomes como <literal>\meu\nome</literal> e <literal>\nome</literal>
       são resolvidos?
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.qualified">Como nome como
      <literal>my\name</literal> é resolvido?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname1">Como nome de classe não qualificado
      como <literal>name</literal> é resolvido?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname2">Como nome de função
      não qualificada ou nome de constante não qualificada
      como <literal>name</literal> é resolvido?</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Há alguns detalhes de implementação dos namespaces que são úteis de se
   entender.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.conflict">Os nomes de importação não deve entrar em conflito com
      classes definidas no mesmo arquivo.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.nested">Namespaces alinhados não são permitidos.
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.quote">Nomes de namespace dinâmicos (identificadores
      entre aspas) deve escapar da barra invertida.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.constants">Undefined Constants referenced
      using any backslash die with fatal error</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.builtinconst">Cannot override special
      constants NULL, TRUE, FALSE, ZEND_THREAD_SAFE or ZEND_DEBUG_BUILD</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <sect2 xml:id="language.namespaces.faq.shouldicare">
   <title>Se eu não utilizo namespames, devo me importar com esta documentação?</title>
   <para>
    Não. Namespaces não afetam nenhum código que já exista, ou que venha
    a existir, que não contenha namespaces. Você pode escrever o seguinte se
    quiser:
   </para>
   <para>
    <example>
     <title>Acessando classes glboais fora de um namespace</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new \stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    O exemplo acima é equivalente ao seguinte código:
   </para>
   <para>
    <example>
     <title>Accessing global classes outside a namespace</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.globalclass">
   <title>Como utilizar classes internas ou globais dentro de um namespace?</title>
   <para>
    <example>
     <title>Acessando classes internas em namespaces</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \stdClass;

function test(\ArrayObject $exemplo_com_tipo_de_parametro = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// herança de uma classe interna ou global
class MyException extends \Exception {}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.innamespace">
   <title>
    Como utilizar classes, funções ou constantes em um namespace, dentro de seu próprio
    namespace?
   </title>
   <para>
    <example>
     <title>Acessando classes, funções ou constantes internas em um namespace</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;

class MinhaClasse {}

// utilizando uma classe do namespace atual como tipo de parâmetro
function test(MinhaClasse $exemplo_com_tipo_de_parametro = null) {}
// outra forma de utilizar a classe do namespace atual como tipo de parâmetro
function test(\foo\MinhaClasse $exemplo_com_tipo_de_parametro = null) {}

// herança de classe a partir do namespace atual
class Extended extends MyClass {}

// acessando uma função global
$a = \globalfunc();

// acessando uma constante global
$b = \INI_ALL;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.full">
   <title>
     Como nomes como <literal>\meu\nome</literal> e <literal>\nome</literal>
     são resolvidos?
   </title>
   <para>
    Nomes que começam com uma barra invertida (<literal>\</literal>) sempre resolvem
    para seu conteúdo exato. Então <literal>\meu\nome</literal> é o mesmo que <literal>meu\nome</literal>,
    e <literal>\Exception</literal> é o mesmo que <literal>Exception</literal>.
    <example>
     <title>Nomes totalmente qualificados (FQN)</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \meu\nome(); // cria uma instância da classe "meu\nome"
echo \strlen('olá'); // invoca a função "strlen"
$a = \INI_ALL; // $a recebe o valor da constante "INI_ALL"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.qualified">
   <title>Como nome como <literal>my\name</literal> é resolvido?</title>
   <para>
    Nomes que contêm uma barra invertida, mas não começam  com uma barra invertida como
    <literal>my\name</literal> podem ser resolvidos de 2 maneiras diferentes.
   </para>
   <para>
    Se houver
    uma instrução de importação que apelide outro nome a <literal>my</literal>, então
    o apelido de importação será aplicado ao <literal>my</literal> em <literal>my\name</literal>.
   </para>
   <para>
    Caso contrário, o nome do namespace atual será anexado a <literal>my\name</literal>.
   </para>
   <para>
    <example>
     <title>Nomes qualificados</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new my\name(); // instancia a classe "foo\my\name"
foo\bar::name(); // chama método estátido "name" na classe "blah\blah\bar"
my\bar(); // chama a função "foo\my\bar"
$a = my\BAR; // define $a com o valor da constante "foo\my\BAR"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname1">
   <title>Como nome de classe não qualificado como <literal>name</literal> é resolvido?</title>
   <para>
    Nomes de classes que não contêm barra invertida como
    <literal>name</literal> pode ser resolvidos de 2 maneiras diferentes.
   </para>
   <para>
    Se houver
    uma instrução de importação que apelide outro nome a <literal>name</literal>, então
    o apelido de importação será aplicado.
   </para>
   <para>
    Caso contrário, o nome do namespace atual será anexado a <literal>name</literal>.
   </para>
   <para>
    <example>
     <title>Nomes de classes não qualificados</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new name(); // instância a classe "foo\name"
foo::name(); // chama o método estático "name" na classe "blah\blah"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname2">
   <title>
    Como nome de função não qualificada ou nome de constânte não qualificada
    como <literal>name</literal> é resolvido?
   </title>
   <para>
    Nomes de funções ou constântes que não contêm barra invertida como
    <literal>name</literal> pode ser resolvidos de 2 maneiras diferentes.
   </para>
   <para>
    Primeito, o nome do namespace atual será anexado a <literal>name</literal>.
   </para>
   <para>
    Finalmente, se a contante ou função <literal>name</literal> não existir
    no namespace atual, uma constante ou função global <literal>name</literal>
    será usada se existir.
   </para>
   <para>
    <example>
     <title>Nomes de funções ou constante não qualificadas</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

const FOO = 1;

function my() {}
function foo() {}
function sort(&$a)
{
    \sort($a); // chama a função global "sort"
    $a = array_flip($a);
    return $a;
}

my(); // chama "foo\my"
$a = strlen('hi'); // chama a função global "strlen" porque não existe "foo\strlen"
$arr = array(1,3,2);
$b = sort($arr); // chama a função "foo\sort"
$c = foo(); // chama a função "foo\foo" - importação não é aplicada

$a = FOO; // define $a com o valor da constante "foo\FOO" - importação não é aplicada
$b = INI_ALL; // define $b com o valor da constante global "INI_ALL"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.conflict">
   <title>Os nomes de importação não devem entrar em conflito com classes definidas no mesmo arquivo.</title>
   <para>
    As seguintes combinação de script são válidas:
    <informalexample>
     <simpara>arquivo1.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace minha\coisa;
class MinhaClasse {}
?>
     ]]>
     </programlisting>
     <simpara>outra.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace outra;
class coisa {}
?>
     ]]>
     </programlisting>
     <simpara>arquivo2.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace minha\coisa;
include 'arquivo1.php';
include 'outro.php';

use outra\coisa as MinhaClasse;
$a = new MinhaClasse; // instancia a classe "coisa" do namespace "outra"
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Não há conflito de nomes, mesmo que a classe <literal>MinhaClasse</literal> exista
    dentro do namespace <literal>minha\coisa</literal>, porque a definição de MinhaClasse está
    em um arquivo separado. No entanto, o próximo exeplo causa um erro fatal de conflito de nomes
    porque MinhaClasse está definida no mesmo arquivo de instrução de uso.
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace minha\coisa;
use outra\coisa as MinhaClasse;
class MinhaClasse {} // erro fatal: MinhaClasse está com conflito de instrução de importação
$a = new MinhaClasse;
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.nested">
   <title>Namespaces alinhados não são permitidos.</title>
   <para>
    PHP não permite alinhar namespaces
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace minha\coisa {
    namespace alinhar {
        class foo {}
    }
}
?>
     ]]>
     </programlisting>
    </informalexample>
    No entanto, é fácil simular o namespace alinhados como:
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace minha\coisa\alinhada {
    class foo {}
}
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>

  <sect2 xml:id="language.namespaces.faq.quote">
   <title>Nomes de namespace dinâmicos (identificadores entre aspas) deve escapar da barra invertida</title>
   <para>
    É muito importante perceber o porque a barra invertida é usada para escapar caracter
    dentro de strings,isso deve sempre ser duplicado quando usado em uma sitrng. Por outro lado,
    existe um risco de consequências não desejadas.
    <example>
     <title>Perigo de usar nomes com namespace dentro de uma string com aspas duplas</title>
     <programlisting role="php">
      <![CDATA[
<?php
$a = "dangerous\name"; // \n é uma nova linha dentro da string de aspas duplas!
$obj = new $a;

$a = 'not\at\all\dangerous'; // não a problemas aqui.
$obj = new $a;
?>
      ]]>
     </programlisting>
    </example>
    Dentro de string com aspas simples, a sequência de escape de barra invertida é muito mais segura de usar, mas
    ainda é recomendado como boa prática escapar com barras invertidas em todas as springs.
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.constants">
   <title>Constantes indefinidas referenciadas por contrabarra geram erro fatal</title>
   <para>
    Quaisquer constantes não qualificadas como por exemplo <literal>FOO</literal> geram
    um alerta avisando que o PHP assumirá que <literal>FOO</literal> era o valor
    da constante. Quaisquer constantes, qualificadas ou totalmente qualificadas, que portanto
    contém uma contrabarra, gerará um erro fatal se não definida.
    <example>
     <title>Constantes qualificadas não definidas</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
$a = FOO; // Produz um alerta - constante FOO assume o valor "FOO"
$a = \FOO; // Erro fatal, constante qualificada indefinida FOO
$a = Bar\FOO; // Erro fatal, constante qualificada indefinida bar\Bar\FOO
$a = \Bar\FOO; // Erro fatal, constante qualificada indefinida Bar\FOO
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.builtinconst">
   <title>Impossibilidade de sobrescrever constantes especiais NULL, TRUE, FALSE, ZEND_THREAD_SAFE ou ZEND_DEBUG_BUILD</title>
   <para>
    Quaisquer tentativas de definir uma constante que seja especial, mesmo que dentro de namespaces,
    resultam em um erro fatal.
    <example>
     <title>Constantes não definíveis</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
const NULL = 0; // Erro fatal
const true = 'stupid'; // Também um erro fatal
// etc.
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
-->
