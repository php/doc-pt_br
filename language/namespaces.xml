<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1431d18dc4ee8056f2958d2b6af559c9e5478f61 Maintainer: none Status: wip --><!-- CREDITS: dcbmariano,lhsazevedo,ae,nawarian -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
 version="1.1">
 <title>Namespaces</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>Visão geral de Namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <simpara>
   O que são namespaces? Na definição mais ampla, os namespaces (na tradução literal, "espaços de nomes") são uma forma de encapsular
   itens. Isso pode ser visto com um conceito abstrato em muitos lugares. Por exemplo, em qualquer
   sistema operacional os diretórios servem para agrupar arquivos relacionados, e agem como um namespace para
   os arquivos dentro dele. Como um exemplo concreto, o arquivo <literal>foo.txt</literal> pode
   existir em ambos os diretórios <literal>/home/greg</literal> e <literal>/home/other</literal>,
   mas duas cópias de <literal>foo.txt</literal> não podem coexistir em um mesmo diretório. Além
   disso, para acessar o arquivo <literal>foo.txt</literal> fora do 
   diretório <literal>/home/greg</literal>, devemos informar o nome do diretório antes do nome
   do arquivo usando o separador de diretórios para obter <literal>/home/greg/foo.txt</literal>. Esse
   mesmo princípio se estende a namespaces no mundo da programação.
  </simpara>

  <simpara>
   No mundo PHP, os namespaces são projetados para resolver dois problemas que os autores 
   de bibliotecas e aplicativos encontram ao criar elementos de código reutilizáveis, 
   como classes ou funções:
  </simpara>
  <para>
   <orderedlist>
    <listitem>
     <simpara>
      Nomear as colisões entre o código que você cria e
      classes/funções/constantes internas do PHP ou classes/funções/constantes de terceiros.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Capacidade de criar apelidos (ou encurtar) Nomes_Extra_Longos projetados para aliviar o primeiro problema, 
      melhorando a legibilidade do código-fonte.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <simpara>
   Os Namespaces do PHP fornecem uma maneira de agrupar classes, interfaces,
   funções e constantes relacionadas. Aqui está um exemplo da sintaxe de namespace em PHP:
  </simpara>
  <example>
   <title>Exemplo da sintaxe de namespace</title>
   <programlisting role="php">
   <![CDATA[
<?php
namespace meu\nome; // veja a seção "Definindo Namespaces"

class MinhaClasse {}
function minhafuncao() {}
const MINHACONST = 1;

$a = new MinhaClasse;
$c = new \meu\nome\MinhaClasse; // veja a seção "Espaço Global"

$a = strlen('oi'); // veja a seção "Usando namespaces: fallback para
                   // função/constante global"

$d = namespace\MINHACONST; // veja a seção "operador de namespace 
                           // e constante __NAMESPACE__"
$d = __NAMESPACE__ . '\MINHACONST';
echo constant($d); // veja a seção "Namespaces e funcionalidades dinâmicas da linguagem" section
?>
    ]]>
   </programlisting>
  </example>
   <note>
    <simpara>
     Os nomes de namespace não diferenciam maiúsculas de minúsculas.
    </simpara>
   </note>   
  <note>
   <para>
    O nome de Namespace <literal>PHP</literal> e nomes compostos que começam 
    com esse nome (como <literal>PHP\Classes</literal>) são reservados para uso interno da linguagem 
    e não devem ser usados no código de espaço de usuário.
   </para>
  </note>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>Definindo namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Embora qualquer código PHP válido possa estar contido em um namespace, apenas os seguintes
   tipos de código são afetados por namespaces: classes (incluindo abstratas e traits), interfaces, funções e constantes.
  </para>
  <para>
   Namespaces são declarados usando a palavra-chave <literal>namespace</literal>. 
   Um arquivo contendo um namespace deve declarar o namespace 
   na parte superior do arquivo antes de qualquer outro código - com uma exceção: a
   palavra-chave <xref linkend="control-structures.declare" />.
   <example>
    <title>Declarando um único namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */ }

?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Nomes totalmente qualificados (ou seja, nomes que começam com uma barra invertida) não são permitidos em declarações
     de namespace, porque esses construtos são interpretadas como expressões de namespace relativos.
    </simpara>
   </note>
   O único construto de código permitido antes de uma declaração de namespace é a
   declaração <literal>declare</literal>, para definir a codificação de um arquivo fonte. Além disso, 
   nenhum código não-PHP pode preceder uma declaração de namespace, incluindo espaço em branco extra:
   <example>
    <title>Declarando um único namespace</title>
    <programlisting role="php">
     <![CDATA[
<html>
<?php
namespace MeuProjeto; // fatal error - namespace must be the first statement in the script
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Além disso, diferente de qualquer outro construto do PHP, o mesmo namespace pode ser definido 
   em vários arquivos, permitindo a divisão do conteúdo de um namespace no sistema de arquivos.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nested">
  <title>Declarando sub namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Assim como diretórios e arquivos, os namespaces do PHP são capazes de especificar
   uma hierarquia de namespaces. Assim, um namespace pode ser definido com
   subníveis.
   <example>
    <title>Declarando um namespace com hierarquia</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto\Nivel\SubNivel;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   O exemplo acima cria a constante <literal>MeuProjeto\Nivel\SubNivel\CONEXAO_OK</literal>,
   a classe <literal>MeuProjeto\Nivel\SubNivel\Conexao</literal> e a função
   <literal>MeuProjeto\Nivel\SubNivel\conectar</literal>.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.definitionmultiple">
  <title>Definindo múltiplos namespaces no mesmo arquivo</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Múltiplos namespaces também podem ser declarados no mesmo arquivo. Existem duas sintaxes
   permitidas.
  </para>
  <para>
   <example>
    <title>Declarando múltiplos namespaces, sintaxe de combinação simples</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }

namespace OutroProjeto;

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Essa sintaxe não é recomendada para combinar namespaces em um único arquivo.
   Em vez disso, é recomendado usar a sintaxe de colchetes como alternativa.
  </para>
  <para>
   <example>
    <title>Declarando múltiplos namespaces, sintaxe de colchetes</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}

namespace OutroProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   É fortemente desencorajado como prática de programação combinar vários namespaces no
   mesmo arquivo. O caso de uso principal é combinar múltiplos scripts PHP no mesmo
   arquivo.
  </para>
  <para>
   Para combinar código global sem namespace e código com namespace, apenas a sintaxe de colchetes é
   suportada. Código global deve ser
   envolto em uma declaração de namespace sem nome de namespace, como em:
   <example>
    <title>Declarando múltiplos namespaces e código sem namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}

namespace { // código global
session_start();
$a = MeuProjeto\conectar();
echo MeuProjeto\Conexao::iniciar();
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Nenhum código PHP pode existir fora dos colchetes de namespace, exceto uma declaração
   declare de abertura.
   <example>
    <title>Declarando múltiplos namespaces e código sem namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
declare(encoding='UTF-8');
namespace MeuProjeto {

const CONEXAO_OK = 1;
class Conexao { /* ... */ }
function conectar() { /* ... */  }
}

namespace { // código global
session_start();
$a = MeuProjeto\conectar();
echo MeuProjeto\Conexao::iniciar();
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.basics">
  <title>Usando namespaces: Fundamentos</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Antes de discutir o uso de namespaces, é importante entender como o PHP
   sabe qual elemento de namespace o seu código está solicitando. Uma analogia simples pode ser feita
   entre os namespaces do PHP e um sistema de arquivos. Existem três maneiras de acessar um arquivo em um
   sistema de arquivos:
   <orderedlist>
    <listitem>
     <simpara>
      Nome de arquivo relativo como <literal>foo.txt</literal>. É resolvido para
      <literal>diretorioatual/foo.txt</literal> onde diretorioatual é o
      diretório ocupado atualmente. Então, se o diretório atual for
      <literal>/home/foo</literal>, o nome resolve para <literal>/home/foo/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome de caminho relativo como <literal>subdiretorio/foo.txt</literal>. É resolvido
      para <literal>diretorioatual/subdiretorio/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome de caminho absoluto como <literal>/main/foo.txt</literal>. É resolvido
      para <literal>/main/foo.txt</literal>.
     </simpara>
    </listitem>
   </orderedlist>
   O mesmo princípio pode ser aplicado para elementos com namespace no PHP. Por
   exemplo, um nome de classe pode ser referenciado em três maneiras:
   <orderedlist>
    <listitem>
     <simpara>
      Nome não qualificado, ou nome de classe sem prefixo como
      <literal>$a = new foo();</literal> ou
      <literal>foo::metodoestatico();</literal>. Se o namespace atual for
      <literal>namespaceatual</literal>, ele é resolvido para
      <literal>namespaceatual\foo</literal>. Se
      o código for global, sem namespace, ele é resolvido para <literal>foo</literal>.
     </simpara>
     <simpara>
      Uma ressalva: nomes não qualificados para funções e constantes
      resolverão para funções e constantes globais se a função ou constante com namespace
      não estiver definida. Veja <link linkend="language.namespaces.fallback">Usando namespaces:
      fallback para função/constante global</link> para detalhes.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome qualificado, ou nome de classe prefixado como
      <literal>$a = new subnamespace\foo();</literal> ou
      <literal>subnamespace\foo::metodoestatico();</literal>. Se o namespace atual for
      <literal>namespaceatual</literal>, ele resolve para
      <literal>namespaceatual\subnamespace\foo</literal>.  Se
      o código for global, sem namespace, ele resolve para <literal>subnamespace\foo</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nome totalmente qualificado, ou nome prefixado com um operador de prefixo global como
      <literal>$a = new \namespaceatual\foo();</literal> ou
      <literal>\namespaceatual\foo::metodoestatico();</literal>. Ele sempre resolve
      para o nome literal especificado no código, <literal>namespaceatual\foo</literal>.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Aqui está um exemplo dos três tipos de sintaxe em código real:
   <informalexample>
    <simpara>arquivo1.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo\Bar\subnamespace;

const FOO = 1;
function foo() {}
class foo
{
    static function metodoestatico() {}
}
?>
     ]]>
    </programlisting>
    <simpara>arquivo2.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo\Bar;
include 'arquivo1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function metodoestatico() {}
}

/* Nome não qualificado */
foo(); // resolve para a função Foo\Bar\foo
foo::metodoestatico(); // resolve para a classe Foo\Bar\foo, método metodoestatico
echo FOO; // resolve para a constante Foo\Bar\FOO

/* Nome qualificado */
subnamespace\foo(); // resolve para a função Foo\Bar\subnamespace\foo
subnamespace\foo::metodoestatico(); // resolve para a classe Foo\Bar\subnamespace\foo,
                                    // método metodoestatico
echo subnamespace\FOO; // resolve para a constante constant Foo\Bar\subnamespace\FOO
                                  
/* Nome totalmente qualificado */
\Foo\Bar\foo(); // resolve para a função Foo\Bar\foo
\Foo\Bar\foo::metodoestatico(); // resolve para a classe Foo\Bar\foo, método metodoestatico
echo \Foo\Bar\FOO; // resolve para a constante Foo\Bar\FOO
?>
     ]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Note que para acessar qualquer classe,
   função ou constante global, um nome totalmente qualificado pode ser usado, como
   <function>\strlen</function> ou <classname>\Exception</classname> ou
   <literal>\INI_ALL</literal>.
   <example>
    <title>Acessando classes, funções e constantes globais de dentro de um namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Foo;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('oi'); // chama a função global strlen
$b = \INI_ALL; // acessa a constante global INI_ALL
$c = new \Exception('erro'); // instancia a classe global Exception
?>
     ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.dynamic">
  <title>Namespaces e funcionalidades de linguagem dinâmica</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   A implementação de namespaces do PHP é influenciada por sua natureza dinâmica como uma linguagem
   de programação. Portanto, para converter código como o seguinte para código com namespace:
   <example>
    <title>Acessando elementos dinamicamente</title>
    <simpara>exemplo1.php:</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
class namedaclasse
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function nomedafuncao()
{
    echo __FUNCTION__,"\n";
}
const nomedaconstante = "global";

$a = 'namedaclasse';
$obj = new $a; // imprime namedaclasse::__construct
$b = 'nomedafuncao';
$b(); // imprime nomedafuncao
echo constant('nomedaconstante'), "\n"; // imprime global
?>
    ]]>
    </programlisting>
   </example>
   Deve-se usar o nome totalmente qualificado (nome de classe prefixado com namespace).
   Observe que, como não há diferença entre um nome qualificado e um totalmente qualificado
   dentro de um nome de classe, nome de função ou nome de constante dinâmico, a barra invertida inicial não
   é necessária.
   <example>
    <title>Acessando dinamicamente elementos com namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace nomedonamespace;
class nomedaclasse
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function nomedafuncao()
{
    echo __FUNCTION__,"\n";
}
const nomedaconstante = "comnamespace";

/* Observe que, ao usar aspas duplas, "\\nomedonamespace\\nomedaclasse" deve ser usado */
$a = '\nomedonamespace\nomedaclasse';
$obj = new $a; // imprime nomedonamespace\nomedaclasse::__construct
$a = 'nomedonamespace\nomedaclasse';
$obj = new $a; // também imprime nomedonamespace\nomedaclasse::__construct
$b = 'nomedonamespace\nomedafuncao';
$b(); // imprime nomedonamespace\nomedafuncao
$b = '\nomedonamespace\nomedafuncao';
$b(); // também imprime nomedonamespace\nomedafuncao
echo constant('\nomedonamespace\nomedaconstante'), "\n"; // imprime comnamespace
echo constant('nomedonamespace\nomedaconstante'), "\n"; // também imprime comnamespace
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   Certifique-se de ler a <link linkend="language.namespaces.faq.quote">nota sobre
   escapamento de namespaces em strings</link>.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nsconstants">
  <title>Palavra-chave namespace e constante __NAMESPACE__</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   O PHP suporta duas maneiras de acessar elementos de forma abstrata dentro do namespace atual,
   a constante mágica <constant>__NAMESPACE__</constant>, e a palavra-chave
   <literal>namespace</literal>.
  </para>
  <para>
   O valor de <constant>__NAMESPACE__</constant> é uma string que contem o nome do namespace
   atual. Em código global, sem namespace, ela contém uma string vazia.
   <example>
    <title>Exemplo da __NAMESPACE__, código com namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

echo '"', __NAMESPACE__, '"'; // produz "MeuProjeto"
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Exemplo da __NAMESPACE__, código global</title>
    <programlisting role="php">
     <![CDATA[
<?php

echo '"', __NAMESPACE__, '"'; // produz ""
?>
]]>
    </programlisting>
   </example>
   A constante <constant>__NAMESPACE__</constant> é útil para construir nomes de forma
   dinâmica, por exemplo:
   <example>
    <title>Usando __NAMESPACE__ para construção dinâmica de nomes</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

function get($nomedaclasse)
{
    $a = __NAMESPACE__ . '\\' . $nomedaclasse;
    return new $a;
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   A palavra-chave <literal>namespace</literal> pode ser usada para solicitar explicitamente
   um elemento do namespace atual ou um sub-namespace. Ela é o equivalente
   para os namespaces do operador <literal>self</literal> para classes.
   <example>
    <title>O operador namespace, dentro de um namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace MeuProjeto;

use bla\bla as meu; // Veja "Usando namespaces: Apelidando/Importando"

bla\meu(); // chama a função MeuProjeto\bla\meu()
namespace\bla\meu(); // chama a função MeuProjeto\bla\meu()

namespace\func(); // chama a função MeuProjeto\func()
namespace\sub\func(); // chama a função MeuProjeto\sub\func()
namespace\cname::metodo(); // chama o método estático "metodo" da classe MeuProjeto\cname
$a = new namespace\sub\cname(); // instancia um objeto da classe MeuProjeto\sub\cname
$b = namespace\CONSTANTE; // atribui o valor da constante MeuProjeto\CONSTANTE à $b
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>O operador namespace, em código global</title>
    <programlisting role="php">
     <![CDATA[
<?php

namespace\func(); // chama a função func()
namespace\sub\func(); // chama a função sub\func()
namespace\cname::metodo(); // chama o método estático "metodo" da classe cname
$a = new namespace\sub\cname(); // instancia um objeto da classe sub\cname
$b = namespace\CONSTANTE; // atribui o valor da constante CONSTANTE à $b
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.importing">
  <title>Usando namespaces: Apelidando/Importando</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   The ability to refer to an external fully qualified name with an alias, or importing,
   is an important feature of namespaces.  This is similar to the
   ability of unix-based filesystems to create symbolic links to a file or to a directory.
  </para>
  <para>
   PHP can alias(/import) constants, functions, classes, interfaces, traits, enums and namespaces.
  </para>
  <para>
   Aliasing is accomplished with the <literal>use</literal> operator.
   Here is an example showing all 5 kinds of importing:
   <example>
    <title>importing/aliasing with the use operator</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace foo;
use My\Full\Classname as Another;

// this is the same as use My\Full\NSname as NSname
use My\Full\NSname;

// importing a global class
use ArrayObject;

// importing a function
use function My\Full\functionName;

// aliasing a function
use function My\Full\functionName as func;

// importing a constant
use const My\Full\CONSTANT;

$obj = new namespace\Another; // instantiates object of class foo\Another
$obj = new Another; // instantiates object of class My\Full\Classname
NSname\subns\func(); // calls function My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // instantiates object of class ArrayObject
// without the "use ArrayObject" we would instantiate an object of class foo\ArrayObject
func(); // calls function My\Full\functionName
echo CONSTANT; // echoes the value of My\Full\CONSTANT
?>
]]>
    </programlisting>
   </example>
   Note that for namespaced names (fully qualified namespace names containing
   namespace separator, such as <literal>Foo\Bar</literal> as opposed to global names that
   do not, such as <literal>FooBar</literal>), the leading backslash is unnecessary and not
   recommended, as import names
   must be fully qualified, and are not processed relative to the current namespace.
  </para>
  <para>
   PHP additionally supports a convenience shortcut to place multiple use statements
   on the same line
   <example>
    <title>importing/aliasing with the use operator, multiple use statements combined</title>
    <programlisting role="php">
     <![CDATA[
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // instantiates object of class My\Full\Classname
NSname\subns\func(); // calls function My\Full\NSname\subns\func
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Importing is performed at compile-time, and so does not affect dynamic class, function
   or constant names.
   <example>
    <title>Importing and dynamic names</title>
    <programlisting role="php">
     <![CDATA[
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // instantiates object of class My\Full\Classname
$a = 'Another';
$obj = new $a;      // instantiates object of class Another
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   In addition, importing only affects unqualified and qualified names.  Fully qualified
   names are absolute, and unaffected by imports.
   <example>
    <title>Importing and fully qualified names</title>
    <programlisting role="php">
     <![CDATA[
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // instantiates object of class My\Full\Classname
$obj = new \Another; // instantiates object of class Another
$obj = new Another\thing; // instantiates object of class My\Full\Classname\thing
$obj = new \Another\thing; // instantiates object of class Another\thing
?>
]]>
    </programlisting>
   </example>
  </para>
  <sect2 xml:id="language.namespaces.importing.scope">
   <title>Scoping rules for importing</title>
   <para>
    The <literal>use</literal> keyword must be declared in the 
    outermost scope of a file (the global scope) or inside namespace 
    declarations. This is because the importing is done at compile 
    time and not runtime, so it cannot be block scoped. The following 
    example will show an illegal use of the <literal>use</literal> 
    keyword:
   </para>
   <para>
    <example>
     <title>Illegal importing rule</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace Languages;

function toGreenlandic()
{
    use Languages\Danish;

    // ...
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Importing rules are per file basis, meaning included files will 
     <emphasis>NOT</emphasis> inherit the parent file's importing rules.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="language.namespaces.importing.group">
   <title>Group <literal>use</literal> declarations</title>
   <para>
    Classes, functions and constants being imported from
    the same &namespace; can be grouped together in a single &use.namespace;
    statement.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// is equivalent to the following groupped use declaration
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
]]>
    </programlisting>
   </informalexample>
  </sect2>
 </sect1>
 <sect1 xml:id="language.namespaces.global">
  <title>Espaço global</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Quando um namespace não é definido, todas as definições de classes e funções são
   colocadas no espaço global, como era no PHP antes dos namespaces serem
   suportados. Prefixar um nome com <literal>\</literal> especificará que
   o nome é requerido do espaço global mesmo no contexto do
   namespace.
   <example>
    <title>Usando especificação de espaço global</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

/* Esta função é A\B\C\fopen */
function fopen() { 
     /* ... */
     $f = \fopen(...); // chama a fopen global
     return $f;
} 
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.fallback">
  <title>Using namespaces: fallback to global function/constant</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Inside a namespace, when PHP encounters an unqualified Name in a class name, function or
   constant context, it resolves these with different priorities.  Class names always
   resolve to the current namespace name.  Thus to access internal or non-namespaced
   user classes, one must refer to them with their fully qualified Name as in:
   <example>
    <title>Accessing global classes inside a namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('hi'); // $a is an object of class A\B\C\Exception
$b = new \Exception('hi'); // $b is an object of class Exception

$c = new ArrayObject; // fatal error, class A\B\C\ArrayObject not found
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   For functions and constants, PHP will fall back to global functions or constants
   if a namespaced function or constant does not exist.
   <example>
    <title>global functions/constants fallback inside a namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

const E_ERROR = 45;
function strlen($str)
{
    return \strlen($str) - 1;
}

echo E_ERROR, "\n"; // prints "45"
echo INI_ALL, "\n"; // prints "7" - falls back to global INI_ALL

echo strlen('hi'), "\n"; // prints "1"
if (is_array('hi')) { // prints "is not array"
    echo "is array\n";
} else {
    echo "is not array\n";
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>Name resolution rules</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   For the purposes of these resolution rules, here are some important definitions:
   <variablelist>
    <title>Namespace name definitions</title>
    <varlistentry>
     <term>Unqualified name</term>
     <listitem>
      <para>
       This is an identifier without a namespace separator, such as <literal>Foo</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Qualified name</term>
     <listitem>
      <para>
       This is an identifier with a namespace separator, such as <literal>Foo\Bar</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Fully qualified name</term>
     <listitem>
      <para>
       This is an identifier with a namespace separator that begins with a
       namespace separator, such as <literal>\Foo\Bar</literal>. The namespace
       <literal>\Foo</literal> is also a fully qualified name.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Relative name</term>
     <listitem>
      <para>
       This is an identifier starting with <literal>namespace</literal>, such as
       <literal>namespace\Foo\Bar</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Names are resolved following these resolution rules:
   <orderedlist>
    <listitem>
     <simpara>
      Fully qualified names always resolve to the name without leading namespace separator.
      For instance <literal>\A\B</literal> resolves to <literal>A\B</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Relative names always resolve to the name with <literal>namespace</literal> replaced by
      the current namespace. If the name occurs in the global namespace, the
      <literal>namespace\</literal> prefix is stripped. For example <literal>namespace\A</literal>
      inside namespace <literal>X\Y</literal> resolves to <literal>X\Y\A</literal>. The same name
      inside the global namespace resolves to <literal>A</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      For qualified names the first segment of the name is translated according to the current
      class/namespace import table. For example, if the namespace <literal>A\B\C</literal> is
      imported as <literal>C</literal>, the name <literal>C\D\E</literal> is translated to
      <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      For qualified names, if no import rule applies, the current namespace is prepended to the
      name. For example, the name <literal>C\D\E</literal> inside namespace <literal>A\B</literal>,
      resolves to <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      For unqualified names, the name is translated according to the current import table for the
      respective symbol type. This means that class-like names are translated according to the
      class/namespace import table, function names according to the function import table and
      constants according to the constant import table. For example, after
      <literal>use A\B\C;</literal> a usage such as <literal>new C()</literal> resolves to the name
      <literal>A\B\C()</literal>. Similarly, after <literal>use function A\B\fn;</literal> a usage
      such as <literal>fn()</literal> resolves to the name <literal>A\B\fn</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      For unqualified names, if no import rule applies and the name refers to a class-like symbol,
      the current namespace is prepended. For example <literal>new C()</literal> inside namespace
      <literal>A\B</literal> resolves to name <literal>A\B\C</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      For unqualified names, if no import rule applies and the name refers to a function or constant
      and the code is outside the global namespace, the name is resolved at runtime.
      Assuming the code is in namespace <literal>A\B</literal>, here is how a call to function
      <literal>foo()</literal> is resolved:
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         It looks for a function from the current namespace:
         <literal>A\B\foo()</literal>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         It tries to find and call the <emphasis>global</emphasis> function
         <literal>foo()</literal>.
        </simpara>
       </listitem>
      </orderedlist>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>Name resolutions illustrated</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;
use B\D, C\E as F;

// function calls

foo();      // first tries to call "foo" defined in namespace "A"
            // then calls global function "foo"

\foo();     // calls function "foo" defined in global scope

my\foo();   // calls function "foo" defined in namespace "A\my"

F();        // first tries to call "F" defined in namespace "A"
            // then calls global function "F"

// class references

new B();    // creates object of class "B" defined in namespace "A"
            // if not found, it tries to autoload class "A\B"

new D();    // using import rules, creates object of class "D" defined in namespace "B"
            // if not found, it tries to autoload class "B\D"

new F();    // using import rules, creates object of class "E" defined in namespace "C"
            // if not found, it tries to autoload class "C\E"

new \B();   // creates object of class "B" defined in global scope
            // if not found, it tries to autoload class "B"

new \D();   // creates object of class "D" defined in global scope
            // if not found, it tries to autoload class "D"

new \F();   // creates object of class "F" defined in global scope
            // if not found, it tries to autoload class "F"

// static methods/namespace functions from another namespace

B\foo();    // calls function "foo" from namespace "A\B"

B::foo();   // calls method "foo" of class "B" defined in namespace "A"
            // if class "A\B" not found, it tries to autoload class "A\B"

D::foo();   // using import rules, calls method "foo" of class "D" defined in namespace "B"
            // if class "B\D" not found, it tries to autoload class "B\D"

\B\foo();   // calls function "foo" from namespace "B"

\B::foo();  // calls method "foo" of class "B" from global scope
            // if class "B" not found, it tries to autoload class "B"

// static methods/namespace functions of current namespace

A\B::foo();   // calls method "foo" of class "B" from namespace "A\A"
              // if class "A\A\B" not found, it tries to autoload class "A\A\B"

\A\B::foo();  // calls method "foo" of class "B" from namespace "A"
              // if class "A\B" not found, it tries to autoload class "A\B"
?>
]]>
   </programlisting>
  </example>
 </sect1>
 <sect1 xml:id="language.namespaces.faq">
  <title>Perguntas Frequentes (FAQ): Coisas que você precisa saber sobre namespaces</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Este FAQ se divide em duas seções: perguntas comuns e alguns detalhes de
   implementação úteis de se entender completamente.
  </para>
  <para>
   Primeiro, as perguntas comuns.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shouldicare">Se eu não utilizo namespames, devo me importar
      com esta documentação?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.globalclass">Como utilizar classes internas ou globais
      dentro de um namespace?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.innamespace">Como utilizar classes,
      funções ou constantes em um namespace, dentro de seu próprio namespace?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.full">
       Como nomes como <literal>\meu\nome</literal> e <literal>\nome</literal>
       são resolvidos?
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.qualified">How does a name like
      <literal>my\name</literal> resolve?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname1">How does an unqualified class name
      like <literal>name</literal> resolve?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname2">How does an unqualified function
      name or unqualified constant name
      like <literal>name</literal> resolve?</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Há alguns detalhes de implementação dos namespaces que são úteis de se
   entender.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.conflict">Import names must not conflict with
      classes defined in the same file.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.nested">Nested namespaces are not allowed.
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.quote">Dynamic namespace names (quoted
      identifiers) should escape backslash.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.constants">Undefined Constants referenced
      using any backslash die with fatal error</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.builtinconst">Cannot override special
      constants NULL, TRUE, FALSE, ZEND_THREAD_SAFE or ZEND_DEBUG_BUILD</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <sect2 xml:id="language.namespaces.faq.shouldicare">
   <title>Se eu não utilizo namespames, devo me importar com esta documentação?</title>
   <para>
    Não. Namespaces não afetam nenhum código que já exista, ou que venha
    a existir, que não contenha namespaces. Você pode escrever o seguinte se
    quiser:
   </para>
   <para>
    <example>
     <title>Acessando classes glboais fora de um namespace</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new \stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    O exemplo acima é equivalente ao seguinte código:
   </para>
   <para>
    <example>
     <title>Accessing global classes outside a namespace</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.globalclass">
   <title>Como utilizar classes internas ou globais dentro de um namespace?</title>
   <para>
    <example>
     <title>Acessando classes internas em namespaces</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \stdClass;

function test(\ArrayObject $exemplo_com_tipo_de_parametro = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// herança de uma classe interna ou global
class MyException extends \Exception {}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.innamespace">
   <title>
    Como utilizar classes, funções ou constantes em um namespace, dentro de seu próprio
    namespace?
   </title>
   <para>
    <example>
    <title>Acessando classes, funções ou constantes internas em um namespace</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;

class MinhaClasse {}

// utilizando uma classe do namespace atual como tipo de parâmetro
function test(MinhaClasse $exemplo_com_tipo_de_parametro = null) {}
// outra forma de utilizar a classe do namespace atual como tipo de parâmetro
function test(\foo\MinhaClasse $exemplo_com_tipo_de_parametro = null) {}

// herança de classe a partir do namespace atual
class Extended extends MyClass {}

// acessando uma função global
$a = \globalfunc();

// acessando uma constante global
$b = \INI_ALL;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.full">
   <title>
     Como nomes como <literal>\meu\nome</literal> e <literal>\nome</literal>
     são resolvidos?
   </title>
   <para>
    Nomes que começam com uma barra invertida (<literal>\</literal>) sempre resolvem
    para seu conteúdo exato. Então <literal>\meu\nome</literal> é o mesmo que <literal>meu\nome</literal>,
    e <literal>\Exception</literal> é o mesmo que <literal>Exception</literal>.
    <example>
     <title>Nomes totalmente qualificados (FQN)</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \meu\nome(); // cria uma instância da classe "meu\nome"
echo \strlen('olá'); // invoca a função "strlen"
$a = \INI_ALL; // $a recebe o valor da constante "INI_ALL"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.qualified">
   <title>How does a name like <literal>my\name</literal> resolve?</title>
   <para>
    Names that contain a backslash but do not begin with a backslash like
    <literal>my\name</literal> can be resolved in 2 different ways.
   </para>
   <para>
    If there is
    an import statement that aliases another name to <literal>my</literal>, then
    the import alias is applied to the <literal>my</literal> in <literal>my\name</literal>.
   </para>
   <para>
    Otherwise, the current namespace name is prepended to <literal>my\name</literal>.
   </para>
   <para>
    <example>
     <title>Qualified names</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new my\name(); // instantiates "foo\my\name" class
foo\bar::name(); // calls static method "name" in class "blah\blah\bar"
my\bar(); // calls function "foo\my\bar"
$a = my\BAR; // sets $a to the value of constant "foo\my\BAR"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname1">
   <title>How does an unqualified class name like <literal>name</literal> resolve?</title>
   <para>
    Class names that do not contain a backslash like
    <literal>name</literal> can be resolved in 2 different ways.
   </para>
   <para>
    If there is
    an import statement that aliases another name to <literal>name</literal>, then
    the import alias is applied.
   </para>
   <para>
    Otherwise, the current namespace name is prepended to <literal>name</literal>.
   </para>
   <para>
    <example>
     <title>Unqualified class names</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new name(); // instantiates "foo\name" class
foo::name(); // calls static method "name" in class "blah\blah"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname2">
   <title>
    How does an unqualified function name or unqualified constant name
    like <literal>name</literal> resolve?
   </title>
   <para>
    Function or constant names that do not contain a backslash like
    <literal>name</literal> can be resolved in 2 different ways.
   </para>
   <para>
    First, the current namespace name is prepended to <literal>name</literal>.
   </para>
   <para>
    Finally, if the constant or function <literal>name</literal> does not exist
    in the current namespace, a global constant or function <literal>name</literal>
    is used if it exists.
   </para>
   <para>
    <example>
     <title>Unqualified function or constant names</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

const FOO = 1;

function my() {}
function foo() {}
function sort(&$a)
{
    \sort($a); // calls the global function "sort"
    $a = array_flip($a);
    return $a;
}

my(); // calls "foo\my"
$a = strlen('hi'); // calls global function "strlen" because "foo\strlen" does not exist
$arr = array(1,3,2);
$b = sort($arr); // calls function "foo\sort"
$c = foo(); // calls function "foo\foo" - import is not applied

$a = FOO; // sets $a to value of constant "foo\FOO" - import is not applied
$b = INI_ALL; // sets $b to value of global constant "INI_ALL"
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.conflict">
   <title>Import names must not conflict with classes defined in the same file.</title>
   <para>
    The following script combinations are legal:
    <informalexample>
     <simpara>file1.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace my\stuff;
class MyClass {}
?>
     ]]>
     </programlisting>
     <simpara>another.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace another;
class thing {}
?>
     ]]>
     </programlisting>
     <simpara>file2.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace my\stuff;
include 'file1.php';
include 'another.php';

use another\thing as MyClass;
$a = new MyClass; // instantiates class "thing" from namespace another
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    There is no name conflict, even though the class <literal>MyClass</literal> exists
    within the <literal>my\stuff</literal> namespace, because the MyClass definition is
    in a separate file.  However, the next example causes a fatal error on name conflict
    because MyClass is defined in the same file as the use statement.
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace my\stuff;
use another\thing as MyClass;
class MyClass {} // fatal error: MyClass conflicts with import statement
$a = new MyClass;
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.nested">
   <title>Nested namespaces are not allowed.</title>
   <para>
    PHP does not allow nesting namespaces
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace my\stuff {
    namespace nested {
        class foo {}
    }
}
?>
     ]]>
     </programlisting>
    </informalexample>
    However, it is easy to simulate nested namespaces like so:
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace my\stuff\nested {
    class foo {}
}
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>

  <sect2 xml:id="language.namespaces.faq.quote">
   <title>Dynamic namespace names (quoted identifiers) should escape backslash</title>
   <para>
    It is very important to realize that because the backslash is used as an escape character
    within strings, it should always be doubled when used inside a string.  Otherwise
    there is a risk of unintended consequences:
    <example>
     <title>Dangers of using namespaced names inside a double-quoted string</title>
     <programlisting role="php">
      <![CDATA[
<?php
$a = "dangerous\name"; // \n is a newline inside double quoted strings!
$obj = new $a;

$a = 'not\at\all\dangerous'; // no problems here.
$obj = new $a;
?>
      ]]>
     </programlisting>
    </example>
    Inside a single-quoted string, the backslash escape sequence is much safer to use, but it
    is still recommended practice to escape backslashes in all strings as a best practice.
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.constants">
   <title>Constantes indefinidas referenciadas por contrabarra geram erro fatal</title>
   <para>
    Quaisquer constantes não qualificadas como por exemplo <literal>FOO</literal> geram
    um alerta avisando que o PHP assumirá que <literal>FOO</literal> era o valor
    da constante. Quaisquer constantes, qualificadas ou totalmente qualificadas, que portanto
    contém uma contrabarra, gerará um erro fatal se não definida.
    <example>
     <title>Constantes qualificadas não definidas</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
$a = FOO; // Produz um alerta - constante FOO assume o valor "FOO"
$a = \FOO; // Erro fatal, constante qualificada indefinida FOO
$a = Bar\FOO; // Erro fatal, constante qualificada indefinida bar\Bar\FOO
$a = \Bar\FOO; // Erro fatal, constante qualificada indefinida Bar\FOO
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.builtinconst">
   <title>Impossibilidade de sobrescrever constantes especiais NULL, TRUE, FALSE, ZEND_THREAD_SAFE ou ZEND_DEBUG_BUILD</title>
   <para>
    Quaisquer tentativas de definir uma constante que seja especial, mesmo que dentro de namespaces,
    resultam em um erro fatal.
    <example>
     <title>Constantes não definíveis</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
const NULL = 0; // Erro fatal
const true = 'stupid'; // Também um erro fatal
// etc.
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
-->
