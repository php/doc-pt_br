<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.34 Maintainer: ae Status: ready -->
 <chapter id="functions">
  <title>Funções</title>

  <sect1 id="functions.user-defined">
   <title>Funções definidas pelo usuário</title>

   <para>
    Uma função pode ser definida usando-se a sintaxe como a seguinte:

    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo ($argumento_1, $argumento_2, ..., $argumento_n)
{
    echo "Exemplo de função.\n";
    return $valor_retornado;
}
]]>
     </programlisting>
    </informalexample>
   </para>

   <!--

    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)

    -->

   <simpara>
    Qualquer código PHP válido pode aparecer dentro de uma função, mesmo outras funções
    e definições de <link linkend="keyword.class">classes</link>.

   </simpara>
   <simpara>
    No PHP 3, as funções precisam ser definidas antes de serem referenciadas. Esse
    requisito não existe no PHP 4. <emphasis>Exceto</emphasis> quando
    uma função é definida condicionalmente como mostrada nos dois exemplos
    abaixo:
   </simpara>
   <para>
    Quando uma função é definida condicionalmente como nos dois
    exemplos abaixo, sua definição precusa ser processada <emphasis>antes</emphasis>
    de ser chamada.
    <example>
     <title>Funções definidas condicionalmente</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nos nao podemos chamar foo() daqui
   porque ela ainda não existe,
   mas nos podemos chamar bar() */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Eu não existo até que o programa passe por aqui.\n";
  }
}

/* Agora nos podemos chamar foo()
   porque $makefoo foi avaliado como true */

if ($makefoo) foo();

function bar()
{
  echo "Eu existo imediatamente desde o programa começar.\n";
}

?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Funções dentro de funções</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Eu não existo até foo() ser chamada.\n";
  }
}

/* Nós não podemos chamar bar() ainda
   porque ela ainda não foi definida. */

foo();

/* Agora nós podemos chamar bar(),
   porque o processamento de foo()
   tornou a primeira acessivel */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    O PHP não suporta sobrecarga de funções, e também não é possível cancelar ou
    alterar a definição de funções previamente declaradas.
   </simpara>
   <note>
    <simpara>
     Nomes de funções são insensíveis ao caso, mas é melhor chamar
     as funções da mesma forma que ela aparecem nas declarações.
    </simpara>
   </note>
   <simpara>
    O PHP3 não suporta número variável de argumentos para funções, apesar de os
    argumentos padrões serem suportados (veja <link
    linkend="functions.arguments.default">Valores padrão de argumentos
    </link> para mais informações). O PHP4 suporta ambos: veja <link
    linkend="functions.variable-arg-list">Número de argumentos
    variável</link> e as referências das funções
    <function>func_num_args</function>,
    <function>func_get_arg</function> e
    <function>func_get_args</function> para mais informações.
   </simpara>

  </sect1>

  <sect1 id="functions.arguments">
   <title>Argumentos de funções</title>

   <simpara>
    Informações podem ser passadas para funções através da lista de argumentos, que é uma
    lista de variáveis e/ou constantes delimitados por vírgulas.
   </simpara>
   <para>
     O PHP suporta a passagem de argumentos por valor (o padrão), <link
     linkend="functions.arguments.by-reference">passagem por referência
     </link> e <link
     linkend="functions.arguments.default">valores padrão de argumento
     </link>. Listas de argumentos de comprimento variável são suportadas apenas
     no PHP4 e posterior; veja <link
     linkend="functions.variable-arg-list">Número de argumentos
     variável</link> e as referências das funções
     <function>func_num_args</function>,
     <function>func_get_arg</function> e
     <function>func_get_args</function> para mais informações. Um efeito similar
     pode ser atingido no PHP 3 pela passagem de um array de argumentos para uma
     função:

    <informalexample>
     <programlisting role="php">
<![CDATA[
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 id="functions.arguments.by-reference">
    <title>Fazendo argumentos serem passados por referência</title>

    <simpara>
     Por padrão, argumentos de função são passados por valor (de forma que se
     você mudar o valor do parâmetro dentro da função, ele não é alterado fora
     da função). Se você deseja permitir que uma função modifique seus argumentos,
     você precisa passá-los por
     referência.
    </simpara>
    <para>
     Se você quer que um argumento para uma função sempre seja passado por
     referência, você pode preceder o nome do argumento com um "e comercial" (&amp;)
     na definição da função:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function add_some_extra(&$string)
{
    $string .= ' e alguma coisa mais.';
}
$str = 'Isto é uma string,';
add_some_extra($str);
echo $str;    // imprime 'Isto é uma string, e alguma coisa mais.'
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>

   <sect2 id="functions.arguments.default">
    <title>Valores padrão de argumentos</title>

    <para>
     Uma função pode definir valores padrão no estilo C++ para argumentos escalares, como
     a seguir:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function cafeteira ($tipo = "cappuccino")
{
    return "Fazendo uma xícara de café $type.\n";
}
echo cafeteira ();
echo cafeteira ("expresso");
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     A saída do código acima será:

     <screen>
Fazendo uma xícara de café cappucino.
Fazendo uma xícara de café expresso.
     </screen>
    </para>

    <simpara>
     O valor padrão precisa ser uma expressão constante, não (por
     exemplo) uma variável ou um membro de classe.
    </simpara>
    <para>
     Note que usando argumentos padrão, qualquer padrão deve vir após
     os argumentos sem padrão: caso contrário, as coisas não funcionarão
     como esperado. Considere o seguinte trecho de código:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function iogurtera ($tipo = "azeda", $sabor)
{
    return "Fazendo uma taça de $tipo $sabor.\n";
}

echo iogurtera ("framboesa");   // não funciona como esperado
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     A saída do exemplo acima é:

     <screen>
Warning: Missing argument 2 in call to iogurtera() in
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Fazendo uma taça de framboesa.
     </screen>
    </para>

    <para>
     Agora, compare o que está acima com este:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function iogurtera ($sabor, $tipo = "azeda")
{
    return "Fazendo uma taça de $tipo $sabor.\n";
}

echo iogurtera ("framboesa");   // funciona
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     A saída deste exemplo é:

     <screen>
Fazendo uma taça de framboesa azeda.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Número variável de argumentos</title>

    <simpara>
     O PHP4 tem suporte para um número variável de argumentos
     nas funções definidas pelo usuário. Isto é realmente bem fácil, usando
     as funções <function>func_num_args</function>,
     <function>func_get_arg</function> e
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nenhuma sintaxe especial é requerida, e a lista de argumentos ainda
     pode ser fornecida explicitamente com as definições de funções e se
     comportarão normalmente.
    </simpara>

   </sect2>

  </sect1>

  <sect1 id="functions.returning-values">
   <title>Retornando valores</title>

   <para>
    Valores podem ser retornados utilizando a instrução opcional return. Qualquer
    tipo pode ser retornado, incluindo arrays e objetos. Isto faz com que
    as função termine sua execução imediatamente e passa o controle de volta para
    a linha de onde ela foi chamada. Veja a documentação da função <function>return</function>
    para maiores informações.
    <informalexample>
     <programlisting role="php">
<![CDATA[
function quadrado ($num)
{
    return $num * $num;
}
echo quadrado (4);   // imprime '16'.
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Você não pode retornar múltiplos valores a partir de uma função, mas
    resultados similares podem ser devolvidos retornando por uma lista.

    <informalexample>
     <programlisting role="php">
<![CDATA[
function numeros_pequenos()
{
    return array (0, 1, 2);
}
list ($zero, $um, $dois) = numeros_pequenos();
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Para retornar uma referência de uma função, você precisa utilizar
    o operador de referência &amp; tanto na declaração da função como
    quando assimilando o valor retornado para a variável.
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &retorna_referencia()
{
    return $alguma_referencia;
}

$nova_referencia =& retorna_referencia();
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Para mais detalhes sobre referências, leia a seção <link
    linkend="language.references">Referências</link>.
   </simpara>
  </sect1>

  <sect1 id="functions.old-syntax">
   <title><literal>old_function</literal></title>

   <simpara>
    O comando <literal>old_function</literal> permite que você declare uma
    função usando uma sintaxe idêntica ao PHP/FI2 (exceto pelo fato de que
    você precisa substituir 'function' com 'old_function').
   </simpara>
   <simpara>
    Esta é uma implementação obsoleta, e deve ser usada somente pelo
    conversor PHP/FI2->PHP3.
   </simpara>
   <warning>
    <para>
     Funções declaradas como <literal>old_function</literal> não podem ser chamadas
     a partir de código interno do PHP. Entre outras coisas, isso significa que você
     não pode usá-las em funções como
     <function>usort</function>, <function>array_walk</function> e
     <function>register_shutdown_function</function>. Você pode contornar essa
     limitação escrevendo um invólucro de função (no formato PHP3 normal) para chamar
     o <literal>old_function</literal>.
    </para>
   </warning>

  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Funções variáveis</title>

   <para>
    O PHP suporta o conceito de funções variáveis. Isto significa que se
    um nome de variável tem parênteses no final dela, o PHP procurará
    uma função com o mesmo nome, qualquer que seja a avaliação da variável,
    e tentará executá-la. Entre outras coisas, isto pode
    ser usado para implementar callbacks, tabelas de função e assim por diante.
   </para>
   <para>
    Funções variáveis não funcionam com construtores de linguagem como
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> e outras assim. Você precisa antes construir
    uma função interceptadora (wrapper) para utilizar qualquer um desses construtores
    como funções convencionais.
   </para>
   <para>
    <example>
     <title>Exemplo de funções variáveis</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "Chamou foo()<br>\n";
}

function bar($arg = '')
{
    echo "Chamou bar(); com argumento '$arg'.<br>\n";
}

// Essa eh uma funcao wrapper para echo()
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Chama foo()

$func = 'bar';
$func('test');  // Chama bar()

$func = 'echoit';
$func('test');  // Chama echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Você também pode chamar métodos de objetos utilizando o recurso de funções
    variáveis.
    <example>
     <title>Exemplo de chama de método variável</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Var()
    {
        $name = 'Bar';
        $this->$name(); // Isto chama o método Bar()
    }

    function Bar()
    {
        echo "Bar foi chamada!";
    }
}

$foo = new Foo();
$funcname = "Var";
$foo->$funcname();  // Isto chama $foo->Var()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Veja também <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    variáveis variáveis</link> e <function>function_exists</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
